(function (Ai) { typeof define == "function" && define.amd ? define(Ai) : Ai() })(function () {
  "use strict"; function Ai(t, r) { for (var o = 0; o < r.length; o++) { const s = r[o]; if (typeof s != "string" && !Array.isArray(s)) { for (const l in s) if (l !== "default" && !(l in t)) { const d = Object.getOwnPropertyDescriptor(s, l); d && Object.defineProperty(t, l, d.get ? d : { enumerable: !0, get: () => s[l] }) } } } return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" })) } function l0(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var ad = { exports: {} }, wo = {}, Ea = { exports: {} }, Ce = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ld; function u0() { if (ld) return Ce; ld = 1; var t = Symbol.for("react.element"), r = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), l = Symbol.for("react.profiler"), d = Symbol.for("react.provider"), u = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), m = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), g = Symbol.iterator; function w(E) { return E === null || typeof E != "object" ? null : (E = g && E[g] || E["@@iterator"], typeof E == "function" ? E : null) } var C = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, b = Object.assign, S = {}; function P(E, V, ce) { this.props = E, this.context = V, this.refs = S, this.updater = ce || C } P.prototype.isReactComponent = {}, P.prototype.setState = function (E, V) { if (typeof E != "object" && typeof E != "function" && E != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, E, V, "setState") }, P.prototype.forceUpdate = function (E) { this.updater.enqueueForceUpdate(this, E, "forceUpdate") }; function R() { } R.prototype = P.prototype; function N(E, V, ce) { this.props = E, this.context = V, this.refs = S, this.updater = ce || C } var L = N.prototype = new R; L.constructor = N, b(L, P.prototype), L.isPureReactComponent = !0; var j = Array.isArray, I = Object.prototype.hasOwnProperty, K = { current: null }, H = { key: !0, ref: !0, __self: !0, __source: !0 }; function W(E, V, ce) { var se, xe = {}, me = null, Q = null; if (V != null) for (se in V.ref !== void 0 && (Q = V.ref), V.key !== void 0 && (me = "" + V.key), V) I.call(V, se) && !H.hasOwnProperty(se) && (xe[se] = V[se]); var ae = arguments.length - 2; if (ae === 1) xe.children = ce; else if (1 < ae) { for (var ve = Array(ae), ye = 0; ye < ae; ye++)ve[ye] = arguments[ye + 2]; xe.children = ve } if (E && E.defaultProps) for (se in ae = E.defaultProps, ae) xe[se] === void 0 && (xe[se] = ae[se]); return { $$typeof: t, type: E, key: me, ref: Q, props: xe, _owner: K.current } } function le(E, V) { return { $$typeof: t, type: E.type, key: V, ref: E.ref, props: E.props, _owner: E._owner } } function ie(E) { return typeof E == "object" && E !== null && E.$$typeof === t } function ge(E) { var V = { "=": "=0", ":": "=2" }; return "$" + E.replace(/[=:]/g, function (ce) { return V[ce] }) } var J = /\/+/g; function Se(E, V) { return typeof E == "object" && E !== null && E.key != null ? ge("" + E.key) : V.toString(36) } function ne(E, V, ce, se, xe) { var me = typeof E; (me === "undefined" || me === "boolean") && (E = null); var Q = !1; if (E === null) Q = !0; else switch (me) { case "string": case "number": Q = !0; break; case "object": switch (E.$$typeof) { case t: case r: Q = !0 } }if (Q) return Q = E, xe = xe(Q), E = se === "" ? "." + Se(Q, 0) : se, j(xe) ? (ce = "", E != null && (ce = E.replace(J, "$&/") + "/"), ne(xe, V, ce, "", function (ye) { return ye })) : xe != null && (ie(xe) && (xe = le(xe, ce + (!xe.key || Q && Q.key === xe.key ? "" : ("" + xe.key).replace(J, "$&/") + "/") + E)), V.push(xe)), 1; if (Q = 0, se = se === "" ? "." : se + ":", j(E)) for (var ae = 0; ae < E.length; ae++) { me = E[ae]; var ve = se + Se(me, ae); Q += ne(me, V, ce, ve, xe) } else if (ve = w(E), typeof ve == "function") for (E = ve.call(E), ae = 0; !(me = E.next()).done;)me = me.value, ve = se + Se(me, ae++), Q += ne(me, V, ce, ve, xe); else if (me === "object") throw V = String(E), Error("Objects are not valid as a React child (found: " + (V === "[object Object]" ? "object with keys {" + Object.keys(E).join(", ") + "}" : V) + "). If you meant to render a collection of children, use an array instead."); return Q } function oe(E, V, ce) { if (E == null) return E; var se = [], xe = 0; return ne(E, se, "", "", function (me) { return V.call(ce, me, xe++) }), se } function ue(E) { if (E._status === -1) { var V = E._result; V = V(), V.then(function (ce) { (E._status === 0 || E._status === -1) && (E._status = 1, E._result = ce) }, function (ce) { (E._status === 0 || E._status === -1) && (E._status = 2, E._result = ce) }), E._status === -1 && (E._status = 0, E._result = V) } if (E._status === 1) return E._result.default; throw E._result } var G = { current: null }, F = { transition: null }, Y = { ReactCurrentDispatcher: G, ReactCurrentBatchConfig: F, ReactCurrentOwner: K }; function X() { throw Error("act(...) is not supported in production builds of React.") } return Ce.Children = { map: oe, forEach: function (E, V, ce) { oe(E, function () { V.apply(this, arguments) }, ce) }, count: function (E) { var V = 0; return oe(E, function () { V++ }), V }, toArray: function (E) { return oe(E, function (V) { return V }) || [] }, only: function (E) { if (!ie(E)) throw Error("React.Children.only expected to receive a single React element child."); return E } }, Ce.Component = P, Ce.Fragment = o, Ce.Profiler = l, Ce.PureComponent = N, Ce.StrictMode = s, Ce.Suspense = h, Ce.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Y, Ce.act = X, Ce.cloneElement = function (E, V, ce) { if (E == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + E + "."); var se = b({}, E.props), xe = E.key, me = E.ref, Q = E._owner; if (V != null) { if (V.ref !== void 0 && (me = V.ref, Q = K.current), V.key !== void 0 && (xe = "" + V.key), E.type && E.type.defaultProps) var ae = E.type.defaultProps; for (ve in V) I.call(V, ve) && !H.hasOwnProperty(ve) && (se[ve] = V[ve] === void 0 && ae !== void 0 ? ae[ve] : V[ve]) } var ve = arguments.length - 2; if (ve === 1) se.children = ce; else if (1 < ve) { ae = Array(ve); for (var ye = 0; ye < ve; ye++)ae[ye] = arguments[ye + 2]; se.children = ae } return { $$typeof: t, type: E.type, key: xe, ref: me, props: se, _owner: Q } }, Ce.createContext = function (E) { return E = { $$typeof: u, _currentValue: E, _currentValue2: E, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, E.Provider = { $$typeof: d, _context: E }, E.Consumer = E }, Ce.createElement = W, Ce.createFactory = function (E) { var V = W.bind(null, E); return V.type = E, V }, Ce.createRef = function () { return { current: null } }, Ce.forwardRef = function (E) { return { $$typeof: f, render: E } }, Ce.isValidElement = ie, Ce.lazy = function (E) { return { $$typeof: v, _payload: { _status: -1, _result: E }, _init: ue } }, Ce.memo = function (E, V) { return { $$typeof: m, type: E, compare: V === void 0 ? null : V } }, Ce.startTransition = function (E) { var V = F.transition; F.transition = {}; try { E() } finally { F.transition = V } }, Ce.unstable_act = X, Ce.useCallback = function (E, V) { return G.current.useCallback(E, V) }, Ce.useContext = function (E) { return G.current.useContext(E) }, Ce.useDebugValue = function () { }, Ce.useDeferredValue = function (E) { return G.current.useDeferredValue(E) }, Ce.useEffect = function (E, V) { return G.current.useEffect(E, V) }, Ce.useId = function () { return G.current.useId() }, Ce.useImperativeHandle = function (E, V, ce) { return G.current.useImperativeHandle(E, V, ce) }, Ce.useInsertionEffect = function (E, V) { return G.current.useInsertionEffect(E, V) }, Ce.useLayoutEffect = function (E, V) { return G.current.useLayoutEffect(E, V) }, Ce.useMemo = function (E, V) { return G.current.useMemo(E, V) }, Ce.useReducer = function (E, V, ce) { return G.current.useReducer(E, V, ce) }, Ce.useRef = function (E) { return G.current.useRef(E) }, Ce.useState = function (E) { return G.current.useState(E) }, Ce.useSyncExternalStore = function (E, V, ce) { return G.current.useSyncExternalStore(E, V, ce) }, Ce.useTransition = function () { return G.current.useTransition() }, Ce.version = "18.3.1", Ce } var ud; function Ta() { return ud || (ud = 1, Ea.exports = u0()), Ea.exports }/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var cd; function c0() { if (cd) return wo; cd = 1; var t = Ta(), r = Symbol.for("react.element"), o = Symbol.for("react.fragment"), s = Object.prototype.hasOwnProperty, l = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, d = { key: !0, ref: !0, __self: !0, __source: !0 }; function u(f, h, m) { var v, g = {}, w = null, C = null; m !== void 0 && (w = "" + m), h.key !== void 0 && (w = "" + h.key), h.ref !== void 0 && (C = h.ref); for (v in h) s.call(h, v) && !d.hasOwnProperty(v) && (g[v] = h[v]); if (f && f.defaultProps) for (v in h = f.defaultProps, h) g[v] === void 0 && (g[v] = h[v]); return { $$typeof: r, type: f, key: w, ref: C, props: g, _owner: l.current } } return wo.Fragment = o, wo.jsx = u, wo.jsxs = u, wo } ad.exports = c0(); var T = ad.exports, Ra = {}, dd = { exports: {} }, dt = {}, Aa = { exports: {} }, Na = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var fd; function d0() { return fd || (fd = 1, function (t) { function r(F, Y) { var X = F.length; F.push(Y); e: for (; 0 < X;) { var E = X - 1 >>> 1, V = F[E]; if (0 < l(V, Y)) F[E] = Y, F[X] = V, X = E; else break e } } function o(F) { return F.length === 0 ? null : F[0] } function s(F) { if (F.length === 0) return null; var Y = F[0], X = F.pop(); if (X !== Y) { F[0] = X; e: for (var E = 0, V = F.length, ce = V >>> 1; E < ce;) { var se = 2 * (E + 1) - 1, xe = F[se], me = se + 1, Q = F[me]; if (0 > l(xe, X)) me < V && 0 > l(Q, xe) ? (F[E] = Q, F[me] = X, E = me) : (F[E] = xe, F[se] = X, E = se); else if (me < V && 0 > l(Q, X)) F[E] = Q, F[me] = X, E = me; else break e } } return Y } function l(F, Y) { var X = F.sortIndex - Y.sortIndex; return X !== 0 ? X : F.id - Y.id } if (typeof performance == "object" && typeof performance.now == "function") { var d = performance; t.unstable_now = function () { return d.now() } } else { var u = Date, f = u.now(); t.unstable_now = function () { return u.now() - f } } var h = [], m = [], v = 1, g = null, w = 3, C = !1, b = !1, S = !1, P = typeof setTimeout == "function" ? setTimeout : null, R = typeof clearTimeout == "function" ? clearTimeout : null, N = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function L(F) { for (var Y = o(m); Y !== null;) { if (Y.callback === null) s(m); else if (Y.startTime <= F) s(m), Y.sortIndex = Y.expirationTime, r(h, Y); else break; Y = o(m) } } function j(F) { if (S = !1, L(F), !b) if (o(h) !== null) b = !0, ue(I); else { var Y = o(m); Y !== null && G(j, Y.startTime - F) } } function I(F, Y) { b = !1, S && (S = !1, R(W), W = -1), C = !0; var X = w; try { for (L(Y), g = o(h); g !== null && (!(g.expirationTime > Y) || F && !ge());) { var E = g.callback; if (typeof E == "function") { g.callback = null, w = g.priorityLevel; var V = E(g.expirationTime <= Y); Y = t.unstable_now(), typeof V == "function" ? g.callback = V : g === o(h) && s(h), L(Y) } else s(h); g = o(h) } if (g !== null) var ce = !0; else { var se = o(m); se !== null && G(j, se.startTime - Y), ce = !1 } return ce } finally { g = null, w = X, C = !1 } } var K = !1, H = null, W = -1, le = 5, ie = -1; function ge() { return !(t.unstable_now() - ie < le) } function J() { if (H !== null) { var F = t.unstable_now(); ie = F; var Y = !0; try { Y = H(!0, F) } finally { Y ? Se() : (K = !1, H = null) } } else K = !1 } var Se; if (typeof N == "function") Se = function () { N(J) }; else if (typeof MessageChannel < "u") { var ne = new MessageChannel, oe = ne.port2; ne.port1.onmessage = J, Se = function () { oe.postMessage(null) } } else Se = function () { P(J, 0) }; function ue(F) { H = F, K || (K = !0, Se()) } function G(F, Y) { W = P(function () { F(t.unstable_now()) }, Y) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (F) { F.callback = null }, t.unstable_continueExecution = function () { b || C || (b = !0, ue(I)) }, t.unstable_forceFrameRate = function (F) { 0 > F || 125 < F ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : le = 0 < F ? Math.floor(1e3 / F) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return w }, t.unstable_getFirstCallbackNode = function () { return o(h) }, t.unstable_next = function (F) { switch (w) { case 1: case 2: case 3: var Y = 3; break; default: Y = w }var X = w; w = Y; try { return F() } finally { w = X } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (F, Y) { switch (F) { case 1: case 2: case 3: case 4: case 5: break; default: F = 3 }var X = w; w = F; try { return Y() } finally { w = X } }, t.unstable_scheduleCallback = function (F, Y, X) { var E = t.unstable_now(); switch (typeof X == "object" && X !== null ? (X = X.delay, X = typeof X == "number" && 0 < X ? E + X : E) : X = E, F) { case 1: var V = -1; break; case 2: V = 250; break; case 5: V = 1073741823; break; case 4: V = 1e4; break; default: V = 5e3 }return V = X + V, F = { id: v++, callback: Y, priorityLevel: F, startTime: X, expirationTime: V, sortIndex: -1 }, X > E ? (F.sortIndex = X, r(m, F), o(h) === null && F === o(m) && (S ? (R(W), W = -1) : S = !0, G(j, X - E))) : (F.sortIndex = V, r(h, F), b || C || (b = !0, ue(I))), F }, t.unstable_shouldYield = ge, t.unstable_wrapCallback = function (F) { var Y = w; return function () { var X = w; w = Y; try { return F.apply(this, arguments) } finally { w = X } } } }(Na)), Na } var pd; function f0() { return pd || (pd = 1, Aa.exports = d0()), Aa.exports }/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hd; function p0() {
    if (hd) return dt; hd = 1; var t = Ta(), r = f0(); function o(e) { for (var n = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, i = 1; i < arguments.length; i++)n += "&args[]=" + encodeURIComponent(arguments[i]); return "Minified React error #" + e + "; visit " + n + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var s = new Set, l = {}; function d(e, n) { u(e, n), u(e + "Capture", n) } function u(e, n) { for (l[e] = n, e = 0; e < n.length; e++)s.add(n[e]) } var f = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), h = Object.prototype.hasOwnProperty, m = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, v = {}, g = {}; function w(e) { return h.call(g, e) ? !0 : h.call(v, e) ? !1 : m.test(e) ? g[e] = !0 : (v[e] = !0, !1) } function C(e, n, i, a) { if (i !== null && i.type === 0) return !1; switch (typeof n) { case "function": case "symbol": return !0; case "boolean": return a ? !1 : i !== null ? !i.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function b(e, n, i, a) { if (n === null || typeof n > "u" || C(e, n, i, a)) return !0; if (a) return !1; if (i !== null) switch (i.type) { case 3: return !n; case 4: return n === !1; case 5: return isNaN(n); case 6: return isNaN(n) || 1 > n }return !1 } function S(e, n, i, a, c, p, y) { this.acceptsBooleans = n === 2 || n === 3 || n === 4, this.attributeName = a, this.attributeNamespace = c, this.mustUseProperty = i, this.propertyName = e, this.type = n, this.sanitizeURL = p, this.removeEmptyString = y } var P = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { P[e] = new S(e, 0, !1, e, null, !1, !1) }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var n = e[0]; P[n] = new S(n, 1, !1, e[1], null, !1, !1) }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { P[e] = new S(e, 2, !1, e.toLowerCase(), null, !1, !1) }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { P[e] = new S(e, 2, !1, e, null, !1, !1) }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { P[e] = new S(e, 3, !1, e.toLowerCase(), null, !1, !1) }), ["checked", "multiple", "muted", "selected"].forEach(function (e) { P[e] = new S(e, 3, !0, e, null, !1, !1) }), ["capture", "download"].forEach(function (e) { P[e] = new S(e, 4, !1, e, null, !1, !1) }), ["cols", "rows", "size", "span"].forEach(function (e) { P[e] = new S(e, 6, !1, e, null, !1, !1) }), ["rowSpan", "start"].forEach(function (e) { P[e] = new S(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var R = /[\-:]([a-z])/g; function N(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var n = e.replace(R, N); P[n] = new S(n, 1, !1, e, null, !1, !1) }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var n = e.replace(R, N); P[n] = new S(n, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) }), ["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var n = e.replace(R, N); P[n] = new S(n, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) }), ["tabIndex", "crossOrigin"].forEach(function (e) { P[e] = new S(e, 1, !1, e.toLowerCase(), null, !1, !1) }), P.xlinkHref = new S("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (e) { P[e] = new S(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function L(e, n, i, a) { var c = P.hasOwnProperty(n) ? P[n] : null; (c !== null ? c.type !== 0 : a || !(2 < n.length) || n[0] !== "o" && n[0] !== "O" || n[1] !== "n" && n[1] !== "N") && (b(n, i, c, a) && (i = null), a || c === null ? w(n) && (i === null ? e.removeAttribute(n) : e.setAttribute(n, "" + i)) : c.mustUseProperty ? e[c.propertyName] = i === null ? c.type === 3 ? !1 : "" : i : (n = c.attributeName, a = c.attributeNamespace, i === null ? e.removeAttribute(n) : (c = c.type, i = c === 3 || c === 4 && i === !0 ? "" : "" + i, a ? e.setAttributeNS(a, n, i) : e.setAttribute(n, i)))) } var j = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, I = Symbol.for("react.element"), K = Symbol.for("react.portal"), H = Symbol.for("react.fragment"), W = Symbol.for("react.strict_mode"), le = Symbol.for("react.profiler"), ie = Symbol.for("react.provider"), ge = Symbol.for("react.context"), J = Symbol.for("react.forward_ref"), Se = Symbol.for("react.suspense"), ne = Symbol.for("react.suspense_list"), oe = Symbol.for("react.memo"), ue = Symbol.for("react.lazy"), G = Symbol.for("react.offscreen"), F = Symbol.iterator; function Y(e) { return e === null || typeof e != "object" ? null : (e = F && e[F] || e["@@iterator"], typeof e == "function" ? e : null) } var X = Object.assign, E; function V(e) {
      if (E === void 0) try { throw Error() } catch (i) { var n = i.stack.trim().match(/\n( *(at )?)/); E = n && n[1] || "" } return `
`+ E + e
    } var ce = !1; function se(e, n) {
      if (!e || ce) return ""; ce = !0; var i = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (n) if (n = function () { throw Error() }, Object.defineProperty(n.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(n, []) } catch (_) { var a = _ } Reflect.construct(e, [], n) } else { try { n.call() } catch (_) { a = _ } e.call(n.prototype) } else { try { throw Error() } catch (_) { a = _ } e() } } catch (_) {
        if (_ && a && typeof _.stack == "string") {
          for (var c = _.stack.split(`
`), p = a.stack.split(`
`), y = c.length - 1, k = p.length - 1; 1 <= y && 0 <= k && c[y] !== p[k];)k--; for (; 1 <= y && 0 <= k; y--, k--)if (c[y] !== p[k]) {
            if (y !== 1 || k !== 1) do if (y--, k--, 0 > k || c[y] !== p[k]) {
              var A = `
`+ c[y].replace(" at new ", " at "); return e.displayName && A.includes("<anonymous>") && (A = A.replace("<anonymous>", e.displayName)), A
            } while (1 <= y && 0 <= k); break
          }
        }
      } finally { ce = !1, Error.prepareStackTrace = i } return (e = e ? e.displayName || e.name : "") ? V(e) : ""
    } function xe(e) { switch (e.tag) { case 5: return V(e.type); case 16: return V("Lazy"); case 13: return V("Suspense"); case 19: return V("SuspenseList"); case 0: case 2: case 15: return e = se(e.type, !1), e; case 11: return e = se(e.type.render, !1), e; case 1: return e = se(e.type, !0), e; default: return "" } } function me(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case H: return "Fragment"; case K: return "Portal"; case le: return "Profiler"; case W: return "StrictMode"; case Se: return "Suspense"; case ne: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case ge: return (e.displayName || "Context") + ".Consumer"; case ie: return (e._context.displayName || "Context") + ".Provider"; case J: var n = e.render; return e = e.displayName, e || (e = n.displayName || n.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case oe: return n = e.displayName || null, n !== null ? n : me(e.type) || "Memo"; case ue: n = e._payload, e = e._init; try { return me(e(n)) } catch { } }return null } function Q(e) { var n = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (n.displayName || "Context") + ".Consumer"; case 10: return (n._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = n.render, e = e.displayName || e.name || "", n.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return n; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return me(n); case 8: return n === W ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof n == "function") return n.displayName || n.name || null; if (typeof n == "string") return n }return null } function ae(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function ve(e) { var n = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (n === "checkbox" || n === "radio") } function ye(e) { var n = ve(e) ? "checked" : "value", i = Object.getOwnPropertyDescriptor(e.constructor.prototype, n), a = "" + e[n]; if (!e.hasOwnProperty(n) && typeof i < "u" && typeof i.get == "function" && typeof i.set == "function") { var c = i.get, p = i.set; return Object.defineProperty(e, n, { configurable: !0, get: function () { return c.call(this) }, set: function (y) { a = "" + y, p.call(this, y) } }), Object.defineProperty(e, n, { enumerable: i.enumerable }), { getValue: function () { return a }, setValue: function (y) { a = "" + y }, stopTracking: function () { e._valueTracker = null, delete e[n] } } } } function be(e) { e._valueTracker || (e._valueTracker = ye(e)) } function Re(e) { if (!e) return !1; var n = e._valueTracker; if (!n) return !0; var i = n.getValue(), a = ""; return e && (a = ve(e) ? e.checked ? "true" : "false" : e.value), e = a, e !== i ? (n.setValue(e), !0) : !1 } function Be(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function Ot(e, n) { var i = n.checked; return X({}, n, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: i ?? e._wrapperState.initialChecked }) } function Hr(e, n) { var i = n.defaultValue == null ? "" : n.defaultValue, a = n.checked != null ? n.checked : n.defaultChecked; i = ae(n.value != null ? n.value : i), e._wrapperState = { initialChecked: a, initialValue: i, controlled: n.type === "checkbox" || n.type === "radio" ? n.checked != null : n.value != null } } function Kr(e, n) { n = n.checked, n != null && L(e, "checked", n, !1) } function ur(e, n) { Kr(e, n); var i = ae(n.value), a = n.type; if (i != null) a === "number" ? (i === 0 && e.value === "" || e.value != i) && (e.value = "" + i) : e.value !== "" + i && (e.value = "" + i); else if (a === "submit" || a === "reset") { e.removeAttribute("value"); return } n.hasOwnProperty("value") ? gu(e, n.type, i) : n.hasOwnProperty("defaultValue") && gu(e, n.type, ae(n.defaultValue)), n.checked == null && n.defaultChecked != null && (e.defaultChecked = !!n.defaultChecked) } function vg(e, n, i) { if (n.hasOwnProperty("value") || n.hasOwnProperty("defaultValue")) { var a = n.type; if (!(a !== "submit" && a !== "reset" || n.value !== void 0 && n.value !== null)) return; n = "" + e._wrapperState.initialValue, i || n === e.value || (e.value = n), e.defaultValue = n } i = e.name, i !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, i !== "" && (e.name = i) } function gu(e, n, i) { (n !== "number" || Be(e.ownerDocument) !== e) && (i == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + i && (e.defaultValue = "" + i)) } var $o = Array.isArray; function Gr(e, n, i, a) { if (e = e.options, n) { n = {}; for (var c = 0; c < i.length; c++)n["$" + i[c]] = !0; for (i = 0; i < e.length; i++)c = n.hasOwnProperty("$" + e[i].value), e[i].selected !== c && (e[i].selected = c), c && a && (e[i].defaultSelected = !0) } else { for (i = "" + ae(i), n = null, c = 0; c < e.length; c++) { if (e[c].value === i) { e[c].selected = !0, a && (e[c].defaultSelected = !0); return } n !== null || e[c].disabled || (n = e[c]) } n !== null && (n.selected = !0) } } function vu(e, n) { if (n.dangerouslySetInnerHTML != null) throw Error(o(91)); return X({}, n, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function yg(e, n) { var i = n.value; if (i == null) { if (i = n.children, n = n.defaultValue, i != null) { if (n != null) throw Error(o(92)); if ($o(i)) { if (1 < i.length) throw Error(o(93)); i = i[0] } n = i } n == null && (n = ""), i = n } e._wrapperState = { initialValue: ae(i) } } function wg(e, n) { var i = ae(n.value), a = ae(n.defaultValue); i != null && (i = "" + i, i !== e.value && (e.value = i), n.defaultValue == null && e.defaultValue !== i && (e.defaultValue = i)), a != null && (e.defaultValue = "" + a) } function xg(e) { var n = e.textContent; n === e._wrapperState.initialValue && n !== "" && n !== null && (e.value = n) } function Sg(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function yu(e, n) { return e == null || e === "http://www.w3.org/1999/xhtml" ? Sg(n) : e === "http://www.w3.org/2000/svg" && n === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var ys, Cg = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (n, i, a, c) { MSApp.execUnsafeLocalFunction(function () { return e(n, i, a, c) }) } : e }(function (e, n) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = n; else { for (ys = ys || document.createElement("div"), ys.innerHTML = "<svg>" + n.valueOf().toString() + "</svg>", n = ys.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; n.firstChild;)e.appendChild(n.firstChild) } }); function Ho(e, n) { if (n) { var i = e.firstChild; if (i && i === e.lastChild && i.nodeType === 3) { i.nodeValue = n; return } } e.textContent = n } var Ko = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, LP = ["Webkit", "ms", "Moz", "O"]; Object.keys(Ko).forEach(function (e) { LP.forEach(function (n) { n = n + e.charAt(0).toUpperCase() + e.substring(1), Ko[n] = Ko[e] }) }); function bg(e, n, i) { return n == null || typeof n == "boolean" || n === "" ? "" : i || typeof n != "number" || n === 0 || Ko.hasOwnProperty(e) && Ko[e] ? ("" + n).trim() : n + "px" } function kg(e, n) { e = e.style; for (var i in n) if (n.hasOwnProperty(i)) { var a = i.indexOf("--") === 0, c = bg(i, n[i], a); i === "float" && (i = "cssFloat"), a ? e.setProperty(i, c) : e[i] = c } } var DP = X({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function wu(e, n) { if (n) { if (DP[e] && (n.children != null || n.dangerouslySetInnerHTML != null)) throw Error(o(137, e)); if (n.dangerouslySetInnerHTML != null) { if (n.children != null) throw Error(o(60)); if (typeof n.dangerouslySetInnerHTML != "object" || !("__html" in n.dangerouslySetInnerHTML)) throw Error(o(61)) } if (n.style != null && typeof n.style != "object") throw Error(o(62)) } } function xu(e, n) { if (e.indexOf("-") === -1) return typeof n.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Su = null; function Cu(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var bu = null, Yr = null, Xr = null; function Pg(e) { if (e = hi(e)) { if (typeof bu != "function") throw Error(o(280)); var n = e.stateNode; n && (n = Bs(n), bu(e.stateNode, e.type, n)) } } function Eg(e) { Yr ? Xr ? Xr.push(e) : Xr = [e] : Yr = e } function Tg() { if (Yr) { var e = Yr, n = Xr; if (Xr = Yr = null, Pg(e), n) for (e = 0; e < n.length; e++)Pg(n[e]) } } function Rg(e, n) { return e(n) } function Ag() { } var ku = !1; function Ng(e, n, i) { if (ku) return e(n, i); ku = !0; try { return Rg(e, n, i) } finally { ku = !1, (Yr !== null || Xr !== null) && (Ag(), Tg()) } } function Go(e, n) { var i = e.stateNode; if (i === null) return null; var a = Bs(i); if (a === null) return null; i = a[n]; e: switch (n) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (a = !a.disabled) || (e = e.type, a = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !a; break e; default: e = !1 }if (e) return null; if (i && typeof i != "function") throw Error(o(231, n, typeof i)); return i } var Pu = !1; if (f) try { var Yo = {}; Object.defineProperty(Yo, "passive", { get: function () { Pu = !0 } }), window.addEventListener("test", Yo, Yo), window.removeEventListener("test", Yo, Yo) } catch { Pu = !1 } function jP(e, n, i, a, c, p, y, k, A) { var _ = Array.prototype.slice.call(arguments, 3); try { n.apply(i, _) } catch (B) { this.onError(B) } } var Xo = !1, ws = null, xs = !1, Eu = null, OP = { onError: function (e) { Xo = !0, ws = e } }; function _P(e, n, i, a, c, p, y, k, A) { Xo = !1, ws = null, jP.apply(OP, arguments) } function IP(e, n, i, a, c, p, y, k, A) { if (_P.apply(this, arguments), Xo) { if (Xo) { var _ = ws; Xo = !1, ws = null } else throw Error(o(198)); xs || (xs = !0, Eu = _) } } function cr(e) { var n = e, i = e; if (e.alternate) for (; n.return;)n = n.return; else { e = n; do n = e, n.flags & 4098 && (i = n.return), e = n.return; while (e) } return n.tag === 3 ? i : null } function Mg(e) { if (e.tag === 13) { var n = e.memoizedState; if (n === null && (e = e.alternate, e !== null && (n = e.memoizedState)), n !== null) return n.dehydrated } return null } function Lg(e) { if (cr(e) !== e) throw Error(o(188)) } function VP(e) { var n = e.alternate; if (!n) { if (n = cr(e), n === null) throw Error(o(188)); return n !== e ? null : e } for (var i = e, a = n; ;) { var c = i.return; if (c === null) break; var p = c.alternate; if (p === null) { if (a = c.return, a !== null) { i = a; continue } break } if (c.child === p.child) { for (p = c.child; p;) { if (p === i) return Lg(c), e; if (p === a) return Lg(c), n; p = p.sibling } throw Error(o(188)) } if (i.return !== a.return) i = c, a = p; else { for (var y = !1, k = c.child; k;) { if (k === i) { y = !0, i = c, a = p; break } if (k === a) { y = !0, a = c, i = p; break } k = k.sibling } if (!y) { for (k = p.child; k;) { if (k === i) { y = !0, i = p, a = c; break } if (k === a) { y = !0, a = p, i = c; break } k = k.sibling } if (!y) throw Error(o(189)) } } if (i.alternate !== a) throw Error(o(190)) } if (i.tag !== 3) throw Error(o(188)); return i.stateNode.current === i ? e : n } function Dg(e) { return e = VP(e), e !== null ? jg(e) : null } function jg(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var n = jg(e); if (n !== null) return n; e = e.sibling } return null } var Og = r.unstable_scheduleCallback, _g = r.unstable_cancelCallback, FP = r.unstable_shouldYield, zP = r.unstable_requestPaint, Ue = r.unstable_now, BP = r.unstable_getCurrentPriorityLevel, Tu = r.unstable_ImmediatePriority, Ig = r.unstable_UserBlockingPriority, Ss = r.unstable_NormalPriority, UP = r.unstable_LowPriority, Vg = r.unstable_IdlePriority, Cs = null, Xt = null; function WP(e) { if (Xt && typeof Xt.onCommitFiberRoot == "function") try { Xt.onCommitFiberRoot(Cs, e, void 0, (e.current.flags & 128) === 128) } catch { } } var _t = Math.clz32 ? Math.clz32 : KP, $P = Math.log, HP = Math.LN2; function KP(e) { return e >>>= 0, e === 0 ? 32 : 31 - ($P(e) / HP | 0) | 0 } var bs = 64, ks = 4194304; function Qo(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function Ps(e, n) { var i = e.pendingLanes; if (i === 0) return 0; var a = 0, c = e.suspendedLanes, p = e.pingedLanes, y = i & 268435455; if (y !== 0) { var k = y & ~c; k !== 0 ? a = Qo(k) : (p &= y, p !== 0 && (a = Qo(p))) } else y = i & ~c, y !== 0 ? a = Qo(y) : p !== 0 && (a = Qo(p)); if (a === 0) return 0; if (n !== 0 && n !== a && !(n & c) && (c = a & -a, p = n & -n, c >= p || c === 16 && (p & 4194240) !== 0)) return n; if (a & 4 && (a |= i & 16), n = e.entangledLanes, n !== 0) for (e = e.entanglements, n &= a; 0 < n;)i = 31 - _t(n), c = 1 << i, a |= e[i], n &= ~c; return a } function GP(e, n) { switch (e) { case 1: case 2: case 4: return n + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return n + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function YP(e, n) { for (var i = e.suspendedLanes, a = e.pingedLanes, c = e.expirationTimes, p = e.pendingLanes; 0 < p;) { var y = 31 - _t(p), k = 1 << y, A = c[y]; A === -1 ? (!(k & i) || k & a) && (c[y] = GP(k, n)) : A <= n && (e.expiredLanes |= k), p &= ~k } } function Ru(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function Fg() { var e = bs; return bs <<= 1, !(bs & 4194240) && (bs = 64), e } function Au(e) { for (var n = [], i = 0; 31 > i; i++)n.push(e); return n } function qo(e, n, i) { e.pendingLanes |= n, n !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, n = 31 - _t(n), e[n] = i } function XP(e, n) { var i = e.pendingLanes & ~n; e.pendingLanes = n, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= n, e.mutableReadLanes &= n, e.entangledLanes &= n, n = e.entanglements; var a = e.eventTimes; for (e = e.expirationTimes; 0 < i;) { var c = 31 - _t(i), p = 1 << c; n[c] = 0, a[c] = -1, e[c] = -1, i &= ~p } } function Nu(e, n) { var i = e.entangledLanes |= n; for (e = e.entanglements; i;) { var a = 31 - _t(i), c = 1 << a; c & n | e[a] & n && (e[a] |= n), i &= ~c } } var Ee = 0; function zg(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1 } var Bg, Mu, Ug, Wg, $g, Lu = !1, Es = [], On = null, _n = null, In = null, Zo = new Map, Jo = new Map, Vn = [], QP = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Hg(e, n) { switch (e) { case "focusin": case "focusout": On = null; break; case "dragenter": case "dragleave": _n = null; break; case "mouseover": case "mouseout": In = null; break; case "pointerover": case "pointerout": Zo.delete(n.pointerId); break; case "gotpointercapture": case "lostpointercapture": Jo.delete(n.pointerId) } } function ei(e, n, i, a, c, p) { return e === null || e.nativeEvent !== p ? (e = { blockedOn: n, domEventName: i, eventSystemFlags: a, nativeEvent: p, targetContainers: [c] }, n !== null && (n = hi(n), n !== null && Mu(n)), e) : (e.eventSystemFlags |= a, n = e.targetContainers, c !== null && n.indexOf(c) === -1 && n.push(c), e) } function qP(e, n, i, a, c) { switch (n) { case "focusin": return On = ei(On, e, n, i, a, c), !0; case "dragenter": return _n = ei(_n, e, n, i, a, c), !0; case "mouseover": return In = ei(In, e, n, i, a, c), !0; case "pointerover": var p = c.pointerId; return Zo.set(p, ei(Zo.get(p) || null, e, n, i, a, c)), !0; case "gotpointercapture": return p = c.pointerId, Jo.set(p, ei(Jo.get(p) || null, e, n, i, a, c)), !0 }return !1 } function Kg(e) { var n = dr(e.target); if (n !== null) { var i = cr(n); if (i !== null) { if (n = i.tag, n === 13) { if (n = Mg(i), n !== null) { e.blockedOn = n, $g(e.priority, function () { Ug(i) }); return } } else if (n === 3 && i.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = i.tag === 3 ? i.stateNode.containerInfo : null; return } } } e.blockedOn = null } function Ts(e) { if (e.blockedOn !== null) return !1; for (var n = e.targetContainers; 0 < n.length;) { var i = ju(e.domEventName, e.eventSystemFlags, n[0], e.nativeEvent); if (i === null) { i = e.nativeEvent; var a = new i.constructor(i.type, i); Su = a, i.target.dispatchEvent(a), Su = null } else return n = hi(i), n !== null && Mu(n), e.blockedOn = i, !1; n.shift() } return !0 } function Gg(e, n, i) { Ts(e) && i.delete(n) } function ZP() { Lu = !1, On !== null && Ts(On) && (On = null), _n !== null && Ts(_n) && (_n = null), In !== null && Ts(In) && (In = null), Zo.forEach(Gg), Jo.forEach(Gg) } function ti(e, n) { e.blockedOn === n && (e.blockedOn = null, Lu || (Lu = !0, r.unstable_scheduleCallback(r.unstable_NormalPriority, ZP))) } function ni(e) { function n(c) { return ti(c, e) } if (0 < Es.length) { ti(Es[0], e); for (var i = 1; i < Es.length; i++) { var a = Es[i]; a.blockedOn === e && (a.blockedOn = null) } } for (On !== null && ti(On, e), _n !== null && ti(_n, e), In !== null && ti(In, e), Zo.forEach(n), Jo.forEach(n), i = 0; i < Vn.length; i++)a = Vn[i], a.blockedOn === e && (a.blockedOn = null); for (; 0 < Vn.length && (i = Vn[0], i.blockedOn === null);)Kg(i), i.blockedOn === null && Vn.shift() } var Qr = j.ReactCurrentBatchConfig, Rs = !0; function JP(e, n, i, a) { var c = Ee, p = Qr.transition; Qr.transition = null; try { Ee = 1, Du(e, n, i, a) } finally { Ee = c, Qr.transition = p } } function eE(e, n, i, a) { var c = Ee, p = Qr.transition; Qr.transition = null; try { Ee = 4, Du(e, n, i, a) } finally { Ee = c, Qr.transition = p } } function Du(e, n, i, a) { if (Rs) { var c = ju(e, n, i, a); if (c === null) qu(e, n, a, As, i), Hg(e, a); else if (qP(c, e, n, i, a)) a.stopPropagation(); else if (Hg(e, a), n & 4 && -1 < QP.indexOf(e)) { for (; c !== null;) { var p = hi(c); if (p !== null && Bg(p), p = ju(e, n, i, a), p === null && qu(e, n, a, As, i), p === c) break; c = p } c !== null && a.stopPropagation() } else qu(e, n, a, null, i) } } var As = null; function ju(e, n, i, a) { if (As = null, e = Cu(a), e = dr(e), e !== null) if (n = cr(e), n === null) e = null; else if (i = n.tag, i === 13) { if (e = Mg(n), e !== null) return e; e = null } else if (i === 3) { if (n.stateNode.current.memoizedState.isDehydrated) return n.tag === 3 ? n.stateNode.containerInfo : null; e = null } else n !== e && (e = null); return As = e, null } function Yg(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (BP()) { case Tu: return 1; case Ig: return 4; case Ss: case UP: return 16; case Vg: return 536870912; default: return 16 }default: return 16 } } var Fn = null, Ou = null, Ns = null; function Xg() { if (Ns) return Ns; var e, n = Ou, i = n.length, a, c = "value" in Fn ? Fn.value : Fn.textContent, p = c.length; for (e = 0; e < i && n[e] === c[e]; e++); var y = i - e; for (a = 1; a <= y && n[i - a] === c[p - a]; a++); return Ns = c.slice(e, 1 < a ? 1 - a : void 0) } function Ms(e) { var n = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && n === 13 && (e = 13)) : e = n, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function Ls() { return !0 } function Qg() { return !1 } function xt(e) { function n(i, a, c, p, y) { this._reactName = i, this._targetInst = c, this.type = a, this.nativeEvent = p, this.target = y, this.currentTarget = null; for (var k in e) e.hasOwnProperty(k) && (i = e[k], this[k] = i ? i(p) : p[k]); return this.isDefaultPrevented = (p.defaultPrevented != null ? p.defaultPrevented : p.returnValue === !1) ? Ls : Qg, this.isPropagationStopped = Qg, this } return X(n.prototype, { preventDefault: function () { this.defaultPrevented = !0; var i = this.nativeEvent; i && (i.preventDefault ? i.preventDefault() : typeof i.returnValue != "unknown" && (i.returnValue = !1), this.isDefaultPrevented = Ls) }, stopPropagation: function () { var i = this.nativeEvent; i && (i.stopPropagation ? i.stopPropagation() : typeof i.cancelBubble != "unknown" && (i.cancelBubble = !0), this.isPropagationStopped = Ls) }, persist: function () { }, isPersistent: Ls }), n } var qr = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, _u = xt(qr), ri = X({}, qr, { view: 0, detail: 0 }), tE = xt(ri), Iu, Vu, oi, Ds = X({}, ri, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zu, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== oi && (oi && e.type === "mousemove" ? (Iu = e.screenX - oi.screenX, Vu = e.screenY - oi.screenY) : Vu = Iu = 0, oi = e), Iu) }, movementY: function (e) { return "movementY" in e ? e.movementY : Vu } }), qg = xt(Ds), nE = X({}, Ds, { dataTransfer: 0 }), rE = xt(nE), oE = X({}, ri, { relatedTarget: 0 }), Fu = xt(oE), iE = X({}, qr, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), sE = xt(iE), aE = X({}, qr, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), lE = xt(aE), uE = X({}, qr, { data: 0 }), Zg = xt(uE), cE = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, dE = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, fE = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function pE(e) { var n = this.nativeEvent; return n.getModifierState ? n.getModifierState(e) : (e = fE[e]) ? !!n[e] : !1 } function zu() { return pE } var hE = X({}, ri, { key: function (e) { if (e.key) { var n = cE[e.key] || e.key; if (n !== "Unidentified") return n } return e.type === "keypress" ? (e = Ms(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? dE[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zu, charCode: function (e) { return e.type === "keypress" ? Ms(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? Ms(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), mE = xt(hE), gE = X({}, Ds, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Jg = xt(gE), vE = X({}, ri, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zu }), yE = xt(vE), wE = X({}, qr, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), xE = xt(wE), SE = X({}, Ds, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), CE = xt(SE), bE = [9, 13, 27, 32], Bu = f && "CompositionEvent" in window, ii = null; f && "documentMode" in document && (ii = document.documentMode); var kE = f && "TextEvent" in window && !ii, ev = f && (!Bu || ii && 8 < ii && 11 >= ii), tv = String.fromCharCode(32), nv = !1; function rv(e, n) { switch (e) { case "keyup": return bE.indexOf(n.keyCode) !== -1; case "keydown": return n.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function ov(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var Zr = !1; function PE(e, n) { switch (e) { case "compositionend": return ov(n); case "keypress": return n.which !== 32 ? null : (nv = !0, tv); case "textInput": return e = n.data, e === tv && nv ? null : e; default: return null } } function EE(e, n) { if (Zr) return e === "compositionend" || !Bu && rv(e, n) ? (e = Xg(), Ns = Ou = Fn = null, Zr = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(n.ctrlKey || n.altKey || n.metaKey) || n.ctrlKey && n.altKey) { if (n.char && 1 < n.char.length) return n.char; if (n.which) return String.fromCharCode(n.which) } return null; case "compositionend": return ev && n.locale !== "ko" ? null : n.data; default: return null } } var TE = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function iv(e) { var n = e && e.nodeName && e.nodeName.toLowerCase(); return n === "input" ? !!TE[e.type] : n === "textarea" } function sv(e, n, i, a) { Eg(a), n = Vs(n, "onChange"), 0 < n.length && (i = new _u("onChange", "change", null, i, a), e.push({ event: i, listeners: n })) } var si = null, ai = null; function RE(e) { kv(e, 0) } function js(e) { var n = ro(e); if (Re(n)) return e } function AE(e, n) { if (e === "change") return n } var av = !1; if (f) { var Uu; if (f) { var Wu = "oninput" in document; if (!Wu) { var lv = document.createElement("div"); lv.setAttribute("oninput", "return;"), Wu = typeof lv.oninput == "function" } Uu = Wu } else Uu = !1; av = Uu && (!document.documentMode || 9 < document.documentMode) } function uv() { si && (si.detachEvent("onpropertychange", cv), ai = si = null) } function cv(e) { if (e.propertyName === "value" && js(ai)) { var n = []; sv(n, ai, e, Cu(e)), Ng(RE, n) } } function NE(e, n, i) { e === "focusin" ? (uv(), si = n, ai = i, si.attachEvent("onpropertychange", cv)) : e === "focusout" && uv() } function ME(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return js(ai) } function LE(e, n) { if (e === "click") return js(n) } function DE(e, n) { if (e === "input" || e === "change") return js(n) } function jE(e, n) { return e === n && (e !== 0 || 1 / e === 1 / n) || e !== e && n !== n } var It = typeof Object.is == "function" ? Object.is : jE; function li(e, n) { if (It(e, n)) return !0; if (typeof e != "object" || e === null || typeof n != "object" || n === null) return !1; var i = Object.keys(e), a = Object.keys(n); if (i.length !== a.length) return !1; for (a = 0; a < i.length; a++) { var c = i[a]; if (!h.call(n, c) || !It(e[c], n[c])) return !1 } return !0 } function dv(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function fv(e, n) { var i = dv(e); e = 0; for (var a; i;) { if (i.nodeType === 3) { if (a = e + i.textContent.length, e <= n && a >= n) return { node: i, offset: n - e }; e = a } e: { for (; i;) { if (i.nextSibling) { i = i.nextSibling; break e } i = i.parentNode } i = void 0 } i = dv(i) } } function pv(e, n) { return e && n ? e === n ? !0 : e && e.nodeType === 3 ? !1 : n && n.nodeType === 3 ? pv(e, n.parentNode) : "contains" in e ? e.contains(n) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(n) & 16) : !1 : !1 } function hv() { for (var e = window, n = Be(); n instanceof e.HTMLIFrameElement;) { try { var i = typeof n.contentWindow.location.href == "string" } catch { i = !1 } if (i) e = n.contentWindow; else break; n = Be(e.document) } return n } function $u(e) { var n = e && e.nodeName && e.nodeName.toLowerCase(); return n && (n === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || n === "textarea" || e.contentEditable === "true") } function OE(e) { var n = hv(), i = e.focusedElem, a = e.selectionRange; if (n !== i && i && i.ownerDocument && pv(i.ownerDocument.documentElement, i)) { if (a !== null && $u(i)) { if (n = a.start, e = a.end, e === void 0 && (e = n), "selectionStart" in i) i.selectionStart = n, i.selectionEnd = Math.min(e, i.value.length); else if (e = (n = i.ownerDocument || document) && n.defaultView || window, e.getSelection) { e = e.getSelection(); var c = i.textContent.length, p = Math.min(a.start, c); a = a.end === void 0 ? p : Math.min(a.end, c), !e.extend && p > a && (c = a, a = p, p = c), c = fv(i, p); var y = fv(i, a); c && y && (e.rangeCount !== 1 || e.anchorNode !== c.node || e.anchorOffset !== c.offset || e.focusNode !== y.node || e.focusOffset !== y.offset) && (n = n.createRange(), n.setStart(c.node, c.offset), e.removeAllRanges(), p > a ? (e.addRange(n), e.extend(y.node, y.offset)) : (n.setEnd(y.node, y.offset), e.addRange(n))) } } for (n = [], e = i; e = e.parentNode;)e.nodeType === 1 && n.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof i.focus == "function" && i.focus(), i = 0; i < n.length; i++)e = n[i], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var _E = f && "documentMode" in document && 11 >= document.documentMode, Jr = null, Hu = null, ui = null, Ku = !1; function mv(e, n, i) { var a = i.window === i ? i.document : i.nodeType === 9 ? i : i.ownerDocument; Ku || Jr == null || Jr !== Be(a) || (a = Jr, "selectionStart" in a && $u(a) ? a = { start: a.selectionStart, end: a.selectionEnd } : (a = (a.ownerDocument && a.ownerDocument.defaultView || window).getSelection(), a = { anchorNode: a.anchorNode, anchorOffset: a.anchorOffset, focusNode: a.focusNode, focusOffset: a.focusOffset }), ui && li(ui, a) || (ui = a, a = Vs(Hu, "onSelect"), 0 < a.length && (n = new _u("onSelect", "select", null, n, i), e.push({ event: n, listeners: a }), n.target = Jr))) } function Os(e, n) { var i = {}; return i[e.toLowerCase()] = n.toLowerCase(), i["Webkit" + e] = "webkit" + n, i["Moz" + e] = "moz" + n, i } var eo = { animationend: Os("Animation", "AnimationEnd"), animationiteration: Os("Animation", "AnimationIteration"), animationstart: Os("Animation", "AnimationStart"), transitionend: Os("Transition", "TransitionEnd") }, Gu = {}, gv = {}; f && (gv = document.createElement("div").style, "AnimationEvent" in window || (delete eo.animationend.animation, delete eo.animationiteration.animation, delete eo.animationstart.animation), "TransitionEvent" in window || delete eo.transitionend.transition); function _s(e) { if (Gu[e]) return Gu[e]; if (!eo[e]) return e; var n = eo[e], i; for (i in n) if (n.hasOwnProperty(i) && i in gv) return Gu[e] = n[i]; return e } var vv = _s("animationend"), yv = _s("animationiteration"), wv = _s("animationstart"), xv = _s("transitionend"), Sv = new Map, Cv = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function zn(e, n) { Sv.set(e, n), d(n, [e]) } for (var Yu = 0; Yu < Cv.length; Yu++) { var Xu = Cv[Yu], IE = Xu.toLowerCase(), VE = Xu[0].toUpperCase() + Xu.slice(1); zn(IE, "on" + VE) } zn(vv, "onAnimationEnd"), zn(yv, "onAnimationIteration"), zn(wv, "onAnimationStart"), zn("dblclick", "onDoubleClick"), zn("focusin", "onFocus"), zn("focusout", "onBlur"), zn(xv, "onTransitionEnd"), u("onMouseEnter", ["mouseout", "mouseover"]), u("onMouseLeave", ["mouseout", "mouseover"]), u("onPointerEnter", ["pointerout", "pointerover"]), u("onPointerLeave", ["pointerout", "pointerover"]), d("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), d("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), d("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), d("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), d("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), d("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var ci = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), FE = new Set("cancel close invalid load scroll toggle".split(" ").concat(ci)); function bv(e, n, i) { var a = e.type || "unknown-event"; e.currentTarget = i, IP(a, n, void 0, e), e.currentTarget = null } function kv(e, n) { n = (n & 4) !== 0; for (var i = 0; i < e.length; i++) { var a = e[i], c = a.event; a = a.listeners; e: { var p = void 0; if (n) for (var y = a.length - 1; 0 <= y; y--) { var k = a[y], A = k.instance, _ = k.currentTarget; if (k = k.listener, A !== p && c.isPropagationStopped()) break e; bv(c, k, _), p = A } else for (y = 0; y < a.length; y++) { if (k = a[y], A = k.instance, _ = k.currentTarget, k = k.listener, A !== p && c.isPropagationStopped()) break e; bv(c, k, _), p = A } } } if (xs) throw e = Eu, xs = !1, Eu = null, e } function Me(e, n) { var i = n[rc]; i === void 0 && (i = n[rc] = new Set); var a = e + "__bubble"; i.has(a) || (Pv(n, e, 2, !1), i.add(a)) } function Qu(e, n, i) { var a = 0; n && (a |= 4), Pv(i, e, a, n) } var Is = "_reactListening" + Math.random().toString(36).slice(2); function di(e) { if (!e[Is]) { e[Is] = !0, s.forEach(function (i) { i !== "selectionchange" && (FE.has(i) || Qu(i, !1, e), Qu(i, !0, e)) }); var n = e.nodeType === 9 ? e : e.ownerDocument; n === null || n[Is] || (n[Is] = !0, Qu("selectionchange", !1, n)) } } function Pv(e, n, i, a) { switch (Yg(n)) { case 1: var c = JP; break; case 4: c = eE; break; default: c = Du }i = c.bind(null, n, i, e), c = void 0, !Pu || n !== "touchstart" && n !== "touchmove" && n !== "wheel" || (c = !0), a ? c !== void 0 ? e.addEventListener(n, i, { capture: !0, passive: c }) : e.addEventListener(n, i, !0) : c !== void 0 ? e.addEventListener(n, i, { passive: c }) : e.addEventListener(n, i, !1) } function qu(e, n, i, a, c) { var p = a; if (!(n & 1) && !(n & 2) && a !== null) e: for (; ;) { if (a === null) return; var y = a.tag; if (y === 3 || y === 4) { var k = a.stateNode.containerInfo; if (k === c || k.nodeType === 8 && k.parentNode === c) break; if (y === 4) for (y = a.return; y !== null;) { var A = y.tag; if ((A === 3 || A === 4) && (A = y.stateNode.containerInfo, A === c || A.nodeType === 8 && A.parentNode === c)) return; y = y.return } for (; k !== null;) { if (y = dr(k), y === null) return; if (A = y.tag, A === 5 || A === 6) { a = p = y; continue e } k = k.parentNode } } a = a.return } Ng(function () { var _ = p, B = Cu(i), U = []; e: { var z = Sv.get(e); if (z !== void 0) { var q = _u, ee = e; switch (e) { case "keypress": if (Ms(i) === 0) break e; case "keydown": case "keyup": q = mE; break; case "focusin": ee = "focus", q = Fu; break; case "focusout": ee = "blur", q = Fu; break; case "beforeblur": case "afterblur": q = Fu; break; case "click": if (i.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": q = qg; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": q = rE; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": q = yE; break; case vv: case yv: case wv: q = sE; break; case xv: q = xE; break; case "scroll": q = tE; break; case "wheel": q = CE; break; case "copy": case "cut": case "paste": q = lE; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": q = Jg }var te = (n & 4) !== 0, We = !te && e === "scroll", D = te ? z !== null ? z + "Capture" : null : z; te = []; for (var M = _, O; M !== null;) { O = M; var $ = O.stateNode; if (O.tag === 5 && $ !== null && (O = $, D !== null && ($ = Go(M, D), $ != null && te.push(fi(M, $, O)))), We) break; M = M.return } 0 < te.length && (z = new q(z, ee, null, i, B), U.push({ event: z, listeners: te })) } } if (!(n & 7)) { e: { if (z = e === "mouseover" || e === "pointerover", q = e === "mouseout" || e === "pointerout", z && i !== Su && (ee = i.relatedTarget || i.fromElement) && (dr(ee) || ee[pn])) break e; if ((q || z) && (z = B.window === B ? B : (z = B.ownerDocument) ? z.defaultView || z.parentWindow : window, q ? (ee = i.relatedTarget || i.toElement, q = _, ee = ee ? dr(ee) : null, ee !== null && (We = cr(ee), ee !== We || ee.tag !== 5 && ee.tag !== 6) && (ee = null)) : (q = null, ee = _), q !== ee)) { if (te = qg, $ = "onMouseLeave", D = "onMouseEnter", M = "mouse", (e === "pointerout" || e === "pointerover") && (te = Jg, $ = "onPointerLeave", D = "onPointerEnter", M = "pointer"), We = q == null ? z : ro(q), O = ee == null ? z : ro(ee), z = new te($, M + "leave", q, i, B), z.target = We, z.relatedTarget = O, $ = null, dr(B) === _ && (te = new te(D, M + "enter", ee, i, B), te.target = O, te.relatedTarget = We, $ = te), We = $, q && ee) t: { for (te = q, D = ee, M = 0, O = te; O; O = to(O))M++; for (O = 0, $ = D; $; $ = to($))O++; for (; 0 < M - O;)te = to(te), M--; for (; 0 < O - M;)D = to(D), O--; for (; M--;) { if (te === D || D !== null && te === D.alternate) break t; te = to(te), D = to(D) } te = null } else te = null; q !== null && Ev(U, z, q, te, !1), ee !== null && We !== null && Ev(U, We, ee, te, !0) } } e: { if (z = _ ? ro(_) : window, q = z.nodeName && z.nodeName.toLowerCase(), q === "select" || q === "input" && z.type === "file") var re = AE; else if (iv(z)) if (av) re = DE; else { re = ME; var de = NE } else (q = z.nodeName) && q.toLowerCase() === "input" && (z.type === "checkbox" || z.type === "radio") && (re = LE); if (re && (re = re(e, _))) { sv(U, re, i, B); break e } de && de(e, z, _), e === "focusout" && (de = z._wrapperState) && de.controlled && z.type === "number" && gu(z, "number", z.value) } switch (de = _ ? ro(_) : window, e) { case "focusin": (iv(de) || de.contentEditable === "true") && (Jr = de, Hu = _, ui = null); break; case "focusout": ui = Hu = Jr = null; break; case "mousedown": Ku = !0; break; case "contextmenu": case "mouseup": case "dragend": Ku = !1, mv(U, i, B); break; case "selectionchange": if (_E) break; case "keydown": case "keyup": mv(U, i, B) }var fe; if (Bu) e: { switch (e) { case "compositionstart": var he = "onCompositionStart"; break e; case "compositionend": he = "onCompositionEnd"; break e; case "compositionupdate": he = "onCompositionUpdate"; break e }he = void 0 } else Zr ? rv(e, i) && (he = "onCompositionEnd") : e === "keydown" && i.keyCode === 229 && (he = "onCompositionStart"); he && (ev && i.locale !== "ko" && (Zr || he !== "onCompositionStart" ? he === "onCompositionEnd" && Zr && (fe = Xg()) : (Fn = B, Ou = "value" in Fn ? Fn.value : Fn.textContent, Zr = !0)), de = Vs(_, he), 0 < de.length && (he = new Zg(he, e, null, i, B), U.push({ event: he, listeners: de }), fe ? he.data = fe : (fe = ov(i), fe !== null && (he.data = fe)))), (fe = kE ? PE(e, i) : EE(e, i)) && (_ = Vs(_, "onBeforeInput"), 0 < _.length && (B = new Zg("onBeforeInput", "beforeinput", null, i, B), U.push({ event: B, listeners: _ }), B.data = fe)) } kv(U, n) }) } function fi(e, n, i) { return { instance: e, listener: n, currentTarget: i } } function Vs(e, n) { for (var i = n + "Capture", a = []; e !== null;) { var c = e, p = c.stateNode; c.tag === 5 && p !== null && (c = p, p = Go(e, i), p != null && a.unshift(fi(e, p, c)), p = Go(e, n), p != null && a.push(fi(e, p, c))), e = e.return } return a } function to(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function Ev(e, n, i, a, c) { for (var p = n._reactName, y = []; i !== null && i !== a;) { var k = i, A = k.alternate, _ = k.stateNode; if (A !== null && A === a) break; k.tag === 5 && _ !== null && (k = _, c ? (A = Go(i, p), A != null && y.unshift(fi(i, A, k))) : c || (A = Go(i, p), A != null && y.push(fi(i, A, k)))), i = i.return } y.length !== 0 && e.push({ event: n, listeners: y }) } var zE = /\r\n?/g, BE = /\u0000|\uFFFD/g; function Tv(e) {
      return (typeof e == "string" ? e : "" + e).replace(zE, `
`).replace(BE, "")
    } function Fs(e, n, i) { if (n = Tv(n), Tv(e) !== n && i) throw Error(o(425)) } function zs() { } var Zu = null, Ju = null; function ec(e, n) { return e === "textarea" || e === "noscript" || typeof n.children == "string" || typeof n.children == "number" || typeof n.dangerouslySetInnerHTML == "object" && n.dangerouslySetInnerHTML !== null && n.dangerouslySetInnerHTML.__html != null } var tc = typeof setTimeout == "function" ? setTimeout : void 0, UE = typeof clearTimeout == "function" ? clearTimeout : void 0, Rv = typeof Promise == "function" ? Promise : void 0, WE = typeof queueMicrotask == "function" ? queueMicrotask : typeof Rv < "u" ? function (e) { return Rv.resolve(null).then(e).catch($E) } : tc; function $E(e) { setTimeout(function () { throw e }) } function nc(e, n) { var i = n, a = 0; do { var c = i.nextSibling; if (e.removeChild(i), c && c.nodeType === 8) if (i = c.data, i === "/$") { if (a === 0) { e.removeChild(c), ni(n); return } a-- } else i !== "$" && i !== "$?" && i !== "$!" || a++; i = c } while (i); ni(n) } function Bn(e) { for (; e != null; e = e.nextSibling) { var n = e.nodeType; if (n === 1 || n === 3) break; if (n === 8) { if (n = e.data, n === "$" || n === "$!" || n === "$?") break; if (n === "/$") return null } } return e } function Av(e) { e = e.previousSibling; for (var n = 0; e;) { if (e.nodeType === 8) { var i = e.data; if (i === "$" || i === "$!" || i === "$?") { if (n === 0) return e; n-- } else i === "/$" && n++ } e = e.previousSibling } return null } var no = Math.random().toString(36).slice(2), Qt = "__reactFiber$" + no, pi = "__reactProps$" + no, pn = "__reactContainer$" + no, rc = "__reactEvents$" + no, HE = "__reactListeners$" + no, KE = "__reactHandles$" + no; function dr(e) { var n = e[Qt]; if (n) return n; for (var i = e.parentNode; i;) { if (n = i[pn] || i[Qt]) { if (i = n.alternate, n.child !== null || i !== null && i.child !== null) for (e = Av(e); e !== null;) { if (i = e[Qt]) return i; e = Av(e) } return n } e = i, i = e.parentNode } return null } function hi(e) { return e = e[Qt] || e[pn], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function ro(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(o(33)) } function Bs(e) { return e[pi] || null } var oc = [], oo = -1; function Un(e) { return { current: e } } function Le(e) { 0 > oo || (e.current = oc[oo], oc[oo] = null, oo--) } function Ae(e, n) { oo++, oc[oo] = e.current, e.current = n } var Wn = {}, it = Un(Wn), ft = Un(!1), fr = Wn; function io(e, n) { var i = e.type.contextTypes; if (!i) return Wn; var a = e.stateNode; if (a && a.__reactInternalMemoizedUnmaskedChildContext === n) return a.__reactInternalMemoizedMaskedChildContext; var c = {}, p; for (p in i) c[p] = n[p]; return a && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = n, e.__reactInternalMemoizedMaskedChildContext = c), c } function pt(e) { return e = e.childContextTypes, e != null } function Us() { Le(ft), Le(it) } function Nv(e, n, i) { if (it.current !== Wn) throw Error(o(168)); Ae(it, n), Ae(ft, i) } function Mv(e, n, i) { var a = e.stateNode; if (n = n.childContextTypes, typeof a.getChildContext != "function") return i; a = a.getChildContext(); for (var c in a) if (!(c in n)) throw Error(o(108, Q(e) || "Unknown", c)); return X({}, i, a) } function Ws(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Wn, fr = it.current, Ae(it, e), Ae(ft, ft.current), !0 } function Lv(e, n, i) { var a = e.stateNode; if (!a) throw Error(o(169)); i ? (e = Mv(e, n, fr), a.__reactInternalMemoizedMergedChildContext = e, Le(ft), Le(it), Ae(it, e)) : Le(ft), Ae(ft, i) } var hn = null, $s = !1, ic = !1; function Dv(e) { hn === null ? hn = [e] : hn.push(e) } function GE(e) { $s = !0, Dv(e) } function $n() { if (!ic && hn !== null) { ic = !0; var e = 0, n = Ee; try { var i = hn; for (Ee = 1; e < i.length; e++) { var a = i[e]; do a = a(!0); while (a !== null) } hn = null, $s = !1 } catch (c) { throw hn !== null && (hn = hn.slice(e + 1)), Og(Tu, $n), c } finally { Ee = n, ic = !1 } } return null } var so = [], ao = 0, Hs = null, Ks = 0, Tt = [], Rt = 0, pr = null, mn = 1, gn = ""; function hr(e, n) { so[ao++] = Ks, so[ao++] = Hs, Hs = e, Ks = n } function jv(e, n, i) { Tt[Rt++] = mn, Tt[Rt++] = gn, Tt[Rt++] = pr, pr = e; var a = mn; e = gn; var c = 32 - _t(a) - 1; a &= ~(1 << c), i += 1; var p = 32 - _t(n) + c; if (30 < p) { var y = c - c % 5; p = (a & (1 << y) - 1).toString(32), a >>= y, c -= y, mn = 1 << 32 - _t(n) + c | i << c | a, gn = p + e } else mn = 1 << p | i << c | a, gn = e } function sc(e) { e.return !== null && (hr(e, 1), jv(e, 1, 0)) } function ac(e) { for (; e === Hs;)Hs = so[--ao], so[ao] = null, Ks = so[--ao], so[ao] = null; for (; e === pr;)pr = Tt[--Rt], Tt[Rt] = null, gn = Tt[--Rt], Tt[Rt] = null, mn = Tt[--Rt], Tt[Rt] = null } var St = null, Ct = null, De = !1, Vt = null; function Ov(e, n) { var i = Lt(5, null, null, 0); i.elementType = "DELETED", i.stateNode = n, i.return = e, n = e.deletions, n === null ? (e.deletions = [i], e.flags |= 16) : n.push(i) } function _v(e, n) { switch (e.tag) { case 5: var i = e.type; return n = n.nodeType !== 1 || i.toLowerCase() !== n.nodeName.toLowerCase() ? null : n, n !== null ? (e.stateNode = n, St = e, Ct = Bn(n.firstChild), !0) : !1; case 6: return n = e.pendingProps === "" || n.nodeType !== 3 ? null : n, n !== null ? (e.stateNode = n, St = e, Ct = null, !0) : !1; case 13: return n = n.nodeType !== 8 ? null : n, n !== null ? (i = pr !== null ? { id: mn, overflow: gn } : null, e.memoizedState = { dehydrated: n, treeContext: i, retryLane: 1073741824 }, i = Lt(18, null, null, 0), i.stateNode = n, i.return = e, e.child = i, St = e, Ct = null, !0) : !1; default: return !1 } } function lc(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function uc(e) { if (De) { var n = Ct; if (n) { var i = n; if (!_v(e, n)) { if (lc(e)) throw Error(o(418)); n = Bn(i.nextSibling); var a = St; n && _v(e, n) ? Ov(a, i) : (e.flags = e.flags & -4097 | 2, De = !1, St = e) } } else { if (lc(e)) throw Error(o(418)); e.flags = e.flags & -4097 | 2, De = !1, St = e } } } function Iv(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; St = e } function Gs(e) { if (e !== St) return !1; if (!De) return Iv(e), De = !0, !1; var n; if ((n = e.tag !== 3) && !(n = e.tag !== 5) && (n = e.type, n = n !== "head" && n !== "body" && !ec(e.type, e.memoizedProps)), n && (n = Ct)) { if (lc(e)) throw Vv(), Error(o(418)); for (; n;)Ov(e, n), n = Bn(n.nextSibling) } if (Iv(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(o(317)); e: { for (e = e.nextSibling, n = 0; e;) { if (e.nodeType === 8) { var i = e.data; if (i === "/$") { if (n === 0) { Ct = Bn(e.nextSibling); break e } n-- } else i !== "$" && i !== "$!" && i !== "$?" || n++ } e = e.nextSibling } Ct = null } } else Ct = St ? Bn(e.stateNode.nextSibling) : null; return !0 } function Vv() { for (var e = Ct; e;)e = Bn(e.nextSibling) } function lo() { Ct = St = null, De = !1 } function cc(e) { Vt === null ? Vt = [e] : Vt.push(e) } var YE = j.ReactCurrentBatchConfig; function mi(e, n, i) { if (e = i.ref, e !== null && typeof e != "function" && typeof e != "object") { if (i._owner) { if (i = i._owner, i) { if (i.tag !== 1) throw Error(o(309)); var a = i.stateNode } if (!a) throw Error(o(147, e)); var c = a, p = "" + e; return n !== null && n.ref !== null && typeof n.ref == "function" && n.ref._stringRef === p ? n.ref : (n = function (y) { var k = c.refs; y === null ? delete k[p] : k[p] = y }, n._stringRef = p, n) } if (typeof e != "string") throw Error(o(284)); if (!i._owner) throw Error(o(290, e)) } return e } function Ys(e, n) { throw e = Object.prototype.toString.call(n), Error(o(31, e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e)) } function Fv(e) { var n = e._init; return n(e._payload) } function zv(e) { function n(D, M) { if (e) { var O = D.deletions; O === null ? (D.deletions = [M], D.flags |= 16) : O.push(M) } } function i(D, M) { if (!e) return null; for (; M !== null;)n(D, M), M = M.sibling; return null } function a(D, M) { for (D = new Map; M !== null;)M.key !== null ? D.set(M.key, M) : D.set(M.index, M), M = M.sibling; return D } function c(D, M) { return D = Zn(D, M), D.index = 0, D.sibling = null, D } function p(D, M, O) { return D.index = O, e ? (O = D.alternate, O !== null ? (O = O.index, O < M ? (D.flags |= 2, M) : O) : (D.flags |= 2, M)) : (D.flags |= 1048576, M) } function y(D) { return e && D.alternate === null && (D.flags |= 2), D } function k(D, M, O, $) { return M === null || M.tag !== 6 ? (M = td(O, D.mode, $), M.return = D, M) : (M = c(M, O), M.return = D, M) } function A(D, M, O, $) { var re = O.type; return re === H ? B(D, M, O.props.children, $, O.key) : M !== null && (M.elementType === re || typeof re == "object" && re !== null && re.$$typeof === ue && Fv(re) === M.type) ? ($ = c(M, O.props), $.ref = mi(D, M, O), $.return = D, $) : ($ = ya(O.type, O.key, O.props, null, D.mode, $), $.ref = mi(D, M, O), $.return = D, $) } function _(D, M, O, $) { return M === null || M.tag !== 4 || M.stateNode.containerInfo !== O.containerInfo || M.stateNode.implementation !== O.implementation ? (M = nd(O, D.mode, $), M.return = D, M) : (M = c(M, O.children || []), M.return = D, M) } function B(D, M, O, $, re) { return M === null || M.tag !== 7 ? (M = Cr(O, D.mode, $, re), M.return = D, M) : (M = c(M, O), M.return = D, M) } function U(D, M, O) { if (typeof M == "string" && M !== "" || typeof M == "number") return M = td("" + M, D.mode, O), M.return = D, M; if (typeof M == "object" && M !== null) { switch (M.$$typeof) { case I: return O = ya(M.type, M.key, M.props, null, D.mode, O), O.ref = mi(D, null, M), O.return = D, O; case K: return M = nd(M, D.mode, O), M.return = D, M; case ue: var $ = M._init; return U(D, $(M._payload), O) }if ($o(M) || Y(M)) return M = Cr(M, D.mode, O, null), M.return = D, M; Ys(D, M) } return null } function z(D, M, O, $) { var re = M !== null ? M.key : null; if (typeof O == "string" && O !== "" || typeof O == "number") return re !== null ? null : k(D, M, "" + O, $); if (typeof O == "object" && O !== null) { switch (O.$$typeof) { case I: return O.key === re ? A(D, M, O, $) : null; case K: return O.key === re ? _(D, M, O, $) : null; case ue: return re = O._init, z(D, M, re(O._payload), $) }if ($o(O) || Y(O)) return re !== null ? null : B(D, M, O, $, null); Ys(D, O) } return null } function q(D, M, O, $, re) { if (typeof $ == "string" && $ !== "" || typeof $ == "number") return D = D.get(O) || null, k(M, D, "" + $, re); if (typeof $ == "object" && $ !== null) { switch ($.$$typeof) { case I: return D = D.get($.key === null ? O : $.key) || null, A(M, D, $, re); case K: return D = D.get($.key === null ? O : $.key) || null, _(M, D, $, re); case ue: var de = $._init; return q(D, M, O, de($._payload), re) }if ($o($) || Y($)) return D = D.get(O) || null, B(M, D, $, re, null); Ys(M, $) } return null } function ee(D, M, O, $) { for (var re = null, de = null, fe = M, he = M = 0, Qe = null; fe !== null && he < O.length; he++) { fe.index > he ? (Qe = fe, fe = null) : Qe = fe.sibling; var Pe = z(D, fe, O[he], $); if (Pe === null) { fe === null && (fe = Qe); break } e && fe && Pe.alternate === null && n(D, fe), M = p(Pe, M, he), de === null ? re = Pe : de.sibling = Pe, de = Pe, fe = Qe } if (he === O.length) return i(D, fe), De && hr(D, he), re; if (fe === null) { for (; he < O.length; he++)fe = U(D, O[he], $), fe !== null && (M = p(fe, M, he), de === null ? re = fe : de.sibling = fe, de = fe); return De && hr(D, he), re } for (fe = a(D, fe); he < O.length; he++)Qe = q(fe, D, he, O[he], $), Qe !== null && (e && Qe.alternate !== null && fe.delete(Qe.key === null ? he : Qe.key), M = p(Qe, M, he), de === null ? re = Qe : de.sibling = Qe, de = Qe); return e && fe.forEach(function (Jn) { return n(D, Jn) }), De && hr(D, he), re } function te(D, M, O, $) { var re = Y(O); if (typeof re != "function") throw Error(o(150)); if (O = re.call(O), O == null) throw Error(o(151)); for (var de = re = null, fe = M, he = M = 0, Qe = null, Pe = O.next(); fe !== null && !Pe.done; he++, Pe = O.next()) { fe.index > he ? (Qe = fe, fe = null) : Qe = fe.sibling; var Jn = z(D, fe, Pe.value, $); if (Jn === null) { fe === null && (fe = Qe); break } e && fe && Jn.alternate === null && n(D, fe), M = p(Jn, M, he), de === null ? re = Jn : de.sibling = Jn, de = Jn, fe = Qe } if (Pe.done) return i(D, fe), De && hr(D, he), re; if (fe === null) { for (; !Pe.done; he++, Pe = O.next())Pe = U(D, Pe.value, $), Pe !== null && (M = p(Pe, M, he), de === null ? re = Pe : de.sibling = Pe, de = Pe); return De && hr(D, he), re } for (fe = a(D, fe); !Pe.done; he++, Pe = O.next())Pe = q(fe, D, he, Pe.value, $), Pe !== null && (e && Pe.alternate !== null && fe.delete(Pe.key === null ? he : Pe.key), M = p(Pe, M, he), de === null ? re = Pe : de.sibling = Pe, de = Pe); return e && fe.forEach(function (TT) { return n(D, TT) }), De && hr(D, he), re } function We(D, M, O, $) { if (typeof O == "object" && O !== null && O.type === H && O.key === null && (O = O.props.children), typeof O == "object" && O !== null) { switch (O.$$typeof) { case I: e: { for (var re = O.key, de = M; de !== null;) { if (de.key === re) { if (re = O.type, re === H) { if (de.tag === 7) { i(D, de.sibling), M = c(de, O.props.children), M.return = D, D = M; break e } } else if (de.elementType === re || typeof re == "object" && re !== null && re.$$typeof === ue && Fv(re) === de.type) { i(D, de.sibling), M = c(de, O.props), M.ref = mi(D, de, O), M.return = D, D = M; break e } i(D, de); break } else n(D, de); de = de.sibling } O.type === H ? (M = Cr(O.props.children, D.mode, $, O.key), M.return = D, D = M) : ($ = ya(O.type, O.key, O.props, null, D.mode, $), $.ref = mi(D, M, O), $.return = D, D = $) } return y(D); case K: e: { for (de = O.key; M !== null;) { if (M.key === de) if (M.tag === 4 && M.stateNode.containerInfo === O.containerInfo && M.stateNode.implementation === O.implementation) { i(D, M.sibling), M = c(M, O.children || []), M.return = D, D = M; break e } else { i(D, M); break } else n(D, M); M = M.sibling } M = nd(O, D.mode, $), M.return = D, D = M } return y(D); case ue: return de = O._init, We(D, M, de(O._payload), $) }if ($o(O)) return ee(D, M, O, $); if (Y(O)) return te(D, M, O, $); Ys(D, O) } return typeof O == "string" && O !== "" || typeof O == "number" ? (O = "" + O, M !== null && M.tag === 6 ? (i(D, M.sibling), M = c(M, O), M.return = D, D = M) : (i(D, M), M = td(O, D.mode, $), M.return = D, D = M), y(D)) : i(D, M) } return We } var uo = zv(!0), Bv = zv(!1), Xs = Un(null), Qs = null, co = null, dc = null; function fc() { dc = co = Qs = null } function pc(e) { var n = Xs.current; Le(Xs), e._currentValue = n } function hc(e, n, i) { for (; e !== null;) { var a = e.alternate; if ((e.childLanes & n) !== n ? (e.childLanes |= n, a !== null && (a.childLanes |= n)) : a !== null && (a.childLanes & n) !== n && (a.childLanes |= n), e === i) break; e = e.return } } function fo(e, n) { Qs = e, dc = co = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & n && (ht = !0), e.firstContext = null) } function At(e) { var n = e._currentValue; if (dc !== e) if (e = { context: e, memoizedValue: n, next: null }, co === null) { if (Qs === null) throw Error(o(308)); co = e, Qs.dependencies = { lanes: 0, firstContext: e } } else co = co.next = e; return n } var mr = null; function mc(e) { mr === null ? mr = [e] : mr.push(e) } function Uv(e, n, i, a) { var c = n.interleaved; return c === null ? (i.next = i, mc(n)) : (i.next = c.next, c.next = i), n.interleaved = i, vn(e, a) } function vn(e, n) { e.lanes |= n; var i = e.alternate; for (i !== null && (i.lanes |= n), i = e, e = e.return; e !== null;)e.childLanes |= n, i = e.alternate, i !== null && (i.childLanes |= n), i = e, e = e.return; return i.tag === 3 ? i.stateNode : null } var Hn = !1; function gc(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Wv(e, n) { e = e.updateQueue, n.updateQueue === e && (n.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function yn(e, n) { return { eventTime: e, lane: n, tag: 0, payload: null, callback: null, next: null } } function Kn(e, n, i) { var a = e.updateQueue; if (a === null) return null; if (a = a.shared, ke & 2) { var c = a.pending; return c === null ? n.next = n : (n.next = c.next, c.next = n), a.pending = n, vn(e, i) } return c = a.interleaved, c === null ? (n.next = n, mc(a)) : (n.next = c.next, c.next = n), a.interleaved = n, vn(e, i) } function qs(e, n, i) { if (n = n.updateQueue, n !== null && (n = n.shared, (i & 4194240) !== 0)) { var a = n.lanes; a &= e.pendingLanes, i |= a, n.lanes = i, Nu(e, i) } } function $v(e, n) { var i = e.updateQueue, a = e.alternate; if (a !== null && (a = a.updateQueue, i === a)) { var c = null, p = null; if (i = i.firstBaseUpdate, i !== null) { do { var y = { eventTime: i.eventTime, lane: i.lane, tag: i.tag, payload: i.payload, callback: i.callback, next: null }; p === null ? c = p = y : p = p.next = y, i = i.next } while (i !== null); p === null ? c = p = n : p = p.next = n } else c = p = n; i = { baseState: a.baseState, firstBaseUpdate: c, lastBaseUpdate: p, shared: a.shared, effects: a.effects }, e.updateQueue = i; return } e = i.lastBaseUpdate, e === null ? i.firstBaseUpdate = n : e.next = n, i.lastBaseUpdate = n } function Zs(e, n, i, a) { var c = e.updateQueue; Hn = !1; var p = c.firstBaseUpdate, y = c.lastBaseUpdate, k = c.shared.pending; if (k !== null) { c.shared.pending = null; var A = k, _ = A.next; A.next = null, y === null ? p = _ : y.next = _, y = A; var B = e.alternate; B !== null && (B = B.updateQueue, k = B.lastBaseUpdate, k !== y && (k === null ? B.firstBaseUpdate = _ : k.next = _, B.lastBaseUpdate = A)) } if (p !== null) { var U = c.baseState; y = 0, B = _ = A = null, k = p; do { var z = k.lane, q = k.eventTime; if ((a & z) === z) { B !== null && (B = B.next = { eventTime: q, lane: 0, tag: k.tag, payload: k.payload, callback: k.callback, next: null }); e: { var ee = e, te = k; switch (z = n, q = i, te.tag) { case 1: if (ee = te.payload, typeof ee == "function") { U = ee.call(q, U, z); break e } U = ee; break e; case 3: ee.flags = ee.flags & -65537 | 128; case 0: if (ee = te.payload, z = typeof ee == "function" ? ee.call(q, U, z) : ee, z == null) break e; U = X({}, U, z); break e; case 2: Hn = !0 } } k.callback !== null && k.lane !== 0 && (e.flags |= 64, z = c.effects, z === null ? c.effects = [k] : z.push(k)) } else q = { eventTime: q, lane: z, tag: k.tag, payload: k.payload, callback: k.callback, next: null }, B === null ? (_ = B = q, A = U) : B = B.next = q, y |= z; if (k = k.next, k === null) { if (k = c.shared.pending, k === null) break; z = k, k = z.next, z.next = null, c.lastBaseUpdate = z, c.shared.pending = null } } while (1); if (B === null && (A = U), c.baseState = A, c.firstBaseUpdate = _, c.lastBaseUpdate = B, n = c.shared.interleaved, n !== null) { c = n; do y |= c.lane, c = c.next; while (c !== n) } else p === null && (c.shared.lanes = 0); yr |= y, e.lanes = y, e.memoizedState = U } } function Hv(e, n, i) { if (e = n.effects, n.effects = null, e !== null) for (n = 0; n < e.length; n++) { var a = e[n], c = a.callback; if (c !== null) { if (a.callback = null, a = i, typeof c != "function") throw Error(o(191, c)); c.call(a) } } } var gi = {}, qt = Un(gi), vi = Un(gi), yi = Un(gi); function gr(e) { if (e === gi) throw Error(o(174)); return e } function vc(e, n) { switch (Ae(yi, n), Ae(vi, e), Ae(qt, gi), e = n.nodeType, e) { case 9: case 11: n = (n = n.documentElement) ? n.namespaceURI : yu(null, ""); break; default: e = e === 8 ? n.parentNode : n, n = e.namespaceURI || null, e = e.tagName, n = yu(n, e) }Le(qt), Ae(qt, n) } function po() { Le(qt), Le(vi), Le(yi) } function Kv(e) { gr(yi.current); var n = gr(qt.current), i = yu(n, e.type); n !== i && (Ae(vi, e), Ae(qt, i)) } function yc(e) { vi.current === e && (Le(qt), Le(vi)) } var _e = Un(0); function Js(e) { for (var n = e; n !== null;) { if (n.tag === 13) { var i = n.memoizedState; if (i !== null && (i = i.dehydrated, i === null || i.data === "$?" || i.data === "$!")) return n } else if (n.tag === 19 && n.memoizedProps.revealOrder !== void 0) { if (n.flags & 128) return n } else if (n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return null; n = n.return } n.sibling.return = n.return, n = n.sibling } return null } var wc = []; function xc() { for (var e = 0; e < wc.length; e++)wc[e]._workInProgressVersionPrimary = null; wc.length = 0 } var ea = j.ReactCurrentDispatcher, Sc = j.ReactCurrentBatchConfig, vr = 0, Ie = null, He = null, Ye = null, ta = !1, wi = !1, xi = 0, XE = 0; function st() { throw Error(o(321)) } function Cc(e, n) { if (n === null) return !1; for (var i = 0; i < n.length && i < e.length; i++)if (!It(e[i], n[i])) return !1; return !0 } function bc(e, n, i, a, c, p) { if (vr = p, Ie = n, n.memoizedState = null, n.updateQueue = null, n.lanes = 0, ea.current = e === null || e.memoizedState === null ? JE : eT, e = i(a, c), wi) { p = 0; do { if (wi = !1, xi = 0, 25 <= p) throw Error(o(301)); p += 1, Ye = He = null, n.updateQueue = null, ea.current = tT, e = i(a, c) } while (wi) } if (ea.current = oa, n = He !== null && He.next !== null, vr = 0, Ye = He = Ie = null, ta = !1, n) throw Error(o(300)); return e } function kc() { var e = xi !== 0; return xi = 0, e } function Zt() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Ye === null ? Ie.memoizedState = Ye = e : Ye = Ye.next = e, Ye } function Nt() { if (He === null) { var e = Ie.alternate; e = e !== null ? e.memoizedState : null } else e = He.next; var n = Ye === null ? Ie.memoizedState : Ye.next; if (n !== null) Ye = n, He = e; else { if (e === null) throw Error(o(310)); He = e, e = { memoizedState: He.memoizedState, baseState: He.baseState, baseQueue: He.baseQueue, queue: He.queue, next: null }, Ye === null ? Ie.memoizedState = Ye = e : Ye = Ye.next = e } return Ye } function Si(e, n) { return typeof n == "function" ? n(e) : n } function Pc(e) { var n = Nt(), i = n.queue; if (i === null) throw Error(o(311)); i.lastRenderedReducer = e; var a = He, c = a.baseQueue, p = i.pending; if (p !== null) { if (c !== null) { var y = c.next; c.next = p.next, p.next = y } a.baseQueue = c = p, i.pending = null } if (c !== null) { p = c.next, a = a.baseState; var k = y = null, A = null, _ = p; do { var B = _.lane; if ((vr & B) === B) A !== null && (A = A.next = { lane: 0, action: _.action, hasEagerState: _.hasEagerState, eagerState: _.eagerState, next: null }), a = _.hasEagerState ? _.eagerState : e(a, _.action); else { var U = { lane: B, action: _.action, hasEagerState: _.hasEagerState, eagerState: _.eagerState, next: null }; A === null ? (k = A = U, y = a) : A = A.next = U, Ie.lanes |= B, yr |= B } _ = _.next } while (_ !== null && _ !== p); A === null ? y = a : A.next = k, It(a, n.memoizedState) || (ht = !0), n.memoizedState = a, n.baseState = y, n.baseQueue = A, i.lastRenderedState = a } if (e = i.interleaved, e !== null) { c = e; do p = c.lane, Ie.lanes |= p, yr |= p, c = c.next; while (c !== e) } else c === null && (i.lanes = 0); return [n.memoizedState, i.dispatch] } function Ec(e) { var n = Nt(), i = n.queue; if (i === null) throw Error(o(311)); i.lastRenderedReducer = e; var a = i.dispatch, c = i.pending, p = n.memoizedState; if (c !== null) { i.pending = null; var y = c = c.next; do p = e(p, y.action), y = y.next; while (y !== c); It(p, n.memoizedState) || (ht = !0), n.memoizedState = p, n.baseQueue === null && (n.baseState = p), i.lastRenderedState = p } return [p, a] } function Gv() { } function Yv(e, n) { var i = Ie, a = Nt(), c = n(), p = !It(a.memoizedState, c); if (p && (a.memoizedState = c, ht = !0), a = a.queue, Tc(qv.bind(null, i, a, e), [e]), a.getSnapshot !== n || p || Ye !== null && Ye.memoizedState.tag & 1) { if (i.flags |= 2048, Ci(9, Qv.bind(null, i, a, c, n), void 0, null), Xe === null) throw Error(o(349)); vr & 30 || Xv(i, n, c) } return c } function Xv(e, n, i) { e.flags |= 16384, e = { getSnapshot: n, value: i }, n = Ie.updateQueue, n === null ? (n = { lastEffect: null, stores: null }, Ie.updateQueue = n, n.stores = [e]) : (i = n.stores, i === null ? n.stores = [e] : i.push(e)) } function Qv(e, n, i, a) { n.value = i, n.getSnapshot = a, Zv(n) && Jv(e) } function qv(e, n, i) { return i(function () { Zv(n) && Jv(e) }) } function Zv(e) { var n = e.getSnapshot; e = e.value; try { var i = n(); return !It(e, i) } catch { return !0 } } function Jv(e) { var n = vn(e, 1); n !== null && Ut(n, e, 1, -1) } function ey(e) { var n = Zt(); return typeof e == "function" && (e = e()), n.memoizedState = n.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Si, lastRenderedState: e }, n.queue = e, e = e.dispatch = ZE.bind(null, Ie, e), [n.memoizedState, e] } function Ci(e, n, i, a) { return e = { tag: e, create: n, destroy: i, deps: a, next: null }, n = Ie.updateQueue, n === null ? (n = { lastEffect: null, stores: null }, Ie.updateQueue = n, n.lastEffect = e.next = e) : (i = n.lastEffect, i === null ? n.lastEffect = e.next = e : (a = i.next, i.next = e, e.next = a, n.lastEffect = e)), e } function ty() { return Nt().memoizedState } function na(e, n, i, a) { var c = Zt(); Ie.flags |= e, c.memoizedState = Ci(1 | n, i, void 0, a === void 0 ? null : a) } function ra(e, n, i, a) { var c = Nt(); a = a === void 0 ? null : a; var p = void 0; if (He !== null) { var y = He.memoizedState; if (p = y.destroy, a !== null && Cc(a, y.deps)) { c.memoizedState = Ci(n, i, p, a); return } } Ie.flags |= e, c.memoizedState = Ci(1 | n, i, p, a) } function ny(e, n) { return na(8390656, 8, e, n) } function Tc(e, n) { return ra(2048, 8, e, n) } function ry(e, n) { return ra(4, 2, e, n) } function oy(e, n) { return ra(4, 4, e, n) } function iy(e, n) { if (typeof n == "function") return e = e(), n(e), function () { n(null) }; if (n != null) return e = e(), n.current = e, function () { n.current = null } } function sy(e, n, i) { return i = i != null ? i.concat([e]) : null, ra(4, 4, iy.bind(null, n, e), i) } function Rc() { } function ay(e, n) { var i = Nt(); n = n === void 0 ? null : n; var a = i.memoizedState; return a !== null && n !== null && Cc(n, a[1]) ? a[0] : (i.memoizedState = [e, n], e) } function ly(e, n) { var i = Nt(); n = n === void 0 ? null : n; var a = i.memoizedState; return a !== null && n !== null && Cc(n, a[1]) ? a[0] : (e = e(), i.memoizedState = [e, n], e) } function uy(e, n, i) { return vr & 21 ? (It(i, n) || (i = Fg(), Ie.lanes |= i, yr |= i, e.baseState = !0), n) : (e.baseState && (e.baseState = !1, ht = !0), e.memoizedState = i) } function QE(e, n) { var i = Ee; Ee = i !== 0 && 4 > i ? i : 4, e(!0); var a = Sc.transition; Sc.transition = {}; try { e(!1), n() } finally { Ee = i, Sc.transition = a } } function cy() { return Nt().memoizedState } function qE(e, n, i) { var a = Qn(e); if (i = { lane: a, action: i, hasEagerState: !1, eagerState: null, next: null }, dy(e)) fy(n, i); else if (i = Uv(e, n, i, a), i !== null) { var c = ct(); Ut(i, e, a, c), py(i, n, a) } } function ZE(e, n, i) { var a = Qn(e), c = { lane: a, action: i, hasEagerState: !1, eagerState: null, next: null }; if (dy(e)) fy(n, c); else { var p = e.alternate; if (e.lanes === 0 && (p === null || p.lanes === 0) && (p = n.lastRenderedReducer, p !== null)) try { var y = n.lastRenderedState, k = p(y, i); if (c.hasEagerState = !0, c.eagerState = k, It(k, y)) { var A = n.interleaved; A === null ? (c.next = c, mc(n)) : (c.next = A.next, A.next = c), n.interleaved = c; return } } catch { } finally { } i = Uv(e, n, c, a), i !== null && (c = ct(), Ut(i, e, a, c), py(i, n, a)) } } function dy(e) { var n = e.alternate; return e === Ie || n !== null && n === Ie } function fy(e, n) { wi = ta = !0; var i = e.pending; i === null ? n.next = n : (n.next = i.next, i.next = n), e.pending = n } function py(e, n, i) { if (i & 4194240) { var a = n.lanes; a &= e.pendingLanes, i |= a, n.lanes = i, Nu(e, i) } } var oa = { readContext: At, useCallback: st, useContext: st, useEffect: st, useImperativeHandle: st, useInsertionEffect: st, useLayoutEffect: st, useMemo: st, useReducer: st, useRef: st, useState: st, useDebugValue: st, useDeferredValue: st, useTransition: st, useMutableSource: st, useSyncExternalStore: st, useId: st, unstable_isNewReconciler: !1 }, JE = { readContext: At, useCallback: function (e, n) { return Zt().memoizedState = [e, n === void 0 ? null : n], e }, useContext: At, useEffect: ny, useImperativeHandle: function (e, n, i) { return i = i != null ? i.concat([e]) : null, na(4194308, 4, iy.bind(null, n, e), i) }, useLayoutEffect: function (e, n) { return na(4194308, 4, e, n) }, useInsertionEffect: function (e, n) { return na(4, 2, e, n) }, useMemo: function (e, n) { var i = Zt(); return n = n === void 0 ? null : n, e = e(), i.memoizedState = [e, n], e }, useReducer: function (e, n, i) { var a = Zt(); return n = i !== void 0 ? i(n) : n, a.memoizedState = a.baseState = n, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: n }, a.queue = e, e = e.dispatch = qE.bind(null, Ie, e), [a.memoizedState, e] }, useRef: function (e) { var n = Zt(); return e = { current: e }, n.memoizedState = e }, useState: ey, useDebugValue: Rc, useDeferredValue: function (e) { return Zt().memoizedState = e }, useTransition: function () { var e = ey(!1), n = e[0]; return e = QE.bind(null, e[1]), Zt().memoizedState = e, [n, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, n, i) { var a = Ie, c = Zt(); if (De) { if (i === void 0) throw Error(o(407)); i = i() } else { if (i = n(), Xe === null) throw Error(o(349)); vr & 30 || Xv(a, n, i) } c.memoizedState = i; var p = { value: i, getSnapshot: n }; return c.queue = p, ny(qv.bind(null, a, p, e), [e]), a.flags |= 2048, Ci(9, Qv.bind(null, a, p, i, n), void 0, null), i }, useId: function () { var e = Zt(), n = Xe.identifierPrefix; if (De) { var i = gn, a = mn; i = (a & ~(1 << 32 - _t(a) - 1)).toString(32) + i, n = ":" + n + "R" + i, i = xi++, 0 < i && (n += "H" + i.toString(32)), n += ":" } else i = XE++, n = ":" + n + "r" + i.toString(32) + ":"; return e.memoizedState = n }, unstable_isNewReconciler: !1 }, eT = { readContext: At, useCallback: ay, useContext: At, useEffect: Tc, useImperativeHandle: sy, useInsertionEffect: ry, useLayoutEffect: oy, useMemo: ly, useReducer: Pc, useRef: ty, useState: function () { return Pc(Si) }, useDebugValue: Rc, useDeferredValue: function (e) { var n = Nt(); return uy(n, He.memoizedState, e) }, useTransition: function () { var e = Pc(Si)[0], n = Nt().memoizedState; return [e, n] }, useMutableSource: Gv, useSyncExternalStore: Yv, useId: cy, unstable_isNewReconciler: !1 }, tT = { readContext: At, useCallback: ay, useContext: At, useEffect: Tc, useImperativeHandle: sy, useInsertionEffect: ry, useLayoutEffect: oy, useMemo: ly, useReducer: Ec, useRef: ty, useState: function () { return Ec(Si) }, useDebugValue: Rc, useDeferredValue: function (e) { var n = Nt(); return He === null ? n.memoizedState = e : uy(n, He.memoizedState, e) }, useTransition: function () { var e = Ec(Si)[0], n = Nt().memoizedState; return [e, n] }, useMutableSource: Gv, useSyncExternalStore: Yv, useId: cy, unstable_isNewReconciler: !1 }; function Ft(e, n) { if (e && e.defaultProps) { n = X({}, n), e = e.defaultProps; for (var i in e) n[i] === void 0 && (n[i] = e[i]); return n } return n } function Ac(e, n, i, a) { n = e.memoizedState, i = i(a, n), i = i == null ? n : X({}, n, i), e.memoizedState = i, e.lanes === 0 && (e.updateQueue.baseState = i) } var ia = { isMounted: function (e) { return (e = e._reactInternals) ? cr(e) === e : !1 }, enqueueSetState: function (e, n, i) { e = e._reactInternals; var a = ct(), c = Qn(e), p = yn(a, c); p.payload = n, i != null && (p.callback = i), n = Kn(e, p, c), n !== null && (Ut(n, e, c, a), qs(n, e, c)) }, enqueueReplaceState: function (e, n, i) { e = e._reactInternals; var a = ct(), c = Qn(e), p = yn(a, c); p.tag = 1, p.payload = n, i != null && (p.callback = i), n = Kn(e, p, c), n !== null && (Ut(n, e, c, a), qs(n, e, c)) }, enqueueForceUpdate: function (e, n) { e = e._reactInternals; var i = ct(), a = Qn(e), c = yn(i, a); c.tag = 2, n != null && (c.callback = n), n = Kn(e, c, a), n !== null && (Ut(n, e, a, i), qs(n, e, a)) } }; function hy(e, n, i, a, c, p, y) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(a, p, y) : n.prototype && n.prototype.isPureReactComponent ? !li(i, a) || !li(c, p) : !0 } function my(e, n, i) { var a = !1, c = Wn, p = n.contextType; return typeof p == "object" && p !== null ? p = At(p) : (c = pt(n) ? fr : it.current, a = n.contextTypes, p = (a = a != null) ? io(e, c) : Wn), n = new n(i, p), e.memoizedState = n.state !== null && n.state !== void 0 ? n.state : null, n.updater = ia, e.stateNode = n, n._reactInternals = e, a && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = c, e.__reactInternalMemoizedMaskedChildContext = p), n } function gy(e, n, i, a) { e = n.state, typeof n.componentWillReceiveProps == "function" && n.componentWillReceiveProps(i, a), typeof n.UNSAFE_componentWillReceiveProps == "function" && n.UNSAFE_componentWillReceiveProps(i, a), n.state !== e && ia.enqueueReplaceState(n, n.state, null) } function Nc(e, n, i, a) { var c = e.stateNode; c.props = i, c.state = e.memoizedState, c.refs = {}, gc(e); var p = n.contextType; typeof p == "object" && p !== null ? c.context = At(p) : (p = pt(n) ? fr : it.current, c.context = io(e, p)), c.state = e.memoizedState, p = n.getDerivedStateFromProps, typeof p == "function" && (Ac(e, n, p, i), c.state = e.memoizedState), typeof n.getDerivedStateFromProps == "function" || typeof c.getSnapshotBeforeUpdate == "function" || typeof c.UNSAFE_componentWillMount != "function" && typeof c.componentWillMount != "function" || (n = c.state, typeof c.componentWillMount == "function" && c.componentWillMount(), typeof c.UNSAFE_componentWillMount == "function" && c.UNSAFE_componentWillMount(), n !== c.state && ia.enqueueReplaceState(c, c.state, null), Zs(e, i, c, a), c.state = e.memoizedState), typeof c.componentDidMount == "function" && (e.flags |= 4194308) } function ho(e, n) {
      try { var i = "", a = n; do i += xe(a), a = a.return; while (a); var c = i } catch (p) {
        c = `
Error generating stack: `+ p.message + `
`+ p.stack
      } return { value: e, source: n, stack: c, digest: null }
    } function Mc(e, n, i) { return { value: e, source: null, stack: i ?? null, digest: n ?? null } } function Lc(e, n) { try { console.error(n.value) } catch (i) { setTimeout(function () { throw i }) } } var nT = typeof WeakMap == "function" ? WeakMap : Map; function vy(e, n, i) { i = yn(-1, i), i.tag = 3, i.payload = { element: null }; var a = n.value; return i.callback = function () { fa || (fa = !0, Gc = a), Lc(e, n) }, i } function yy(e, n, i) { i = yn(-1, i), i.tag = 3; var a = e.type.getDerivedStateFromError; if (typeof a == "function") { var c = n.value; i.payload = function () { return a(c) }, i.callback = function () { Lc(e, n) } } var p = e.stateNode; return p !== null && typeof p.componentDidCatch == "function" && (i.callback = function () { Lc(e, n), typeof a != "function" && (Yn === null ? Yn = new Set([this]) : Yn.add(this)); var y = n.stack; this.componentDidCatch(n.value, { componentStack: y !== null ? y : "" }) }), i } function wy(e, n, i) { var a = e.pingCache; if (a === null) { a = e.pingCache = new nT; var c = new Set; a.set(n, c) } else c = a.get(n), c === void 0 && (c = new Set, a.set(n, c)); c.has(i) || (c.add(i), e = gT.bind(null, e, n, i), n.then(e, e)) } function xy(e) { do { var n; if ((n = e.tag === 13) && (n = e.memoizedState, n = n !== null ? n.dehydrated !== null : !0), n) return e; e = e.return } while (e !== null); return null } function Sy(e, n, i, a, c) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = c, e) : (e === n ? e.flags |= 65536 : (e.flags |= 128, i.flags |= 131072, i.flags &= -52805, i.tag === 1 && (i.alternate === null ? i.tag = 17 : (n = yn(-1, 1), n.tag = 2, Kn(i, n, 1))), i.lanes |= 1), e) } var rT = j.ReactCurrentOwner, ht = !1; function ut(e, n, i, a) { n.child = e === null ? Bv(n, null, i, a) : uo(n, e.child, i, a) } function Cy(e, n, i, a, c) { i = i.render; var p = n.ref; return fo(n, c), a = bc(e, n, i, a, p, c), i = kc(), e !== null && !ht ? (n.updateQueue = e.updateQueue, n.flags &= -2053, e.lanes &= ~c, wn(e, n, c)) : (De && i && sc(n), n.flags |= 1, ut(e, n, a, c), n.child) } function by(e, n, i, a, c) { if (e === null) { var p = i.type; return typeof p == "function" && !ed(p) && p.defaultProps === void 0 && i.compare === null && i.defaultProps === void 0 ? (n.tag = 15, n.type = p, ky(e, n, p, a, c)) : (e = ya(i.type, null, a, n, n.mode, c), e.ref = n.ref, e.return = n, n.child = e) } if (p = e.child, !(e.lanes & c)) { var y = p.memoizedProps; if (i = i.compare, i = i !== null ? i : li, i(y, a) && e.ref === n.ref) return wn(e, n, c) } return n.flags |= 1, e = Zn(p, a), e.ref = n.ref, e.return = n, n.child = e } function ky(e, n, i, a, c) { if (e !== null) { var p = e.memoizedProps; if (li(p, a) && e.ref === n.ref) if (ht = !1, n.pendingProps = a = p, (e.lanes & c) !== 0) e.flags & 131072 && (ht = !0); else return n.lanes = e.lanes, wn(e, n, c) } return Dc(e, n, i, a, c) } function Py(e, n, i) { var a = n.pendingProps, c = a.children, p = e !== null ? e.memoizedState : null; if (a.mode === "hidden") if (!(n.mode & 1)) n.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ae(go, bt), bt |= i; else { if (!(i & 1073741824)) return e = p !== null ? p.baseLanes | i : i, n.lanes = n.childLanes = 1073741824, n.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, n.updateQueue = null, Ae(go, bt), bt |= e, null; n.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, a = p !== null ? p.baseLanes : i, Ae(go, bt), bt |= a } else p !== null ? (a = p.baseLanes | i, n.memoizedState = null) : a = i, Ae(go, bt), bt |= a; return ut(e, n, c, i), n.child } function Ey(e, n) { var i = n.ref; (e === null && i !== null || e !== null && e.ref !== i) && (n.flags |= 512, n.flags |= 2097152) } function Dc(e, n, i, a, c) { var p = pt(i) ? fr : it.current; return p = io(n, p), fo(n, c), i = bc(e, n, i, a, p, c), a = kc(), e !== null && !ht ? (n.updateQueue = e.updateQueue, n.flags &= -2053, e.lanes &= ~c, wn(e, n, c)) : (De && a && sc(n), n.flags |= 1, ut(e, n, i, c), n.child) } function Ty(e, n, i, a, c) { if (pt(i)) { var p = !0; Ws(n) } else p = !1; if (fo(n, c), n.stateNode === null) aa(e, n), my(n, i, a), Nc(n, i, a, c), a = !0; else if (e === null) { var y = n.stateNode, k = n.memoizedProps; y.props = k; var A = y.context, _ = i.contextType; typeof _ == "object" && _ !== null ? _ = At(_) : (_ = pt(i) ? fr : it.current, _ = io(n, _)); var B = i.getDerivedStateFromProps, U = typeof B == "function" || typeof y.getSnapshotBeforeUpdate == "function"; U || typeof y.UNSAFE_componentWillReceiveProps != "function" && typeof y.componentWillReceiveProps != "function" || (k !== a || A !== _) && gy(n, y, a, _), Hn = !1; var z = n.memoizedState; y.state = z, Zs(n, a, y, c), A = n.memoizedState, k !== a || z !== A || ft.current || Hn ? (typeof B == "function" && (Ac(n, i, B, a), A = n.memoizedState), (k = Hn || hy(n, i, k, a, z, A, _)) ? (U || typeof y.UNSAFE_componentWillMount != "function" && typeof y.componentWillMount != "function" || (typeof y.componentWillMount == "function" && y.componentWillMount(), typeof y.UNSAFE_componentWillMount == "function" && y.UNSAFE_componentWillMount()), typeof y.componentDidMount == "function" && (n.flags |= 4194308)) : (typeof y.componentDidMount == "function" && (n.flags |= 4194308), n.memoizedProps = a, n.memoizedState = A), y.props = a, y.state = A, y.context = _, a = k) : (typeof y.componentDidMount == "function" && (n.flags |= 4194308), a = !1) } else { y = n.stateNode, Wv(e, n), k = n.memoizedProps, _ = n.type === n.elementType ? k : Ft(n.type, k), y.props = _, U = n.pendingProps, z = y.context, A = i.contextType, typeof A == "object" && A !== null ? A = At(A) : (A = pt(i) ? fr : it.current, A = io(n, A)); var q = i.getDerivedStateFromProps; (B = typeof q == "function" || typeof y.getSnapshotBeforeUpdate == "function") || typeof y.UNSAFE_componentWillReceiveProps != "function" && typeof y.componentWillReceiveProps != "function" || (k !== U || z !== A) && gy(n, y, a, A), Hn = !1, z = n.memoizedState, y.state = z, Zs(n, a, y, c); var ee = n.memoizedState; k !== U || z !== ee || ft.current || Hn ? (typeof q == "function" && (Ac(n, i, q, a), ee = n.memoizedState), (_ = Hn || hy(n, i, _, a, z, ee, A) || !1) ? (B || typeof y.UNSAFE_componentWillUpdate != "function" && typeof y.componentWillUpdate != "function" || (typeof y.componentWillUpdate == "function" && y.componentWillUpdate(a, ee, A), typeof y.UNSAFE_componentWillUpdate == "function" && y.UNSAFE_componentWillUpdate(a, ee, A)), typeof y.componentDidUpdate == "function" && (n.flags |= 4), typeof y.getSnapshotBeforeUpdate == "function" && (n.flags |= 1024)) : (typeof y.componentDidUpdate != "function" || k === e.memoizedProps && z === e.memoizedState || (n.flags |= 4), typeof y.getSnapshotBeforeUpdate != "function" || k === e.memoizedProps && z === e.memoizedState || (n.flags |= 1024), n.memoizedProps = a, n.memoizedState = ee), y.props = a, y.state = ee, y.context = A, a = _) : (typeof y.componentDidUpdate != "function" || k === e.memoizedProps && z === e.memoizedState || (n.flags |= 4), typeof y.getSnapshotBeforeUpdate != "function" || k === e.memoizedProps && z === e.memoizedState || (n.flags |= 1024), a = !1) } return jc(e, n, i, a, p, c) } function jc(e, n, i, a, c, p) { Ey(e, n); var y = (n.flags & 128) !== 0; if (!a && !y) return c && Lv(n, i, !1), wn(e, n, p); a = n.stateNode, rT.current = n; var k = y && typeof i.getDerivedStateFromError != "function" ? null : a.render(); return n.flags |= 1, e !== null && y ? (n.child = uo(n, e.child, null, p), n.child = uo(n, null, k, p)) : ut(e, n, k, p), n.memoizedState = a.state, c && Lv(n, i, !0), n.child } function Ry(e) { var n = e.stateNode; n.pendingContext ? Nv(e, n.pendingContext, n.pendingContext !== n.context) : n.context && Nv(e, n.context, !1), vc(e, n.containerInfo) } function Ay(e, n, i, a, c) { return lo(), cc(c), n.flags |= 256, ut(e, n, i, a), n.child } var Oc = { dehydrated: null, treeContext: null, retryLane: 0 }; function _c(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Ny(e, n, i) { var a = n.pendingProps, c = _e.current, p = !1, y = (n.flags & 128) !== 0, k; if ((k = y) || (k = e !== null && e.memoizedState === null ? !1 : (c & 2) !== 0), k ? (p = !0, n.flags &= -129) : (e === null || e.memoizedState !== null) && (c |= 1), Ae(_e, c & 1), e === null) return uc(n), e = n.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (n.mode & 1 ? e.data === "$!" ? n.lanes = 8 : n.lanes = 1073741824 : n.lanes = 1, null) : (y = a.children, e = a.fallback, p ? (a = n.mode, p = n.child, y = { mode: "hidden", children: y }, !(a & 1) && p !== null ? (p.childLanes = 0, p.pendingProps = y) : p = wa(y, a, 0, null), e = Cr(e, a, i, null), p.return = n, e.return = n, p.sibling = e, n.child = p, n.child.memoizedState = _c(i), n.memoizedState = Oc, e) : Ic(n, y)); if (c = e.memoizedState, c !== null && (k = c.dehydrated, k !== null)) return oT(e, n, y, a, k, c, i); if (p) { p = a.fallback, y = n.mode, c = e.child, k = c.sibling; var A = { mode: "hidden", children: a.children }; return !(y & 1) && n.child !== c ? (a = n.child, a.childLanes = 0, a.pendingProps = A, n.deletions = null) : (a = Zn(c, A), a.subtreeFlags = c.subtreeFlags & 14680064), k !== null ? p = Zn(k, p) : (p = Cr(p, y, i, null), p.flags |= 2), p.return = n, a.return = n, a.sibling = p, n.child = a, a = p, p = n.child, y = e.child.memoizedState, y = y === null ? _c(i) : { baseLanes: y.baseLanes | i, cachePool: null, transitions: y.transitions }, p.memoizedState = y, p.childLanes = e.childLanes & ~i, n.memoizedState = Oc, a } return p = e.child, e = p.sibling, a = Zn(p, { mode: "visible", children: a.children }), !(n.mode & 1) && (a.lanes = i), a.return = n, a.sibling = null, e !== null && (i = n.deletions, i === null ? (n.deletions = [e], n.flags |= 16) : i.push(e)), n.child = a, n.memoizedState = null, a } function Ic(e, n) { return n = wa({ mode: "visible", children: n }, e.mode, 0, null), n.return = e, e.child = n } function sa(e, n, i, a) { return a !== null && cc(a), uo(n, e.child, null, i), e = Ic(n, n.pendingProps.children), e.flags |= 2, n.memoizedState = null, e } function oT(e, n, i, a, c, p, y) { if (i) return n.flags & 256 ? (n.flags &= -257, a = Mc(Error(o(422))), sa(e, n, y, a)) : n.memoizedState !== null ? (n.child = e.child, n.flags |= 128, null) : (p = a.fallback, c = n.mode, a = wa({ mode: "visible", children: a.children }, c, 0, null), p = Cr(p, c, y, null), p.flags |= 2, a.return = n, p.return = n, a.sibling = p, n.child = a, n.mode & 1 && uo(n, e.child, null, y), n.child.memoizedState = _c(y), n.memoizedState = Oc, p); if (!(n.mode & 1)) return sa(e, n, y, null); if (c.data === "$!") { if (a = c.nextSibling && c.nextSibling.dataset, a) var k = a.dgst; return a = k, p = Error(o(419)), a = Mc(p, a, void 0), sa(e, n, y, a) } if (k = (y & e.childLanes) !== 0, ht || k) { if (a = Xe, a !== null) { switch (y & -y) { case 4: c = 2; break; case 16: c = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: c = 32; break; case 536870912: c = 268435456; break; default: c = 0 }c = c & (a.suspendedLanes | y) ? 0 : c, c !== 0 && c !== p.retryLane && (p.retryLane = c, vn(e, c), Ut(a, e, c, -1)) } return Jc(), a = Mc(Error(o(421))), sa(e, n, y, a) } return c.data === "$?" ? (n.flags |= 128, n.child = e.child, n = vT.bind(null, e), c._reactRetry = n, null) : (e = p.treeContext, Ct = Bn(c.nextSibling), St = n, De = !0, Vt = null, e !== null && (Tt[Rt++] = mn, Tt[Rt++] = gn, Tt[Rt++] = pr, mn = e.id, gn = e.overflow, pr = n), n = Ic(n, a.children), n.flags |= 4096, n) } function My(e, n, i) { e.lanes |= n; var a = e.alternate; a !== null && (a.lanes |= n), hc(e.return, n, i) } function Vc(e, n, i, a, c) { var p = e.memoizedState; p === null ? e.memoizedState = { isBackwards: n, rendering: null, renderingStartTime: 0, last: a, tail: i, tailMode: c } : (p.isBackwards = n, p.rendering = null, p.renderingStartTime = 0, p.last = a, p.tail = i, p.tailMode = c) } function Ly(e, n, i) { var a = n.pendingProps, c = a.revealOrder, p = a.tail; if (ut(e, n, a.children, i), a = _e.current, a & 2) a = a & 1 | 2, n.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = n.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && My(e, i, n); else if (e.tag === 19) My(e, i, n); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === n) break e; for (; e.sibling === null;) { if (e.return === null || e.return === n) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } a &= 1 } if (Ae(_e, a), !(n.mode & 1)) n.memoizedState = null; else switch (c) { case "forwards": for (i = n.child, c = null; i !== null;)e = i.alternate, e !== null && Js(e) === null && (c = i), i = i.sibling; i = c, i === null ? (c = n.child, n.child = null) : (c = i.sibling, i.sibling = null), Vc(n, !1, c, i, p); break; case "backwards": for (i = null, c = n.child, n.child = null; c !== null;) { if (e = c.alternate, e !== null && Js(e) === null) { n.child = c; break } e = c.sibling, c.sibling = i, i = c, c = e } Vc(n, !0, i, null, p); break; case "together": Vc(n, !1, null, null, void 0); break; default: n.memoizedState = null }return n.child } function aa(e, n) { !(n.mode & 1) && e !== null && (e.alternate = null, n.alternate = null, n.flags |= 2) } function wn(e, n, i) { if (e !== null && (n.dependencies = e.dependencies), yr |= n.lanes, !(i & n.childLanes)) return null; if (e !== null && n.child !== e.child) throw Error(o(153)); if (n.child !== null) { for (e = n.child, i = Zn(e, e.pendingProps), n.child = i, i.return = n; e.sibling !== null;)e = e.sibling, i = i.sibling = Zn(e, e.pendingProps), i.return = n; i.sibling = null } return n.child } function iT(e, n, i) { switch (n.tag) { case 3: Ry(n), lo(); break; case 5: Kv(n); break; case 1: pt(n.type) && Ws(n); break; case 4: vc(n, n.stateNode.containerInfo); break; case 10: var a = n.type._context, c = n.memoizedProps.value; Ae(Xs, a._currentValue), a._currentValue = c; break; case 13: if (a = n.memoizedState, a !== null) return a.dehydrated !== null ? (Ae(_e, _e.current & 1), n.flags |= 128, null) : i & n.child.childLanes ? Ny(e, n, i) : (Ae(_e, _e.current & 1), e = wn(e, n, i), e !== null ? e.sibling : null); Ae(_e, _e.current & 1); break; case 19: if (a = (i & n.childLanes) !== 0, e.flags & 128) { if (a) return Ly(e, n, i); n.flags |= 128 } if (c = n.memoizedState, c !== null && (c.rendering = null, c.tail = null, c.lastEffect = null), Ae(_e, _e.current), a) break; return null; case 22: case 23: return n.lanes = 0, Py(e, n, i) }return wn(e, n, i) } var Dy, Fc, jy, Oy; Dy = function (e, n) { for (var i = n.child; i !== null;) { if (i.tag === 5 || i.tag === 6) e.appendChild(i.stateNode); else if (i.tag !== 4 && i.child !== null) { i.child.return = i, i = i.child; continue } if (i === n) break; for (; i.sibling === null;) { if (i.return === null || i.return === n) return; i = i.return } i.sibling.return = i.return, i = i.sibling } }, Fc = function () { }, jy = function (e, n, i, a) { var c = e.memoizedProps; if (c !== a) { e = n.stateNode, gr(qt.current); var p = null; switch (i) { case "input": c = Ot(e, c), a = Ot(e, a), p = []; break; case "select": c = X({}, c, { value: void 0 }), a = X({}, a, { value: void 0 }), p = []; break; case "textarea": c = vu(e, c), a = vu(e, a), p = []; break; default: typeof c.onClick != "function" && typeof a.onClick == "function" && (e.onclick = zs) }wu(i, a); var y; i = null; for (_ in c) if (!a.hasOwnProperty(_) && c.hasOwnProperty(_) && c[_] != null) if (_ === "style") { var k = c[_]; for (y in k) k.hasOwnProperty(y) && (i || (i = {}), i[y] = "") } else _ !== "dangerouslySetInnerHTML" && _ !== "children" && _ !== "suppressContentEditableWarning" && _ !== "suppressHydrationWarning" && _ !== "autoFocus" && (l.hasOwnProperty(_) ? p || (p = []) : (p = p || []).push(_, null)); for (_ in a) { var A = a[_]; if (k = c?.[_], a.hasOwnProperty(_) && A !== k && (A != null || k != null)) if (_ === "style") if (k) { for (y in k) !k.hasOwnProperty(y) || A && A.hasOwnProperty(y) || (i || (i = {}), i[y] = ""); for (y in A) A.hasOwnProperty(y) && k[y] !== A[y] && (i || (i = {}), i[y] = A[y]) } else i || (p || (p = []), p.push(_, i)), i = A; else _ === "dangerouslySetInnerHTML" ? (A = A ? A.__html : void 0, k = k ? k.__html : void 0, A != null && k !== A && (p = p || []).push(_, A)) : _ === "children" ? typeof A != "string" && typeof A != "number" || (p = p || []).push(_, "" + A) : _ !== "suppressContentEditableWarning" && _ !== "suppressHydrationWarning" && (l.hasOwnProperty(_) ? (A != null && _ === "onScroll" && Me("scroll", e), p || k === A || (p = [])) : (p = p || []).push(_, A)) } i && (p = p || []).push("style", i); var _ = p; (n.updateQueue = _) && (n.flags |= 4) } }, Oy = function (e, n, i, a) { i !== a && (n.flags |= 4) }; function bi(e, n) { if (!De) switch (e.tailMode) { case "hidden": n = e.tail; for (var i = null; n !== null;)n.alternate !== null && (i = n), n = n.sibling; i === null ? e.tail = null : i.sibling = null; break; case "collapsed": i = e.tail; for (var a = null; i !== null;)i.alternate !== null && (a = i), i = i.sibling; a === null ? n || e.tail === null ? e.tail = null : e.tail.sibling = null : a.sibling = null } } function at(e) { var n = e.alternate !== null && e.alternate.child === e.child, i = 0, a = 0; if (n) for (var c = e.child; c !== null;)i |= c.lanes | c.childLanes, a |= c.subtreeFlags & 14680064, a |= c.flags & 14680064, c.return = e, c = c.sibling; else for (c = e.child; c !== null;)i |= c.lanes | c.childLanes, a |= c.subtreeFlags, a |= c.flags, c.return = e, c = c.sibling; return e.subtreeFlags |= a, e.childLanes = i, n } function sT(e, n, i) { var a = n.pendingProps; switch (ac(n), n.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return at(n), null; case 1: return pt(n.type) && Us(), at(n), null; case 3: return a = n.stateNode, po(), Le(ft), Le(it), xc(), a.pendingContext && (a.context = a.pendingContext, a.pendingContext = null), (e === null || e.child === null) && (Gs(n) ? n.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(n.flags & 256) || (n.flags |= 1024, Vt !== null && (Qc(Vt), Vt = null))), Fc(e, n), at(n), null; case 5: yc(n); var c = gr(yi.current); if (i = n.type, e !== null && n.stateNode != null) jy(e, n, i, a, c), e.ref !== n.ref && (n.flags |= 512, n.flags |= 2097152); else { if (!a) { if (n.stateNode === null) throw Error(o(166)); return at(n), null } if (e = gr(qt.current), Gs(n)) { a = n.stateNode, i = n.type; var p = n.memoizedProps; switch (a[Qt] = n, a[pi] = p, e = (n.mode & 1) !== 0, i) { case "dialog": Me("cancel", a), Me("close", a); break; case "iframe": case "object": case "embed": Me("load", a); break; case "video": case "audio": for (c = 0; c < ci.length; c++)Me(ci[c], a); break; case "source": Me("error", a); break; case "img": case "image": case "link": Me("error", a), Me("load", a); break; case "details": Me("toggle", a); break; case "input": Hr(a, p), Me("invalid", a); break; case "select": a._wrapperState = { wasMultiple: !!p.multiple }, Me("invalid", a); break; case "textarea": yg(a, p), Me("invalid", a) }wu(i, p), c = null; for (var y in p) if (p.hasOwnProperty(y)) { var k = p[y]; y === "children" ? typeof k == "string" ? a.textContent !== k && (p.suppressHydrationWarning !== !0 && Fs(a.textContent, k, e), c = ["children", k]) : typeof k == "number" && a.textContent !== "" + k && (p.suppressHydrationWarning !== !0 && Fs(a.textContent, k, e), c = ["children", "" + k]) : l.hasOwnProperty(y) && k != null && y === "onScroll" && Me("scroll", a) } switch (i) { case "input": be(a), vg(a, p, !0); break; case "textarea": be(a), xg(a); break; case "select": case "option": break; default: typeof p.onClick == "function" && (a.onclick = zs) }a = c, n.updateQueue = a, a !== null && (n.flags |= 4) } else { y = c.nodeType === 9 ? c : c.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = Sg(i)), e === "http://www.w3.org/1999/xhtml" ? i === "script" ? (e = y.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof a.is == "string" ? e = y.createElement(i, { is: a.is }) : (e = y.createElement(i), i === "select" && (y = e, a.multiple ? y.multiple = !0 : a.size && (y.size = a.size))) : e = y.createElementNS(e, i), e[Qt] = n, e[pi] = a, Dy(e, n, !1, !1), n.stateNode = e; e: { switch (y = xu(i, a), i) { case "dialog": Me("cancel", e), Me("close", e), c = a; break; case "iframe": case "object": case "embed": Me("load", e), c = a; break; case "video": case "audio": for (c = 0; c < ci.length; c++)Me(ci[c], e); c = a; break; case "source": Me("error", e), c = a; break; case "img": case "image": case "link": Me("error", e), Me("load", e), c = a; break; case "details": Me("toggle", e), c = a; break; case "input": Hr(e, a), c = Ot(e, a), Me("invalid", e); break; case "option": c = a; break; case "select": e._wrapperState = { wasMultiple: !!a.multiple }, c = X({}, a, { value: void 0 }), Me("invalid", e); break; case "textarea": yg(e, a), c = vu(e, a), Me("invalid", e); break; default: c = a }wu(i, c), k = c; for (p in k) if (k.hasOwnProperty(p)) { var A = k[p]; p === "style" ? kg(e, A) : p === "dangerouslySetInnerHTML" ? (A = A ? A.__html : void 0, A != null && Cg(e, A)) : p === "children" ? typeof A == "string" ? (i !== "textarea" || A !== "") && Ho(e, A) : typeof A == "number" && Ho(e, "" + A) : p !== "suppressContentEditableWarning" && p !== "suppressHydrationWarning" && p !== "autoFocus" && (l.hasOwnProperty(p) ? A != null && p === "onScroll" && Me("scroll", e) : A != null && L(e, p, A, y)) } switch (i) { case "input": be(e), vg(e, a, !1); break; case "textarea": be(e), xg(e); break; case "option": a.value != null && e.setAttribute("value", "" + ae(a.value)); break; case "select": e.multiple = !!a.multiple, p = a.value, p != null ? Gr(e, !!a.multiple, p, !1) : a.defaultValue != null && Gr(e, !!a.multiple, a.defaultValue, !0); break; default: typeof c.onClick == "function" && (e.onclick = zs) }switch (i) { case "button": case "input": case "select": case "textarea": a = !!a.autoFocus; break e; case "img": a = !0; break e; default: a = !1 } } a && (n.flags |= 4) } n.ref !== null && (n.flags |= 512, n.flags |= 2097152) } return at(n), null; case 6: if (e && n.stateNode != null) Oy(e, n, e.memoizedProps, a); else { if (typeof a != "string" && n.stateNode === null) throw Error(o(166)); if (i = gr(yi.current), gr(qt.current), Gs(n)) { if (a = n.stateNode, i = n.memoizedProps, a[Qt] = n, (p = a.nodeValue !== i) && (e = St, e !== null)) switch (e.tag) { case 3: Fs(a.nodeValue, i, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && Fs(a.nodeValue, i, (e.mode & 1) !== 0) }p && (n.flags |= 4) } else a = (i.nodeType === 9 ? i : i.ownerDocument).createTextNode(a), a[Qt] = n, n.stateNode = a } return at(n), null; case 13: if (Le(_e), a = n.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (De && Ct !== null && n.mode & 1 && !(n.flags & 128)) Vv(), lo(), n.flags |= 98560, p = !1; else if (p = Gs(n), a !== null && a.dehydrated !== null) { if (e === null) { if (!p) throw Error(o(318)); if (p = n.memoizedState, p = p !== null ? p.dehydrated : null, !p) throw Error(o(317)); p[Qt] = n } else lo(), !(n.flags & 128) && (n.memoizedState = null), n.flags |= 4; at(n), p = !1 } else Vt !== null && (Qc(Vt), Vt = null), p = !0; if (!p) return n.flags & 65536 ? n : null } return n.flags & 128 ? (n.lanes = i, n) : (a = a !== null, a !== (e !== null && e.memoizedState !== null) && a && (n.child.flags |= 8192, n.mode & 1 && (e === null || _e.current & 1 ? Ke === 0 && (Ke = 3) : Jc())), n.updateQueue !== null && (n.flags |= 4), at(n), null); case 4: return po(), Fc(e, n), e === null && di(n.stateNode.containerInfo), at(n), null; case 10: return pc(n.type._context), at(n), null; case 17: return pt(n.type) && Us(), at(n), null; case 19: if (Le(_e), p = n.memoizedState, p === null) return at(n), null; if (a = (n.flags & 128) !== 0, y = p.rendering, y === null) if (a) bi(p, !1); else { if (Ke !== 0 || e !== null && e.flags & 128) for (e = n.child; e !== null;) { if (y = Js(e), y !== null) { for (n.flags |= 128, bi(p, !1), a = y.updateQueue, a !== null && (n.updateQueue = a, n.flags |= 4), n.subtreeFlags = 0, a = i, i = n.child; i !== null;)p = i, e = a, p.flags &= 14680066, y = p.alternate, y === null ? (p.childLanes = 0, p.lanes = e, p.child = null, p.subtreeFlags = 0, p.memoizedProps = null, p.memoizedState = null, p.updateQueue = null, p.dependencies = null, p.stateNode = null) : (p.childLanes = y.childLanes, p.lanes = y.lanes, p.child = y.child, p.subtreeFlags = 0, p.deletions = null, p.memoizedProps = y.memoizedProps, p.memoizedState = y.memoizedState, p.updateQueue = y.updateQueue, p.type = y.type, e = y.dependencies, p.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), i = i.sibling; return Ae(_e, _e.current & 1 | 2), n.child } e = e.sibling } p.tail !== null && Ue() > vo && (n.flags |= 128, a = !0, bi(p, !1), n.lanes = 4194304) } else { if (!a) if (e = Js(y), e !== null) { if (n.flags |= 128, a = !0, i = e.updateQueue, i !== null && (n.updateQueue = i, n.flags |= 4), bi(p, !0), p.tail === null && p.tailMode === "hidden" && !y.alternate && !De) return at(n), null } else 2 * Ue() - p.renderingStartTime > vo && i !== 1073741824 && (n.flags |= 128, a = !0, bi(p, !1), n.lanes = 4194304); p.isBackwards ? (y.sibling = n.child, n.child = y) : (i = p.last, i !== null ? i.sibling = y : n.child = y, p.last = y) } return p.tail !== null ? (n = p.tail, p.rendering = n, p.tail = n.sibling, p.renderingStartTime = Ue(), n.sibling = null, i = _e.current, Ae(_e, a ? i & 1 | 2 : i & 1), n) : (at(n), null); case 22: case 23: return Zc(), a = n.memoizedState !== null, e !== null && e.memoizedState !== null !== a && (n.flags |= 8192), a && n.mode & 1 ? bt & 1073741824 && (at(n), n.subtreeFlags & 6 && (n.flags |= 8192)) : at(n), null; case 24: return null; case 25: return null }throw Error(o(156, n.tag)) } function aT(e, n) { switch (ac(n), n.tag) { case 1: return pt(n.type) && Us(), e = n.flags, e & 65536 ? (n.flags = e & -65537 | 128, n) : null; case 3: return po(), Le(ft), Le(it), xc(), e = n.flags, e & 65536 && !(e & 128) ? (n.flags = e & -65537 | 128, n) : null; case 5: return yc(n), null; case 13: if (Le(_e), e = n.memoizedState, e !== null && e.dehydrated !== null) { if (n.alternate === null) throw Error(o(340)); lo() } return e = n.flags, e & 65536 ? (n.flags = e & -65537 | 128, n) : null; case 19: return Le(_e), null; case 4: return po(), null; case 10: return pc(n.type._context), null; case 22: case 23: return Zc(), null; case 24: return null; default: return null } } var la = !1, lt = !1, lT = typeof WeakSet == "function" ? WeakSet : Set, Z = null; function mo(e, n) { var i = e.ref; if (i !== null) if (typeof i == "function") try { i(null) } catch (a) { Ve(e, n, a) } else i.current = null } function zc(e, n, i) { try { i() } catch (a) { Ve(e, n, a) } } var _y = !1; function uT(e, n) { if (Zu = Rs, e = hv(), $u(e)) { if ("selectionStart" in e) var i = { start: e.selectionStart, end: e.selectionEnd }; else e: { i = (i = e.ownerDocument) && i.defaultView || window; var a = i.getSelection && i.getSelection(); if (a && a.rangeCount !== 0) { i = a.anchorNode; var c = a.anchorOffset, p = a.focusNode; a = a.focusOffset; try { i.nodeType, p.nodeType } catch { i = null; break e } var y = 0, k = -1, A = -1, _ = 0, B = 0, U = e, z = null; t: for (; ;) { for (var q; U !== i || c !== 0 && U.nodeType !== 3 || (k = y + c), U !== p || a !== 0 && U.nodeType !== 3 || (A = y + a), U.nodeType === 3 && (y += U.nodeValue.length), (q = U.firstChild) !== null;)z = U, U = q; for (; ;) { if (U === e) break t; if (z === i && ++_ === c && (k = y), z === p && ++B === a && (A = y), (q = U.nextSibling) !== null) break; U = z, z = U.parentNode } U = q } i = k === -1 || A === -1 ? null : { start: k, end: A } } else i = null } i = i || { start: 0, end: 0 } } else i = null; for (Ju = { focusedElem: e, selectionRange: i }, Rs = !1, Z = n; Z !== null;)if (n = Z, e = n.child, (n.subtreeFlags & 1028) !== 0 && e !== null) e.return = n, Z = e; else for (; Z !== null;) { n = Z; try { var ee = n.alternate; if (n.flags & 1024) switch (n.tag) { case 0: case 11: case 15: break; case 1: if (ee !== null) { var te = ee.memoizedProps, We = ee.memoizedState, D = n.stateNode, M = D.getSnapshotBeforeUpdate(n.elementType === n.type ? te : Ft(n.type, te), We); D.__reactInternalSnapshotBeforeUpdate = M } break; case 3: var O = n.stateNode.containerInfo; O.nodeType === 1 ? O.textContent = "" : O.nodeType === 9 && O.documentElement && O.removeChild(O.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(o(163)) } } catch ($) { Ve(n, n.return, $) } if (e = n.sibling, e !== null) { e.return = n.return, Z = e; break } Z = n.return } return ee = _y, _y = !1, ee } function ki(e, n, i) { var a = n.updateQueue; if (a = a !== null ? a.lastEffect : null, a !== null) { var c = a = a.next; do { if ((c.tag & e) === e) { var p = c.destroy; c.destroy = void 0, p !== void 0 && zc(n, i, p) } c = c.next } while (c !== a) } } function ua(e, n) { if (n = n.updateQueue, n = n !== null ? n.lastEffect : null, n !== null) { var i = n = n.next; do { if ((i.tag & e) === e) { var a = i.create; i.destroy = a() } i = i.next } while (i !== n) } } function Bc(e) { var n = e.ref; if (n !== null) { var i = e.stateNode; switch (e.tag) { case 5: e = i; break; default: e = i }typeof n == "function" ? n(e) : n.current = e } } function Iy(e) { var n = e.alternate; n !== null && (e.alternate = null, Iy(n)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (n = e.stateNode, n !== null && (delete n[Qt], delete n[pi], delete n[rc], delete n[HE], delete n[KE])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function Vy(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function Fy(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || Vy(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function Uc(e, n, i) { var a = e.tag; if (a === 5 || a === 6) e = e.stateNode, n ? i.nodeType === 8 ? i.parentNode.insertBefore(e, n) : i.insertBefore(e, n) : (i.nodeType === 8 ? (n = i.parentNode, n.insertBefore(e, i)) : (n = i, n.appendChild(e)), i = i._reactRootContainer, i != null || n.onclick !== null || (n.onclick = zs)); else if (a !== 4 && (e = e.child, e !== null)) for (Uc(e, n, i), e = e.sibling; e !== null;)Uc(e, n, i), e = e.sibling } function Wc(e, n, i) { var a = e.tag; if (a === 5 || a === 6) e = e.stateNode, n ? i.insertBefore(e, n) : i.appendChild(e); else if (a !== 4 && (e = e.child, e !== null)) for (Wc(e, n, i), e = e.sibling; e !== null;)Wc(e, n, i), e = e.sibling } var et = null, zt = !1; function Gn(e, n, i) { for (i = i.child; i !== null;)zy(e, n, i), i = i.sibling } function zy(e, n, i) { if (Xt && typeof Xt.onCommitFiberUnmount == "function") try { Xt.onCommitFiberUnmount(Cs, i) } catch { } switch (i.tag) { case 5: lt || mo(i, n); case 6: var a = et, c = zt; et = null, Gn(e, n, i), et = a, zt = c, et !== null && (zt ? (e = et, i = i.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(i) : e.removeChild(i)) : et.removeChild(i.stateNode)); break; case 18: et !== null && (zt ? (e = et, i = i.stateNode, e.nodeType === 8 ? nc(e.parentNode, i) : e.nodeType === 1 && nc(e, i), ni(e)) : nc(et, i.stateNode)); break; case 4: a = et, c = zt, et = i.stateNode.containerInfo, zt = !0, Gn(e, n, i), et = a, zt = c; break; case 0: case 11: case 14: case 15: if (!lt && (a = i.updateQueue, a !== null && (a = a.lastEffect, a !== null))) { c = a = a.next; do { var p = c, y = p.destroy; p = p.tag, y !== void 0 && (p & 2 || p & 4) && zc(i, n, y), c = c.next } while (c !== a) } Gn(e, n, i); break; case 1: if (!lt && (mo(i, n), a = i.stateNode, typeof a.componentWillUnmount == "function")) try { a.props = i.memoizedProps, a.state = i.memoizedState, a.componentWillUnmount() } catch (k) { Ve(i, n, k) } Gn(e, n, i); break; case 21: Gn(e, n, i); break; case 22: i.mode & 1 ? (lt = (a = lt) || i.memoizedState !== null, Gn(e, n, i), lt = a) : Gn(e, n, i); break; default: Gn(e, n, i) } } function By(e) { var n = e.updateQueue; if (n !== null) { e.updateQueue = null; var i = e.stateNode; i === null && (i = e.stateNode = new lT), n.forEach(function (a) { var c = yT.bind(null, e, a); i.has(a) || (i.add(a), a.then(c, c)) }) } } function Bt(e, n) { var i = n.deletions; if (i !== null) for (var a = 0; a < i.length; a++) { var c = i[a]; try { var p = e, y = n, k = y; e: for (; k !== null;) { switch (k.tag) { case 5: et = k.stateNode, zt = !1; break e; case 3: et = k.stateNode.containerInfo, zt = !0; break e; case 4: et = k.stateNode.containerInfo, zt = !0; break e }k = k.return } if (et === null) throw Error(o(160)); zy(p, y, c), et = null, zt = !1; var A = c.alternate; A !== null && (A.return = null), c.return = null } catch (_) { Ve(c, n, _) } } if (n.subtreeFlags & 12854) for (n = n.child; n !== null;)Uy(n, e), n = n.sibling } function Uy(e, n) { var i = e.alternate, a = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (Bt(n, e), Jt(e), a & 4) { try { ki(3, e, e.return), ua(3, e) } catch (te) { Ve(e, e.return, te) } try { ki(5, e, e.return) } catch (te) { Ve(e, e.return, te) } } break; case 1: Bt(n, e), Jt(e), a & 512 && i !== null && mo(i, i.return); break; case 5: if (Bt(n, e), Jt(e), a & 512 && i !== null && mo(i, i.return), e.flags & 32) { var c = e.stateNode; try { Ho(c, "") } catch (te) { Ve(e, e.return, te) } } if (a & 4 && (c = e.stateNode, c != null)) { var p = e.memoizedProps, y = i !== null ? i.memoizedProps : p, k = e.type, A = e.updateQueue; if (e.updateQueue = null, A !== null) try { k === "input" && p.type === "radio" && p.name != null && Kr(c, p), xu(k, y); var _ = xu(k, p); for (y = 0; y < A.length; y += 2) { var B = A[y], U = A[y + 1]; B === "style" ? kg(c, U) : B === "dangerouslySetInnerHTML" ? Cg(c, U) : B === "children" ? Ho(c, U) : L(c, B, U, _) } switch (k) { case "input": ur(c, p); break; case "textarea": wg(c, p); break; case "select": var z = c._wrapperState.wasMultiple; c._wrapperState.wasMultiple = !!p.multiple; var q = p.value; q != null ? Gr(c, !!p.multiple, q, !1) : z !== !!p.multiple && (p.defaultValue != null ? Gr(c, !!p.multiple, p.defaultValue, !0) : Gr(c, !!p.multiple, p.multiple ? [] : "", !1)) }c[pi] = p } catch (te) { Ve(e, e.return, te) } } break; case 6: if (Bt(n, e), Jt(e), a & 4) { if (e.stateNode === null) throw Error(o(162)); c = e.stateNode, p = e.memoizedProps; try { c.nodeValue = p } catch (te) { Ve(e, e.return, te) } } break; case 3: if (Bt(n, e), Jt(e), a & 4 && i !== null && i.memoizedState.isDehydrated) try { ni(n.containerInfo) } catch (te) { Ve(e, e.return, te) } break; case 4: Bt(n, e), Jt(e); break; case 13: Bt(n, e), Jt(e), c = e.child, c.flags & 8192 && (p = c.memoizedState !== null, c.stateNode.isHidden = p, !p || c.alternate !== null && c.alternate.memoizedState !== null || (Kc = Ue())), a & 4 && By(e); break; case 22: if (B = i !== null && i.memoizedState !== null, e.mode & 1 ? (lt = (_ = lt) || B, Bt(n, e), lt = _) : Bt(n, e), Jt(e), a & 8192) { if (_ = e.memoizedState !== null, (e.stateNode.isHidden = _) && !B && e.mode & 1) for (Z = e, B = e.child; B !== null;) { for (U = Z = B; Z !== null;) { switch (z = Z, q = z.child, z.tag) { case 0: case 11: case 14: case 15: ki(4, z, z.return); break; case 1: mo(z, z.return); var ee = z.stateNode; if (typeof ee.componentWillUnmount == "function") { a = z, i = z.return; try { n = a, ee.props = n.memoizedProps, ee.state = n.memoizedState, ee.componentWillUnmount() } catch (te) { Ve(a, i, te) } } break; case 5: mo(z, z.return); break; case 22: if (z.memoizedState !== null) { Hy(U); continue } }q !== null ? (q.return = z, Z = q) : Hy(U) } B = B.sibling } e: for (B = null, U = e; ;) { if (U.tag === 5) { if (B === null) { B = U; try { c = U.stateNode, _ ? (p = c.style, typeof p.setProperty == "function" ? p.setProperty("display", "none", "important") : p.display = "none") : (k = U.stateNode, A = U.memoizedProps.style, y = A != null && A.hasOwnProperty("display") ? A.display : null, k.style.display = bg("display", y)) } catch (te) { Ve(e, e.return, te) } } } else if (U.tag === 6) { if (B === null) try { U.stateNode.nodeValue = _ ? "" : U.memoizedProps } catch (te) { Ve(e, e.return, te) } } else if ((U.tag !== 22 && U.tag !== 23 || U.memoizedState === null || U === e) && U.child !== null) { U.child.return = U, U = U.child; continue } if (U === e) break e; for (; U.sibling === null;) { if (U.return === null || U.return === e) break e; B === U && (B = null), U = U.return } B === U && (B = null), U.sibling.return = U.return, U = U.sibling } } break; case 19: Bt(n, e), Jt(e), a & 4 && By(e); break; case 21: break; default: Bt(n, e), Jt(e) } } function Jt(e) { var n = e.flags; if (n & 2) { try { e: { for (var i = e.return; i !== null;) { if (Vy(i)) { var a = i; break e } i = i.return } throw Error(o(160)) } switch (a.tag) { case 5: var c = a.stateNode; a.flags & 32 && (Ho(c, ""), a.flags &= -33); var p = Fy(e); Wc(e, p, c); break; case 3: case 4: var y = a.stateNode.containerInfo, k = Fy(e); Uc(e, k, y); break; default: throw Error(o(161)) } } catch (A) { Ve(e, e.return, A) } e.flags &= -3 } n & 4096 && (e.flags &= -4097) } function cT(e, n, i) { Z = e, Wy(e) } function Wy(e, n, i) { for (var a = (e.mode & 1) !== 0; Z !== null;) { var c = Z, p = c.child; if (c.tag === 22 && a) { var y = c.memoizedState !== null || la; if (!y) { var k = c.alternate, A = k !== null && k.memoizedState !== null || lt; k = la; var _ = lt; if (la = y, (lt = A) && !_) for (Z = c; Z !== null;)y = Z, A = y.child, y.tag === 22 && y.memoizedState !== null ? Ky(c) : A !== null ? (A.return = y, Z = A) : Ky(c); for (; p !== null;)Z = p, Wy(p), p = p.sibling; Z = c, la = k, lt = _ } $y(e) } else c.subtreeFlags & 8772 && p !== null ? (p.return = c, Z = p) : $y(e) } } function $y(e) { for (; Z !== null;) { var n = Z; if (n.flags & 8772) { var i = n.alternate; try { if (n.flags & 8772) switch (n.tag) { case 0: case 11: case 15: lt || ua(5, n); break; case 1: var a = n.stateNode; if (n.flags & 4 && !lt) if (i === null) a.componentDidMount(); else { var c = n.elementType === n.type ? i.memoizedProps : Ft(n.type, i.memoizedProps); a.componentDidUpdate(c, i.memoizedState, a.__reactInternalSnapshotBeforeUpdate) } var p = n.updateQueue; p !== null && Hv(n, p, a); break; case 3: var y = n.updateQueue; if (y !== null) { if (i = null, n.child !== null) switch (n.child.tag) { case 5: i = n.child.stateNode; break; case 1: i = n.child.stateNode }Hv(n, y, i) } break; case 5: var k = n.stateNode; if (i === null && n.flags & 4) { i = k; var A = n.memoizedProps; switch (n.type) { case "button": case "input": case "select": case "textarea": A.autoFocus && i.focus(); break; case "img": A.src && (i.src = A.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (n.memoizedState === null) { var _ = n.alternate; if (_ !== null) { var B = _.memoizedState; if (B !== null) { var U = B.dehydrated; U !== null && ni(U) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(o(163)) }lt || n.flags & 512 && Bc(n) } catch (z) { Ve(n, n.return, z) } } if (n === e) { Z = null; break } if (i = n.sibling, i !== null) { i.return = n.return, Z = i; break } Z = n.return } } function Hy(e) { for (; Z !== null;) { var n = Z; if (n === e) { Z = null; break } var i = n.sibling; if (i !== null) { i.return = n.return, Z = i; break } Z = n.return } } function Ky(e) { for (; Z !== null;) { var n = Z; try { switch (n.tag) { case 0: case 11: case 15: var i = n.return; try { ua(4, n) } catch (A) { Ve(n, i, A) } break; case 1: var a = n.stateNode; if (typeof a.componentDidMount == "function") { var c = n.return; try { a.componentDidMount() } catch (A) { Ve(n, c, A) } } var p = n.return; try { Bc(n) } catch (A) { Ve(n, p, A) } break; case 5: var y = n.return; try { Bc(n) } catch (A) { Ve(n, y, A) } } } catch (A) { Ve(n, n.return, A) } if (n === e) { Z = null; break } var k = n.sibling; if (k !== null) { k.return = n.return, Z = k; break } Z = n.return } } var dT = Math.ceil, ca = j.ReactCurrentDispatcher, $c = j.ReactCurrentOwner, Mt = j.ReactCurrentBatchConfig, ke = 0, Xe = null, $e = null, tt = 0, bt = 0, go = Un(0), Ke = 0, Pi = null, yr = 0, da = 0, Hc = 0, Ei = null, mt = null, Kc = 0, vo = 1 / 0, xn = null, fa = !1, Gc = null, Yn = null, pa = !1, Xn = null, ha = 0, Ti = 0, Yc = null, ma = -1, ga = 0; function ct() { return ke & 6 ? Ue() : ma !== -1 ? ma : ma = Ue() } function Qn(e) { return e.mode & 1 ? ke & 2 && tt !== 0 ? tt & -tt : YE.transition !== null ? (ga === 0 && (ga = Fg()), ga) : (e = Ee, e !== 0 || (e = window.event, e = e === void 0 ? 16 : Yg(e.type)), e) : 1 } function Ut(e, n, i, a) { if (50 < Ti) throw Ti = 0, Yc = null, Error(o(185)); qo(e, i, a), (!(ke & 2) || e !== Xe) && (e === Xe && (!(ke & 2) && (da |= i), Ke === 4 && qn(e, tt)), gt(e, a), i === 1 && ke === 0 && !(n.mode & 1) && (vo = Ue() + 500, $s && $n())) } function gt(e, n) { var i = e.callbackNode; YP(e, n); var a = Ps(e, e === Xe ? tt : 0); if (a === 0) i !== null && _g(i), e.callbackNode = null, e.callbackPriority = 0; else if (n = a & -a, e.callbackPriority !== n) { if (i != null && _g(i), n === 1) e.tag === 0 ? GE(Yy.bind(null, e)) : Dv(Yy.bind(null, e)), WE(function () { !(ke & 6) && $n() }), i = null; else { switch (zg(a)) { case 1: i = Tu; break; case 4: i = Ig; break; case 16: i = Ss; break; case 536870912: i = Vg; break; default: i = Ss }i = n0(i, Gy.bind(null, e)) } e.callbackPriority = n, e.callbackNode = i } } function Gy(e, n) { if (ma = -1, ga = 0, ke & 6) throw Error(o(327)); var i = e.callbackNode; if (yo() && e.callbackNode !== i) return null; var a = Ps(e, e === Xe ? tt : 0); if (a === 0) return null; if (a & 30 || a & e.expiredLanes || n) n = va(e, a); else { n = a; var c = ke; ke |= 2; var p = Qy(); (Xe !== e || tt !== n) && (xn = null, vo = Ue() + 500, xr(e, n)); do try { hT(); break } catch (k) { Xy(e, k) } while (1); fc(), ca.current = p, ke = c, $e !== null ? n = 0 : (Xe = null, tt = 0, n = Ke) } if (n !== 0) { if (n === 2 && (c = Ru(e), c !== 0 && (a = c, n = Xc(e, c))), n === 1) throw i = Pi, xr(e, 0), qn(e, a), gt(e, Ue()), i; if (n === 6) qn(e, a); else { if (c = e.current.alternate, !(a & 30) && !fT(c) && (n = va(e, a), n === 2 && (p = Ru(e), p !== 0 && (a = p, n = Xc(e, p))), n === 1)) throw i = Pi, xr(e, 0), qn(e, a), gt(e, Ue()), i; switch (e.finishedWork = c, e.finishedLanes = a, n) { case 0: case 1: throw Error(o(345)); case 2: Sr(e, mt, xn); break; case 3: if (qn(e, a), (a & 130023424) === a && (n = Kc + 500 - Ue(), 10 < n)) { if (Ps(e, 0) !== 0) break; if (c = e.suspendedLanes, (c & a) !== a) { ct(), e.pingedLanes |= e.suspendedLanes & c; break } e.timeoutHandle = tc(Sr.bind(null, e, mt, xn), n); break } Sr(e, mt, xn); break; case 4: if (qn(e, a), (a & 4194240) === a) break; for (n = e.eventTimes, c = -1; 0 < a;) { var y = 31 - _t(a); p = 1 << y, y = n[y], y > c && (c = y), a &= ~p } if (a = c, a = Ue() - a, a = (120 > a ? 120 : 480 > a ? 480 : 1080 > a ? 1080 : 1920 > a ? 1920 : 3e3 > a ? 3e3 : 4320 > a ? 4320 : 1960 * dT(a / 1960)) - a, 10 < a) { e.timeoutHandle = tc(Sr.bind(null, e, mt, xn), a); break } Sr(e, mt, xn); break; case 5: Sr(e, mt, xn); break; default: throw Error(o(329)) } } } return gt(e, Ue()), e.callbackNode === i ? Gy.bind(null, e) : null } function Xc(e, n) { var i = Ei; return e.current.memoizedState.isDehydrated && (xr(e, n).flags |= 256), e = va(e, n), e !== 2 && (n = mt, mt = i, n !== null && Qc(n)), e } function Qc(e) { mt === null ? mt = e : mt.push.apply(mt, e) } function fT(e) { for (var n = e; ;) { if (n.flags & 16384) { var i = n.updateQueue; if (i !== null && (i = i.stores, i !== null)) for (var a = 0; a < i.length; a++) { var c = i[a], p = c.getSnapshot; c = c.value; try { if (!It(p(), c)) return !1 } catch { return !1 } } } if (i = n.child, n.subtreeFlags & 16384 && i !== null) i.return = n, n = i; else { if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return !0; n = n.return } n.sibling.return = n.return, n = n.sibling } } return !0 } function qn(e, n) { for (n &= ~Hc, n &= ~da, e.suspendedLanes |= n, e.pingedLanes &= ~n, e = e.expirationTimes; 0 < n;) { var i = 31 - _t(n), a = 1 << i; e[i] = -1, n &= ~a } } function Yy(e) { if (ke & 6) throw Error(o(327)); yo(); var n = Ps(e, 0); if (!(n & 1)) return gt(e, Ue()), null; var i = va(e, n); if (e.tag !== 0 && i === 2) { var a = Ru(e); a !== 0 && (n = a, i = Xc(e, a)) } if (i === 1) throw i = Pi, xr(e, 0), qn(e, n), gt(e, Ue()), i; if (i === 6) throw Error(o(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = n, Sr(e, mt, xn), gt(e, Ue()), null } function qc(e, n) { var i = ke; ke |= 1; try { return e(n) } finally { ke = i, ke === 0 && (vo = Ue() + 500, $s && $n()) } } function wr(e) { Xn !== null && Xn.tag === 0 && !(ke & 6) && yo(); var n = ke; ke |= 1; var i = Mt.transition, a = Ee; try { if (Mt.transition = null, Ee = 1, e) return e() } finally { Ee = a, Mt.transition = i, ke = n, !(ke & 6) && $n() } } function Zc() { bt = go.current, Le(go) } function xr(e, n) { e.finishedWork = null, e.finishedLanes = 0; var i = e.timeoutHandle; if (i !== -1 && (e.timeoutHandle = -1, UE(i)), $e !== null) for (i = $e.return; i !== null;) { var a = i; switch (ac(a), a.tag) { case 1: a = a.type.childContextTypes, a != null && Us(); break; case 3: po(), Le(ft), Le(it), xc(); break; case 5: yc(a); break; case 4: po(); break; case 13: Le(_e); break; case 19: Le(_e); break; case 10: pc(a.type._context); break; case 22: case 23: Zc() }i = i.return } if (Xe = e, $e = e = Zn(e.current, null), tt = bt = n, Ke = 0, Pi = null, Hc = da = yr = 0, mt = Ei = null, mr !== null) { for (n = 0; n < mr.length; n++)if (i = mr[n], a = i.interleaved, a !== null) { i.interleaved = null; var c = a.next, p = i.pending; if (p !== null) { var y = p.next; p.next = c, a.next = y } i.pending = a } mr = null } return e } function Xy(e, n) { do { var i = $e; try { if (fc(), ea.current = oa, ta) { for (var a = Ie.memoizedState; a !== null;) { var c = a.queue; c !== null && (c.pending = null), a = a.next } ta = !1 } if (vr = 0, Ye = He = Ie = null, wi = !1, xi = 0, $c.current = null, i === null || i.return === null) { Ke = 1, Pi = n, $e = null; break } e: { var p = e, y = i.return, k = i, A = n; if (n = tt, k.flags |= 32768, A !== null && typeof A == "object" && typeof A.then == "function") { var _ = A, B = k, U = B.tag; if (!(B.mode & 1) && (U === 0 || U === 11 || U === 15)) { var z = B.alternate; z ? (B.updateQueue = z.updateQueue, B.memoizedState = z.memoizedState, B.lanes = z.lanes) : (B.updateQueue = null, B.memoizedState = null) } var q = xy(y); if (q !== null) { q.flags &= -257, Sy(q, y, k, p, n), q.mode & 1 && wy(p, _, n), n = q, A = _; var ee = n.updateQueue; if (ee === null) { var te = new Set; te.add(A), n.updateQueue = te } else ee.add(A); break e } else { if (!(n & 1)) { wy(p, _, n), Jc(); break e } A = Error(o(426)) } } else if (De && k.mode & 1) { var We = xy(y); if (We !== null) { !(We.flags & 65536) && (We.flags |= 256), Sy(We, y, k, p, n), cc(ho(A, k)); break e } } p = A = ho(A, k), Ke !== 4 && (Ke = 2), Ei === null ? Ei = [p] : Ei.push(p), p = y; do { switch (p.tag) { case 3: p.flags |= 65536, n &= -n, p.lanes |= n; var D = vy(p, A, n); $v(p, D); break e; case 1: k = A; var M = p.type, O = p.stateNode; if (!(p.flags & 128) && (typeof M.getDerivedStateFromError == "function" || O !== null && typeof O.componentDidCatch == "function" && (Yn === null || !Yn.has(O)))) { p.flags |= 65536, n &= -n, p.lanes |= n; var $ = yy(p, k, n); $v(p, $); break e } }p = p.return } while (p !== null) } Zy(i) } catch (re) { n = re, $e === i && i !== null && ($e = i = i.return); continue } break } while (1) } function Qy() { var e = ca.current; return ca.current = oa, e === null ? oa : e } function Jc() { (Ke === 0 || Ke === 3 || Ke === 2) && (Ke = 4), Xe === null || !(yr & 268435455) && !(da & 268435455) || qn(Xe, tt) } function va(e, n) { var i = ke; ke |= 2; var a = Qy(); (Xe !== e || tt !== n) && (xn = null, xr(e, n)); do try { pT(); break } catch (c) { Xy(e, c) } while (1); if (fc(), ke = i, ca.current = a, $e !== null) throw Error(o(261)); return Xe = null, tt = 0, Ke } function pT() { for (; $e !== null;)qy($e) } function hT() { for (; $e !== null && !FP();)qy($e) } function qy(e) { var n = t0(e.alternate, e, bt); e.memoizedProps = e.pendingProps, n === null ? Zy(e) : $e = n, $c.current = null } function Zy(e) { var n = e; do { var i = n.alternate; if (e = n.return, n.flags & 32768) { if (i = aT(i, n), i !== null) { i.flags &= 32767, $e = i; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { Ke = 6, $e = null; return } } else if (i = sT(i, n, bt), i !== null) { $e = i; return } if (n = n.sibling, n !== null) { $e = n; return } $e = n = e } while (n !== null); Ke === 0 && (Ke = 5) } function Sr(e, n, i) { var a = Ee, c = Mt.transition; try { Mt.transition = null, Ee = 1, mT(e, n, i, a) } finally { Mt.transition = c, Ee = a } return null } function mT(e, n, i, a) { do yo(); while (Xn !== null); if (ke & 6) throw Error(o(327)); i = e.finishedWork; var c = e.finishedLanes; if (i === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, i === e.current) throw Error(o(177)); e.callbackNode = null, e.callbackPriority = 0; var p = i.lanes | i.childLanes; if (XP(e, p), e === Xe && ($e = Xe = null, tt = 0), !(i.subtreeFlags & 2064) && !(i.flags & 2064) || pa || (pa = !0, n0(Ss, function () { return yo(), null })), p = (i.flags & 15990) !== 0, i.subtreeFlags & 15990 || p) { p = Mt.transition, Mt.transition = null; var y = Ee; Ee = 1; var k = ke; ke |= 4, $c.current = null, uT(e, i), Uy(i, e), OE(Ju), Rs = !!Zu, Ju = Zu = null, e.current = i, cT(i), zP(), ke = k, Ee = y, Mt.transition = p } else e.current = i; if (pa && (pa = !1, Xn = e, ha = c), p = e.pendingLanes, p === 0 && (Yn = null), WP(i.stateNode), gt(e, Ue()), n !== null) for (a = e.onRecoverableError, i = 0; i < n.length; i++)c = n[i], a(c.value, { componentStack: c.stack, digest: c.digest }); if (fa) throw fa = !1, e = Gc, Gc = null, e; return ha & 1 && e.tag !== 0 && yo(), p = e.pendingLanes, p & 1 ? e === Yc ? Ti++ : (Ti = 0, Yc = e) : Ti = 0, $n(), null } function yo() { if (Xn !== null) { var e = zg(ha), n = Mt.transition, i = Ee; try { if (Mt.transition = null, Ee = 16 > e ? 16 : e, Xn === null) var a = !1; else { if (e = Xn, Xn = null, ha = 0, ke & 6) throw Error(o(331)); var c = ke; for (ke |= 4, Z = e.current; Z !== null;) { var p = Z, y = p.child; if (Z.flags & 16) { var k = p.deletions; if (k !== null) { for (var A = 0; A < k.length; A++) { var _ = k[A]; for (Z = _; Z !== null;) { var B = Z; switch (B.tag) { case 0: case 11: case 15: ki(8, B, p) }var U = B.child; if (U !== null) U.return = B, Z = U; else for (; Z !== null;) { B = Z; var z = B.sibling, q = B.return; if (Iy(B), B === _) { Z = null; break } if (z !== null) { z.return = q, Z = z; break } Z = q } } } var ee = p.alternate; if (ee !== null) { var te = ee.child; if (te !== null) { ee.child = null; do { var We = te.sibling; te.sibling = null, te = We } while (te !== null) } } Z = p } } if (p.subtreeFlags & 2064 && y !== null) y.return = p, Z = y; else e: for (; Z !== null;) { if (p = Z, p.flags & 2048) switch (p.tag) { case 0: case 11: case 15: ki(9, p, p.return) }var D = p.sibling; if (D !== null) { D.return = p.return, Z = D; break e } Z = p.return } } var M = e.current; for (Z = M; Z !== null;) { y = Z; var O = y.child; if (y.subtreeFlags & 2064 && O !== null) O.return = y, Z = O; else e: for (y = M; Z !== null;) { if (k = Z, k.flags & 2048) try { switch (k.tag) { case 0: case 11: case 15: ua(9, k) } } catch (re) { Ve(k, k.return, re) } if (k === y) { Z = null; break e } var $ = k.sibling; if ($ !== null) { $.return = k.return, Z = $; break e } Z = k.return } } if (ke = c, $n(), Xt && typeof Xt.onPostCommitFiberRoot == "function") try { Xt.onPostCommitFiberRoot(Cs, e) } catch { } a = !0 } return a } finally { Ee = i, Mt.transition = n } } return !1 } function Jy(e, n, i) { n = ho(i, n), n = vy(e, n, 1), e = Kn(e, n, 1), n = ct(), e !== null && (qo(e, 1, n), gt(e, n)) } function Ve(e, n, i) { if (e.tag === 3) Jy(e, e, i); else for (; n !== null;) { if (n.tag === 3) { Jy(n, e, i); break } else if (n.tag === 1) { var a = n.stateNode; if (typeof n.type.getDerivedStateFromError == "function" || typeof a.componentDidCatch == "function" && (Yn === null || !Yn.has(a))) { e = ho(i, e), e = yy(n, e, 1), n = Kn(n, e, 1), e = ct(), n !== null && (qo(n, 1, e), gt(n, e)); break } } n = n.return } } function gT(e, n, i) { var a = e.pingCache; a !== null && a.delete(n), n = ct(), e.pingedLanes |= e.suspendedLanes & i, Xe === e && (tt & i) === i && (Ke === 4 || Ke === 3 && (tt & 130023424) === tt && 500 > Ue() - Kc ? xr(e, 0) : Hc |= i), gt(e, n) } function e0(e, n) { n === 0 && (e.mode & 1 ? (n = ks, ks <<= 1, !(ks & 130023424) && (ks = 4194304)) : n = 1); var i = ct(); e = vn(e, n), e !== null && (qo(e, n, i), gt(e, i)) } function vT(e) { var n = e.memoizedState, i = 0; n !== null && (i = n.retryLane), e0(e, i) } function yT(e, n) { var i = 0; switch (e.tag) { case 13: var a = e.stateNode, c = e.memoizedState; c !== null && (i = c.retryLane); break; case 19: a = e.stateNode; break; default: throw Error(o(314)) }a !== null && a.delete(n), e0(e, i) } var t0; t0 = function (e, n, i) { if (e !== null) if (e.memoizedProps !== n.pendingProps || ft.current) ht = !0; else { if (!(e.lanes & i) && !(n.flags & 128)) return ht = !1, iT(e, n, i); ht = !!(e.flags & 131072) } else ht = !1, De && n.flags & 1048576 && jv(n, Ks, n.index); switch (n.lanes = 0, n.tag) { case 2: var a = n.type; aa(e, n), e = n.pendingProps; var c = io(n, it.current); fo(n, i), c = bc(null, n, a, e, c, i); var p = kc(); return n.flags |= 1, typeof c == "object" && c !== null && typeof c.render == "function" && c.$$typeof === void 0 ? (n.tag = 1, n.memoizedState = null, n.updateQueue = null, pt(a) ? (p = !0, Ws(n)) : p = !1, n.memoizedState = c.state !== null && c.state !== void 0 ? c.state : null, gc(n), c.updater = ia, n.stateNode = c, c._reactInternals = n, Nc(n, a, e, i), n = jc(null, n, a, !0, p, i)) : (n.tag = 0, De && p && sc(n), ut(null, n, c, i), n = n.child), n; case 16: a = n.elementType; e: { switch (aa(e, n), e = n.pendingProps, c = a._init, a = c(a._payload), n.type = a, c = n.tag = xT(a), e = Ft(a, e), c) { case 0: n = Dc(null, n, a, e, i); break e; case 1: n = Ty(null, n, a, e, i); break e; case 11: n = Cy(null, n, a, e, i); break e; case 14: n = by(null, n, a, Ft(a.type, e), i); break e }throw Error(o(306, a, "")) } return n; case 0: return a = n.type, c = n.pendingProps, c = n.elementType === a ? c : Ft(a, c), Dc(e, n, a, c, i); case 1: return a = n.type, c = n.pendingProps, c = n.elementType === a ? c : Ft(a, c), Ty(e, n, a, c, i); case 3: e: { if (Ry(n), e === null) throw Error(o(387)); a = n.pendingProps, p = n.memoizedState, c = p.element, Wv(e, n), Zs(n, a, null, i); var y = n.memoizedState; if (a = y.element, p.isDehydrated) if (p = { element: a, isDehydrated: !1, cache: y.cache, pendingSuspenseBoundaries: y.pendingSuspenseBoundaries, transitions: y.transitions }, n.updateQueue.baseState = p, n.memoizedState = p, n.flags & 256) { c = ho(Error(o(423)), n), n = Ay(e, n, a, i, c); break e } else if (a !== c) { c = ho(Error(o(424)), n), n = Ay(e, n, a, i, c); break e } else for (Ct = Bn(n.stateNode.containerInfo.firstChild), St = n, De = !0, Vt = null, i = Bv(n, null, a, i), n.child = i; i;)i.flags = i.flags & -3 | 4096, i = i.sibling; else { if (lo(), a === c) { n = wn(e, n, i); break e } ut(e, n, a, i) } n = n.child } return n; case 5: return Kv(n), e === null && uc(n), a = n.type, c = n.pendingProps, p = e !== null ? e.memoizedProps : null, y = c.children, ec(a, c) ? y = null : p !== null && ec(a, p) && (n.flags |= 32), Ey(e, n), ut(e, n, y, i), n.child; case 6: return e === null && uc(n), null; case 13: return Ny(e, n, i); case 4: return vc(n, n.stateNode.containerInfo), a = n.pendingProps, e === null ? n.child = uo(n, null, a, i) : ut(e, n, a, i), n.child; case 11: return a = n.type, c = n.pendingProps, c = n.elementType === a ? c : Ft(a, c), Cy(e, n, a, c, i); case 7: return ut(e, n, n.pendingProps, i), n.child; case 8: return ut(e, n, n.pendingProps.children, i), n.child; case 12: return ut(e, n, n.pendingProps.children, i), n.child; case 10: e: { if (a = n.type._context, c = n.pendingProps, p = n.memoizedProps, y = c.value, Ae(Xs, a._currentValue), a._currentValue = y, p !== null) if (It(p.value, y)) { if (p.children === c.children && !ft.current) { n = wn(e, n, i); break e } } else for (p = n.child, p !== null && (p.return = n); p !== null;) { var k = p.dependencies; if (k !== null) { y = p.child; for (var A = k.firstContext; A !== null;) { if (A.context === a) { if (p.tag === 1) { A = yn(-1, i & -i), A.tag = 2; var _ = p.updateQueue; if (_ !== null) { _ = _.shared; var B = _.pending; B === null ? A.next = A : (A.next = B.next, B.next = A), _.pending = A } } p.lanes |= i, A = p.alternate, A !== null && (A.lanes |= i), hc(p.return, i, n), k.lanes |= i; break } A = A.next } } else if (p.tag === 10) y = p.type === n.type ? null : p.child; else if (p.tag === 18) { if (y = p.return, y === null) throw Error(o(341)); y.lanes |= i, k = y.alternate, k !== null && (k.lanes |= i), hc(y, i, n), y = p.sibling } else y = p.child; if (y !== null) y.return = p; else for (y = p; y !== null;) { if (y === n) { y = null; break } if (p = y.sibling, p !== null) { p.return = y.return, y = p; break } y = y.return } p = y } ut(e, n, c.children, i), n = n.child } return n; case 9: return c = n.type, a = n.pendingProps.children, fo(n, i), c = At(c), a = a(c), n.flags |= 1, ut(e, n, a, i), n.child; case 14: return a = n.type, c = Ft(a, n.pendingProps), c = Ft(a.type, c), by(e, n, a, c, i); case 15: return ky(e, n, n.type, n.pendingProps, i); case 17: return a = n.type, c = n.pendingProps, c = n.elementType === a ? c : Ft(a, c), aa(e, n), n.tag = 1, pt(a) ? (e = !0, Ws(n)) : e = !1, fo(n, i), my(n, a, c), Nc(n, a, c, i), jc(null, n, a, !0, e, i); case 19: return Ly(e, n, i); case 22: return Py(e, n, i) }throw Error(o(156, n.tag)) }; function n0(e, n) { return Og(e, n) } function wT(e, n, i, a) { this.tag = e, this.key = i, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = n, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = a, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Lt(e, n, i, a) { return new wT(e, n, i, a) } function ed(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function xT(e) { if (typeof e == "function") return ed(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === J) return 11; if (e === oe) return 14 } return 2 } function Zn(e, n) { var i = e.alternate; return i === null ? (i = Lt(e.tag, n, e.key, e.mode), i.elementType = e.elementType, i.type = e.type, i.stateNode = e.stateNode, i.alternate = e, e.alternate = i) : (i.pendingProps = n, i.type = e.type, i.flags = 0, i.subtreeFlags = 0, i.deletions = null), i.flags = e.flags & 14680064, i.childLanes = e.childLanes, i.lanes = e.lanes, i.child = e.child, i.memoizedProps = e.memoizedProps, i.memoizedState = e.memoizedState, i.updateQueue = e.updateQueue, n = e.dependencies, i.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }, i.sibling = e.sibling, i.index = e.index, i.ref = e.ref, i } function ya(e, n, i, a, c, p) { var y = 2; if (a = e, typeof e == "function") ed(e) && (y = 1); else if (typeof e == "string") y = 5; else e: switch (e) { case H: return Cr(i.children, c, p, n); case W: y = 8, c |= 8; break; case le: return e = Lt(12, i, n, c | 2), e.elementType = le, e.lanes = p, e; case Se: return e = Lt(13, i, n, c), e.elementType = Se, e.lanes = p, e; case ne: return e = Lt(19, i, n, c), e.elementType = ne, e.lanes = p, e; case G: return wa(i, c, p, n); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case ie: y = 10; break e; case ge: y = 9; break e; case J: y = 11; break e; case oe: y = 14; break e; case ue: y = 16, a = null; break e }throw Error(o(130, e == null ? e : typeof e, "")) }return n = Lt(y, i, n, c), n.elementType = e, n.type = a, n.lanes = p, n } function Cr(e, n, i, a) { return e = Lt(7, e, a, n), e.lanes = i, e } function wa(e, n, i, a) { return e = Lt(22, e, a, n), e.elementType = G, e.lanes = i, e.stateNode = { isHidden: !1 }, e } function td(e, n, i) { return e = Lt(6, e, null, n), e.lanes = i, e } function nd(e, n, i) { return n = Lt(4, e.children !== null ? e.children : [], e.key, n), n.lanes = i, n.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, n } function ST(e, n, i, a, c) { this.tag = n, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Au(0), this.expirationTimes = Au(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Au(0), this.identifierPrefix = a, this.onRecoverableError = c, this.mutableSourceEagerHydrationData = null } function rd(e, n, i, a, c, p, y, k, A) { return e = new ST(e, n, i, k, A), n === 1 ? (n = 1, p === !0 && (n |= 8)) : n = 0, p = Lt(3, null, null, n), e.current = p, p.stateNode = e, p.memoizedState = { element: a, isDehydrated: i, cache: null, transitions: null, pendingSuspenseBoundaries: null }, gc(p), e } function CT(e, n, i) { var a = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: K, key: a == null ? null : "" + a, children: e, containerInfo: n, implementation: i } } function r0(e) { if (!e) return Wn; e = e._reactInternals; e: { if (cr(e) !== e || e.tag !== 1) throw Error(o(170)); var n = e; do { switch (n.tag) { case 3: n = n.stateNode.context; break e; case 1: if (pt(n.type)) { n = n.stateNode.__reactInternalMemoizedMergedChildContext; break e } }n = n.return } while (n !== null); throw Error(o(171)) } if (e.tag === 1) { var i = e.type; if (pt(i)) return Mv(e, i, n) } return n } function o0(e, n, i, a, c, p, y, k, A) { return e = rd(i, a, !0, e, c, p, y, k, A), e.context = r0(null), i = e.current, a = ct(), c = Qn(i), p = yn(a, c), p.callback = n ?? null, Kn(i, p, c), e.current.lanes = c, qo(e, c, a), gt(e, a), e } function xa(e, n, i, a) { var c = n.current, p = ct(), y = Qn(c); return i = r0(i), n.context === null ? n.context = i : n.pendingContext = i, n = yn(p, y), n.payload = { element: e }, a = a === void 0 ? null : a, a !== null && (n.callback = a), e = Kn(c, n, y), e !== null && (Ut(e, c, y, p), qs(e, c, y)), y } function Sa(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function i0(e, n) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var i = e.retryLane; e.retryLane = i !== 0 && i < n ? i : n } } function od(e, n) { i0(e, n), (e = e.alternate) && i0(e, n) } function bT() { return null } var s0 = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function id(e) { this._internalRoot = e } Ca.prototype.render = id.prototype.render = function (e) { var n = this._internalRoot; if (n === null) throw Error(o(409)); xa(e, n, null, null) }, Ca.prototype.unmount = id.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var n = e.containerInfo; wr(function () { xa(null, e, null, null) }), n[pn] = null } }; function Ca(e) { this._internalRoot = e } Ca.prototype.unstable_scheduleHydration = function (e) { if (e) { var n = Wg(); e = { blockedOn: null, target: e, priority: n }; for (var i = 0; i < Vn.length && n !== 0 && n < Vn[i].priority; i++); Vn.splice(i, 0, e), i === 0 && Kg(e) } }; function sd(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function ba(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function a0() { } function kT(e, n, i, a, c) { if (c) { if (typeof a == "function") { var p = a; a = function () { var _ = Sa(y); p.call(_) } } var y = o0(n, a, e, 0, null, !1, !1, "", a0); return e._reactRootContainer = y, e[pn] = y.current, di(e.nodeType === 8 ? e.parentNode : e), wr(), y } for (; c = e.lastChild;)e.removeChild(c); if (typeof a == "function") { var k = a; a = function () { var _ = Sa(A); k.call(_) } } var A = rd(e, 0, !1, null, null, !1, !1, "", a0); return e._reactRootContainer = A, e[pn] = A.current, di(e.nodeType === 8 ? e.parentNode : e), wr(function () { xa(n, A, i, a) }), A } function ka(e, n, i, a, c) { var p = i._reactRootContainer; if (p) { var y = p; if (typeof c == "function") { var k = c; c = function () { var A = Sa(y); k.call(A) } } xa(n, y, e, c) } else y = kT(i, n, e, c, a); return Sa(y) } Bg = function (e) { switch (e.tag) { case 3: var n = e.stateNode; if (n.current.memoizedState.isDehydrated) { var i = Qo(n.pendingLanes); i !== 0 && (Nu(n, i | 1), gt(n, Ue()), !(ke & 6) && (vo = Ue() + 500, $n())) } break; case 13: wr(function () { var a = vn(e, 1); if (a !== null) { var c = ct(); Ut(a, e, 1, c) } }), od(e, 1) } }, Mu = function (e) { if (e.tag === 13) { var n = vn(e, 134217728); if (n !== null) { var i = ct(); Ut(n, e, 134217728, i) } od(e, 134217728) } }, Ug = function (e) { if (e.tag === 13) { var n = Qn(e), i = vn(e, n); if (i !== null) { var a = ct(); Ut(i, e, n, a) } od(e, n) } }, Wg = function () { return Ee }, $g = function (e, n) { var i = Ee; try { return Ee = e, n() } finally { Ee = i } }, bu = function (e, n, i) { switch (n) { case "input": if (ur(e, i), n = i.name, i.type === "radio" && n != null) { for (i = e; i.parentNode;)i = i.parentNode; for (i = i.querySelectorAll("input[name=" + JSON.stringify("" + n) + '][type="radio"]'), n = 0; n < i.length; n++) { var a = i[n]; if (a !== e && a.form === e.form) { var c = Bs(a); if (!c) throw Error(o(90)); Re(a), ur(a, c) } } } break; case "textarea": wg(e, i); break; case "select": n = i.value, n != null && Gr(e, !!i.multiple, n, !1) } }, Rg = qc, Ag = wr; var PT = { usingClientEntryPoint: !1, Events: [hi, ro, Bs, Eg, Tg, qc] }, Ri = { findFiberByHostInstance: dr, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, ET = { bundleType: Ri.bundleType, version: Ri.version, rendererPackageName: Ri.rendererPackageName, rendererConfig: Ri.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: j.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = Dg(e), e === null ? null : e.stateNode }, findFiberByHostInstance: Ri.findFiberByHostInstance || bT, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Pa = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Pa.isDisabled && Pa.supportsFiber) try { Cs = Pa.inject(ET), Xt = Pa } catch { } } return dt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = PT, dt.createPortal = function (e, n) { var i = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!sd(n)) throw Error(o(200)); return CT(e, n, null, i) }, dt.createRoot = function (e, n) { if (!sd(e)) throw Error(o(299)); var i = !1, a = "", c = s0; return n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (a = n.identifierPrefix), n.onRecoverableError !== void 0 && (c = n.onRecoverableError)), n = rd(e, 1, !1, null, null, i, !1, a, c), e[pn] = n.current, di(e.nodeType === 8 ? e.parentNode : e), new id(n) }, dt.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var n = e._reactInternals; if (n === void 0) throw typeof e.render == "function" ? Error(o(188)) : (e = Object.keys(e).join(","), Error(o(268, e))); return e = Dg(n), e = e === null ? null : e.stateNode, e }, dt.flushSync = function (e) { return wr(e) }, dt.hydrate = function (e, n, i) { if (!ba(n)) throw Error(o(200)); return ka(null, e, n, !0, i) }, dt.hydrateRoot = function (e, n, i) { if (!sd(e)) throw Error(o(405)); var a = i != null && i.hydratedSources || null, c = !1, p = "", y = s0; if (i != null && (i.unstable_strictMode === !0 && (c = !0), i.identifierPrefix !== void 0 && (p = i.identifierPrefix), i.onRecoverableError !== void 0 && (y = i.onRecoverableError)), n = o0(n, null, e, 1, i ?? null, c, !1, p, y), e[pn] = n.current, di(e), a) for (e = 0; e < a.length; e++)i = a[e], c = i._getVersion, c = c(i._source), n.mutableSourceEagerHydrationData == null ? n.mutableSourceEagerHydrationData = [i, c] : n.mutableSourceEagerHydrationData.push(i, c); return new Ca(n) }, dt.render = function (e, n, i) { if (!ba(n)) throw Error(o(200)); return ka(null, e, n, !1, i) }, dt.unmountComponentAtNode = function (e) { if (!ba(e)) throw Error(o(40)); return e._reactRootContainer ? (wr(function () { ka(null, null, e, !1, function () { e._reactRootContainer = null, e[pn] = null }) }), !0) : !1 }, dt.unstable_batchedUpdates = qc, dt.unstable_renderSubtreeIntoContainer = function (e, n, i, a) { if (!ba(i)) throw Error(o(200)); if (e == null || e._reactInternals === void 0) throw Error(o(38)); return ka(e, n, i, !1, a) }, dt.version = "18.3.1-next-f1338f8080-20240426", dt
  } function md() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(md) } catch (t) { console.error(t) } } md(), dd.exports = p0(); var xo = dd.exports, gd = xo; Ra.createRoot = gd.createRoot, Ra.hydrateRoot = gd.hydrateRoot; var x = Ta(); const Sn = l0(x), h0 = Ai({ __proto__: null, default: Sn }, [x]);/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const m0 = t => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), vd = (...t) => t.filter((r, o, s) => !!r && s.indexOf(r) === o).join(" ");/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var g0 = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const v0 = x.forwardRef(({ color: t = "currentColor", size: r = 24, strokeWidth: o = 2, absoluteStrokeWidth: s, className: l = "", children: d, iconNode: u, ...f }, h) => x.createElement("svg", { ref: h, ...g0, width: r, height: r, stroke: t, strokeWidth: s ? Number(o) * 24 / Number(r) : o, className: vd("lucide", l), ...f }, [...u.map(([m, v]) => x.createElement(m, v)), ...Array.isArray(d) ? d : [d]]));/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const br = (t, r) => { const o = x.forwardRef(({ className: s, ...l }, d) => x.createElement(v0, { ref: d, iconNode: r, className: vd(`lucide-${m0(t)}`, s), ...l })); return o.displayName = `${t}`, o };/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const yd = br("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const wd = br("ChevronDown", [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]]);/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const y0 = br("ChevronLeft", [["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]]);/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const w0 = br("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const x0 = br("CircleAlert", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }], ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]]);/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const S0 = br("X", [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]]), Ma = x.createContext({ transformPagePoint: t => t, isStatic: !1, reducedMotion: "never" }), Ni = x.createContext({}), Mi = x.createContext(null), La = typeof window < "u", xd = La ? x.useLayoutEffect : x.useEffect, Sd = x.createContext({ strict: !1 }), Li = t => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), Cd = "data-" + Li("framerAppearId"), C0 = { skipAnimations: !1, useManualTiming: !1 }; function b0(t) { let r = new Set, o = new Set, s = !1, l = !1; const d = new WeakSet; let u = { delta: 0, timestamp: 0, isProcessing: !1 }; function f(m) { d.has(m) && (h.schedule(m), t()), m(u) } const h = { schedule: (m, v = !1, g = !1) => { const C = g && s ? r : o; return v && d.add(m), C.has(m) || C.add(m), m }, cancel: m => { o.delete(m), d.delete(m) }, process: m => { if (u = m, s) { l = !0; return } s = !0, [r, o] = [o, r], o.clear(), r.forEach(f), s = !1, l && (l = !1, h.process(m)) } }; return h } const Di = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"], k0 = 40; function bd(t, r) { let o = !1, s = !0; const l = { delta: 0, timestamp: 0, isProcessing: !1 }, d = () => o = !0, u = Di.reduce((R, N) => (R[N] = b0(d), R), {}), { read: f, resolveKeyframes: h, update: m, preRender: v, render: g, postRender: w } = u, C = () => { const R = performance.now(); o = !1, l.delta = s ? 1e3 / 60 : Math.max(Math.min(R - l.timestamp, k0), 1), l.timestamp = R, l.isProcessing = !0, f.process(l), h.process(l), m.process(l), v.process(l), g.process(l), w.process(l), l.isProcessing = !1, o && r && (s = !1, t(C)) }, b = () => { o = !0, s = !0, l.isProcessing || t(C) }; return { schedule: Di.reduce((R, N) => { const L = u[N]; return R[N] = (j, I = !1, K = !1) => (o || b(), L.schedule(j, I, K)), R }, {}), cancel: R => { for (let N = 0; N < Di.length; N++)u[Di[N]].cancel(R) }, state: l, steps: u } } const { schedule: Da, cancel: AT } = bd(queueMicrotask, !1); function kr(t) { return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current") } const kd = x.createContext({}); let Pd = !1; function P0(t, r, o, s, l) { var d; const { visualElement: u } = x.useContext(Ni), f = x.useContext(Sd), h = x.useContext(Mi), m = x.useContext(Ma).reducedMotion, v = x.useRef(); s = s || f.renderer, !v.current && s && (v.current = s(t, { visualState: r, parent: u, props: o, presenceContext: h, blockInitialAnimation: h ? h.initial === !1 : !1, reducedMotionConfig: m })); const g = v.current, w = x.useContext(kd); g && !g.projection && l && (g.type === "html" || g.type === "svg") && T0(v.current, o, l, w), x.useInsertionEffect(() => { g && g.update(o, h) }); const C = o[Cd], b = x.useRef(!!C && !window.MotionHandoffIsComplete && ((d = window.MotionHasOptimisedAnimation) === null || d === void 0 ? void 0 : d.call(window, C))); return xd(() => { g && (g.updateFeatures(), Da.render(g.render), b.current && g.animationState && g.animationState.animateChanges()) }), x.useEffect(() => { g && (!b.current && g.animationState && g.animationState.animateChanges(), b.current = !1, Pd || (Pd = !0, queueMicrotask(E0))) }), g } function E0() { window.MotionHandoffIsComplete = !0 } function T0(t, r, o, s) { const { layoutId: l, layout: d, drag: u, dragConstraints: f, layoutScroll: h, layoutRoot: m } = r; t.projection = new o(t.latestValues, r["data-framer-portal-id"] ? void 0 : Ed(t.parent)), t.projection.setOptions({ layoutId: l, layout: d, alwaysMeasureLayout: !!u || f && kr(f), visualElement: t, animationType: typeof d == "string" ? d : "both", initialPromotionConfig: s, layoutScroll: h, layoutRoot: m }) } function Ed(t) { if (t) return t.options.allowProjection !== !1 ? t.projection : Ed(t.parent) } function R0(t, r, o) { return x.useCallback(s => { s && t.mount && t.mount(s), r && (s ? r.mount(s) : r.unmount()), o && (typeof o == "function" ? o(s) : kr(o) && (o.current = s)) }, [r]) } function So(t) { return typeof t == "string" || Array.isArray(t) } function Co(t) { return t !== null && typeof t == "object" && typeof t.start == "function" } const ja = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], Oa = ["initial", ...ja]; function ji(t) { return Co(t.animate) || Oa.some(r => So(t[r])) } function Td(t) { return !!(ji(t) || t.variants) } function A0(t, r) { if (ji(t)) { const { initial: o, animate: s } = t; return { initial: o === !1 || So(o) ? o : void 0, animate: So(s) ? s : void 0 } } return t.inherit !== !1 ? r : {} } function N0(t) { const { initial: r, animate: o } = A0(t, x.useContext(Ni)); return x.useMemo(() => ({ initial: r, animate: o }), [Rd(r), Rd(o)]) } function Rd(t) { return Array.isArray(t) ? t.join(" ") : t } const Ad = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, Pr = {}; for (const t in Ad) Pr[t] = { isEnabled: r => Ad[t].some(o => !!r[o]) }; function M0(t) { for (const r in t) Pr[r] = { ...Pr[r], ...t[r] } } const _a = x.createContext({}), L0 = Symbol.for("motionComponentSymbol"), qe = t => t; let D0 = qe, Nd = qe; function j0({ preloadedFeatures: t, createVisualElement: r, useRender: o, useVisualState: s, Component: l }) { t && M0(t); function d(f, h) { let m; const v = { ...x.useContext(Ma), ...f, layoutId: O0(f) }, { isStatic: g } = v, w = N0(f), C = s(f, g); if (!g && La) { _0(); const b = I0(v); m = b.MeasureLayout, w.visualElement = P0(l, C, v, r, b.ProjectionNode) } return T.jsxs(Ni.Provider, { value: w, children: [m && w.visualElement ? T.jsx(m, { visualElement: w.visualElement, ...v }) : null, o(l, f, R0(C, w.visualElement, h), C, g, w.visualElement)] }) } const u = x.forwardRef(d); return u[L0] = l, u } function O0({ layoutId: t }) { const r = x.useContext(_a).id; return r && t !== void 0 ? r + "-" + t : t } function _0(t, r) { x.useContext(Sd).strict } function I0(t) { const { drag: r, layout: o } = Pr; if (!r && !o) return {}; const s = { ...r, ...o }; return { MeasureLayout: r?.isEnabled(t) || o?.isEnabled(t) ? s.MeasureLayout : void 0, ProjectionNode: s.ProjectionNode } } function V0(t) { function r(s, l = {}) { return j0(t(s, l)) } if (typeof Proxy > "u") return r; const o = new Map; return new Proxy(r, { get: (s, l) => (o.has(l) || o.set(l, r(l)), o.get(l)) }) } const F0 = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function Ia(t) { return typeof t != "string" || t.includes("-") ? !1 : !!(F0.indexOf(t) > -1 || /[A-Z]/u.test(t)) } const Oi = {}; function z0(t) { Object.assign(Oi, t) } const bo = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], Cn = new Set(bo); function Md(t, { layout: r, layoutId: o }) { return Cn.has(t) || t.startsWith("origin") || (r || o !== void 0) && (!!Oi[t] || t === "opacity") } const nt = t => !!(t && t.getVelocity), Ld = (t, r) => r && typeof t == "number" ? r.transform(t) : t, bn = (t, r, o) => o > r ? r : o < t ? t : o, Er = { test: t => typeof t == "number", parse: parseFloat, transform: t => t }, ko = { ...Er, transform: t => bn(0, 1, t) }, _i = { ...Er, default: 1 }, Po = t => Math.round(t * 1e5) / 1e5, Va = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu, B0 = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu, U0 = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu; function Eo(t) { return typeof t == "string" } function W0(t) { return t == null } const To = t => ({ test: r => Eo(r) && r.endsWith(t) && r.split(" ").length === 1, parse: parseFloat, transform: r => `${r}${t}` }), kn = To("deg"), Wt = To("%"), pe = To("px"), $0 = To("vh"), H0 = To("vw"), Dd = { ...Wt, parse: t => Wt.parse(t) / 100, transform: t => Wt.transform(t * 100) }, jd = { ...Er, transform: Math.round }, Fa = { borderWidth: pe, borderTopWidth: pe, borderRightWidth: pe, borderBottomWidth: pe, borderLeftWidth: pe, borderRadius: pe, radius: pe, borderTopLeftRadius: pe, borderTopRightRadius: pe, borderBottomRightRadius: pe, borderBottomLeftRadius: pe, width: pe, maxWidth: pe, height: pe, maxHeight: pe, size: pe, top: pe, right: pe, bottom: pe, left: pe, padding: pe, paddingTop: pe, paddingRight: pe, paddingBottom: pe, paddingLeft: pe, margin: pe, marginTop: pe, marginRight: pe, marginBottom: pe, marginLeft: pe, rotate: kn, rotateX: kn, rotateY: kn, rotateZ: kn, scale: _i, scaleX: _i, scaleY: _i, scaleZ: _i, skew: kn, skewX: kn, skewY: kn, distance: pe, translateX: pe, translateY: pe, translateZ: pe, x: pe, y: pe, z: pe, perspective: pe, transformPerspective: pe, opacity: ko, originX: Dd, originY: Dd, originZ: pe, zIndex: jd, backgroundPositionX: pe, backgroundPositionY: pe, fillOpacity: ko, strokeOpacity: ko, numOctaves: jd }, K0 = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, G0 = bo.length; function Y0(t, r, o) { let s = "", l = !0; for (let d = 0; d < G0; d++) { const u = bo[d], f = t[u]; if (f === void 0) continue; let h = !0; if (typeof f == "number" ? h = f === (u.startsWith("scale") ? 1 : 0) : h = parseFloat(f) === 0, !h || o) { const m = Ld(f, Fa[u]); if (!h) { l = !1; const v = K0[u] || u; s += `${v}(${m}) ` } o && (r[u] = m) } } return s = s.trim(), o ? s = o(r, l ? "" : s) : l && (s = "none"), s } const Od = t => r => typeof r == "string" && r.startsWith(t), _d = Od("--"), X0 = Od("var(--"), za = t => X0(t) ? Q0.test(t.split("/*")[0].trim()) : !1, Q0 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu; function Ba(t, r, o) { const { style: s, vars: l, transformOrigin: d } = t; let u = !1, f = !1; for (const h in r) { const m = r[h]; if (Cn.has(h)) { u = !0; continue } else if (_d(h)) { l[h] = m; continue } else { const v = Ld(m, Fa[h]); h.startsWith("origin") ? (f = !0, d[h] = v) : s[h] = v } } if (r.transform || (u || o ? s.transform = Y0(r, t.transform, o) : s.transform && (s.transform = "none")), f) { const { originX: h = "50%", originY: m = "50%", originZ: v = 0 } = d; s.transformOrigin = `${h} ${m} ${v}` } } const Ua = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function Id(t, r, o) { for (const s in r) !nt(r[s]) && !Md(s, o) && (t[s] = r[s]) } function q0({ transformTemplate: t }, r) { return x.useMemo(() => { const o = Ua(); return Ba(o, r, t), Object.assign({}, o.vars, o.style) }, [r]) } function Z0(t, r) { const o = t.style || {}, s = {}; return Id(s, o, t), Object.assign(s, q0(t, r)), s } function J0(t, r) { const o = {}, s = Z0(t, r); return t.drag && t.dragListener !== !1 && (o.draggable = !1, s.userSelect = s.WebkitUserSelect = s.WebkitTouchCallout = "none", s.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (o.tabIndex = 0), o.style = s, o } const ew = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function Ii(t) { return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || ew.has(t) } let Vd = t => !Ii(t); function tw(t) { t && (Vd = r => r.startsWith("on") ? !Ii(r) : t(r)) } try { tw(require("@emotion/is-prop-valid").default) } catch { } function nw(t, r, o) { const s = {}; for (const l in t) l === "values" && typeof t.values == "object" || (Vd(l) || o === !0 && Ii(l) || !r && !Ii(l) || t.draggable && l.startsWith("onDrag")) && (s[l] = t[l]); return s } function Fd(t, r, o) { return typeof t == "string" ? t : pe.transform(r + o * t) } function rw(t, r, o) { const s = Fd(r, t.x, t.width), l = Fd(o, t.y, t.height); return `${s} ${l}` } const ow = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, iw = { offset: "strokeDashoffset", array: "strokeDasharray" }; function sw(t, r, o = 1, s = 0, l = !0) { t.pathLength = 1; const d = l ? ow : iw; t[d.offset] = pe.transform(-s); const u = pe.transform(r), f = pe.transform(o); t[d.array] = `${u} ${f}` } function Wa(t, { attrX: r, attrY: o, attrScale: s, originX: l, originY: d, pathLength: u, pathSpacing: f = 1, pathOffset: h = 0, ...m }, v, g) { if (Ba(t, m, g), v) { t.style.viewBox && (t.attrs.viewBox = t.style.viewBox); return } t.attrs = t.style, t.style = {}; const { attrs: w, style: C, dimensions: b } = t; w.transform && (b && (C.transform = w.transform), delete w.transform), b && (l !== void 0 || d !== void 0 || C.transform) && (C.transformOrigin = rw(b, l !== void 0 ? l : .5, d !== void 0 ? d : .5)), r !== void 0 && (w.x = r), o !== void 0 && (w.y = o), s !== void 0 && (w.scale = s), u !== void 0 && sw(w, u, f, h, !1) } const zd = () => ({ ...Ua(), attrs: {} }), $a = t => typeof t == "string" && t.toLowerCase() === "svg"; function aw(t, r, o, s) { const l = x.useMemo(() => { const d = zd(); return Wa(d, r, $a(s), t.transformTemplate), { ...d.attrs, style: { ...d.style } } }, [r]); if (t.style) { const d = {}; Id(d, t.style, t), l.style = { ...d, ...l.style } } return l } function lw(t = !1) { return (o, s, l, { latestValues: d }, u) => { const h = (Ia(o) ? aw : J0)(s, d, u, o), m = nw(s, typeof o == "string", t), v = o !== x.Fragment ? { ...m, ...h, ref: l } : {}, { children: g } = s, w = x.useMemo(() => nt(g) ? g.get() : g, [g]); return x.createElement(o, { ...v, children: w }) } } function Bd(t, { style: r, vars: o }, s, l) { Object.assign(t.style, r, l && l.getProjectionStyles(s)); for (const d in o) t.style.setProperty(d, o[d]) } const Ud = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function Wd(t, r, o, s) { Bd(t, r, void 0, s); for (const l in r.attrs) t.setAttribute(Ud.has(l) ? l : Li(l), r.attrs[l]) } function Ha(t, r, o) { var s; const { style: l } = t, d = {}; for (const u in l) (nt(l[u]) || r.style && nt(r.style[u]) || Md(u, t) || ((s = o?.getValue(u)) === null || s === void 0 ? void 0 : s.liveStyle) !== void 0) && (d[u] = l[u]); return o && l && typeof l.willChange == "string" && (o.applyWillChange = !1), d } function $d(t, r, o) { const s = Ha(t, r, o); for (const l in t) if (nt(t[l]) || nt(r[l])) { const d = bo.indexOf(l) !== -1 ? "attr" + l.charAt(0).toUpperCase() + l.substring(1) : l; s[d] = t[l] } return s } function Hd(t) { const r = [{}, {}]; return t?.values.forEach((o, s) => { r[0][s] = o.get(), r[1][s] = o.getVelocity() }), r } function Ka(t, r, o, s) { if (typeof r == "function") { const [l, d] = Hd(s); r = r(o !== void 0 ? o : t.custom, l, d) } if (typeof r == "string" && (r = t.variants && t.variants[r]), typeof r == "function") { const [l, d] = Hd(s); r = r(o !== void 0 ? o : t.custom, l, d) } return r } function Ga(t) { const r = x.useRef(null); return r.current === null && (r.current = t()), r.current } const Ya = t => Array.isArray(t), uw = t => !!(t && typeof t == "object" && t.mix && t.toValue), cw = t => Ya(t) ? t[t.length - 1] || 0 : t; function Vi(t) { const r = nt(t) ? t.get() : t; return uw(r) ? r.toValue() : r } const Kd = new Set(["opacity", "clipPath", "filter", "transform"]); function Gd(t) { if (Cn.has(t)) return "transform"; if (Kd.has(t)) return Li(t) } function Fi(t, r) { t.indexOf(r) === -1 && t.push(r) } function zi(t, r) { const o = t.indexOf(r); o > -1 && t.splice(o, 1) } function dw({ applyWillChange: t = !1, scrapeMotionValuesFromProps: r, createRenderState: o, onMount: s }, l, d, u, f) { const h = { latestValues: pw(l, d, u, f ? !1 : t, r), renderState: o() }; return s && (h.mount = m => s(l, m, h)), h } const Yd = t => (r, o) => { const s = x.useContext(Ni), l = x.useContext(Mi), d = () => dw(t, r, s, l, o); return o ? d() : Ga(d) }; function fw(t, r) { const o = Gd(r); o && Fi(t, o) } function Xd(t, r, o) { const s = Array.isArray(r) ? r : [r]; for (let l = 0; l < s.length; l++) { const d = Ka(t, s[l]); if (d) { const { transitionEnd: u, transition: f, ...h } = d; o(h, u) } } } function pw(t, r, o, s, l) { var d; const u = {}, f = [], h = s && ((d = t.style) === null || d === void 0 ? void 0 : d.willChange) === void 0, m = l(t, {}); for (const P in m) u[P] = Vi(m[P]); let { initial: v, animate: g } = t; const w = ji(t), C = Td(t); r && C && !w && t.inherit !== !1 && (v === void 0 && (v = r.initial), g === void 0 && (g = r.animate)); let b = o ? o.initial === !1 : !1; b = b || v === !1; const S = b ? g : v; return S && typeof S != "boolean" && !Co(S) && Xd(t, S, (P, R) => { for (const N in P) { let L = P[N]; if (Array.isArray(L)) { const j = b ? L.length - 1 : 0; L = L[j] } L !== null && (u[N] = L) } for (const N in R) u[N] = R[N] }), h && (g && v !== !1 && !Co(g) && Xd(t, g, P => { for (const R in P) fw(f, R) }), f.length && (u.willChange = f.join(","))), u } const { schedule: Te, cancel: en, state: Ze, steps: Xa } = bd(typeof requestAnimationFrame < "u" ? requestAnimationFrame : qe, !0), hw = { useVisualState: Yd({ scrapeMotionValuesFromProps: $d, createRenderState: zd, onMount: (t, r, { renderState: o, latestValues: s }) => { Te.read(() => { try { o.dimensions = typeof r.getBBox == "function" ? r.getBBox() : r.getBoundingClientRect() } catch { o.dimensions = { x: 0, y: 0, width: 0, height: 0 } } }), Te.render(() => { Wa(o, s, $a(r.tagName), t.transformTemplate), Wd(r, o) }) } }) }, mw = { useVisualState: Yd({ applyWillChange: !0, scrapeMotionValuesFromProps: Ha, createRenderState: Ua }) }; function gw(t, { forwardMotionProps: r = !1 }, o, s) { return { ...Ia(t) ? hw : mw, preloadedFeatures: o, useRender: lw(r), createVisualElement: s, Component: t } } function tn(t, r, o, s = { passive: !0 }) { return t.addEventListener(r, o, s), () => t.removeEventListener(r, o) } const Qd = t => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1; function Bi(t, r = "page") { return { point: { x: t[`${r}X`], y: t[`${r}Y`] } } } const vw = t => r => Qd(r) && t(r, Bi(r)); function nn(t, r, o, s) { return tn(t, r, vw(o), s) } const yw = (t, r) => o => r(t(o)), rn = (...t) => t.reduce(yw); function qd(t) { let r = null; return () => { const o = () => { r = null }; return r === null ? (r = t, o) : !1 } } const Zd = qd("dragHorizontal"), Jd = qd("dragVertical"); function ef(t) { let r = !1; if (t === "y") r = Jd(); else if (t === "x") r = Zd(); else { const o = Zd(), s = Jd(); o && s ? r = () => { o(), s() } : (o && o(), s && s()) } return r } function tf() { const t = ef(!0); return t ? (t(), !1) : !0 } class Pn { constructor(r) { this.isMounted = !1, this.node = r } update() { } } function nf(t, r) { const o = r ? "pointerenter" : "pointerleave", s = r ? "onHoverStart" : "onHoverEnd", l = (d, u) => { if (d.pointerType === "touch" || tf()) return; const f = t.getProps(); t.animationState && f.whileHover && t.animationState.setActive("whileHover", r); const h = f[s]; h && Te.postRender(() => h(d, u)) }; return nn(t.current, o, l, { passive: !t.getProps()[s] }) } class ww extends Pn { mount() { this.unmount = rn(nf(this.node, !0), nf(this.node, !1)) } unmount() { } } class xw extends Pn { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let r = !1; try { r = this.node.current.matches(":focus-visible") } catch { r = !0 } !r || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = rn(tn(this.node.current, "focus", () => this.onFocus()), tn(this.node.current, "blur", () => this.onBlur())) } unmount() { } } const rf = (t, r) => r ? t === r ? !0 : rf(t, r.parentElement) : !1; function Qa(t, r) { if (!r) return; const o = new PointerEvent("pointer" + t); r(o, Bi(o)) } class Sw extends Pn { constructor() { super(...arguments), this.removeStartListeners = qe, this.removeEndListeners = qe, this.removeAccessibleListeners = qe, this.startPointerPress = (r, o) => { if (this.isPressing) return; this.removeEndListeners(); const s = this.node.getProps(), d = nn(window, "pointerup", (f, h) => { if (!this.checkPressEnd()) return; const { onTap: m, onTapCancel: v, globalTapTarget: g } = this.node.getProps(), w = !g && !rf(this.node.current, f.target) ? v : m; w && Te.update(() => w(f, h)) }, { passive: !(s.onTap || s.onPointerUp) }), u = nn(window, "pointercancel", (f, h) => this.cancelPress(f, h), { passive: !(s.onTapCancel || s.onPointerCancel) }); this.removeEndListeners = rn(d, u), this.startPress(r, o) }, this.startAccessiblePress = () => { const r = d => { if (d.key !== "Enter" || this.isPressing) return; const u = f => { f.key !== "Enter" || !this.checkPressEnd() || Qa("up", (h, m) => { const { onTap: v } = this.node.getProps(); v && Te.postRender(() => v(h, m)) }) }; this.removeEndListeners(), this.removeEndListeners = tn(this.node.current, "keyup", u), Qa("down", (f, h) => { this.startPress(f, h) }) }, o = tn(this.node.current, "keydown", r), s = () => { this.isPressing && Qa("cancel", (d, u) => this.cancelPress(d, u)) }, l = tn(this.node.current, "blur", s); this.removeAccessibleListeners = rn(o, l) } } startPress(r, o) { this.isPressing = !0; const { onTapStart: s, whileTap: l } = this.node.getProps(); l && this.node.animationState && this.node.animationState.setActive("whileTap", !0), s && Te.postRender(() => s(r, o)) } checkPressEnd() { return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !tf() } cancelPress(r, o) { if (!this.checkPressEnd()) return; const { onTapCancel: s } = this.node.getProps(); s && Te.postRender(() => s(r, o)) } mount() { const r = this.node.getProps(), o = nn(r.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(r.onTapStart || r.onPointerStart) }), s = tn(this.node.current, "focus", this.startAccessiblePress); this.removeStartListeners = rn(o, s) } unmount() { this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners() } } const qa = new WeakMap, Za = new WeakMap, Cw = t => { const r = qa.get(t.target); r && r(t) }, bw = t => { t.forEach(Cw) }; function kw({ root: t, ...r }) { const o = t || document; Za.has(o) || Za.set(o, {}); const s = Za.get(o), l = JSON.stringify(r); return s[l] || (s[l] = new IntersectionObserver(bw, { root: t, ...r })), s[l] } function Pw(t, r, o) { const s = kw(r); return qa.set(t, o), s.observe(t), () => { qa.delete(t), s.unobserve(t) } } const Ew = { some: 0, all: 1 }; class Tw extends Pn { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: r = {} } = this.node.getProps(), { root: o, margin: s, amount: l = "some", once: d } = r, u = { root: o ? o.current : void 0, rootMargin: s, threshold: typeof l == "number" ? l : Ew[l] }, f = h => { const { isIntersecting: m } = h; if (this.isInView === m || (this.isInView = m, d && !m && this.hasEnteredView)) return; m && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", m); const { onViewportEnter: v, onViewportLeave: g } = this.node.getProps(), w = m ? v : g; w && w(h) }; return Pw(this.node.current, u, f) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: r, prevProps: o } = this.node;["amount", "margin", "root"].some(Rw(r, o)) && this.startObserver() } unmount() { } } function Rw({ viewport: t = {} }, { viewport: r = {} } = {}) { return o => t[o] !== r[o] } const Aw = { inView: { Feature: Tw }, tap: { Feature: Sw }, focus: { Feature: xw }, hover: { Feature: ww } }; function of(t, r) { if (!Array.isArray(r)) return !1; const o = r.length; if (o !== t.length) return !1; for (let s = 0; s < o; s++)if (r[s] !== t[s]) return !1; return !0 } function Ui(t, r, o) { const s = t.getProps(); return Ka(s, r, o !== void 0 ? o : s.custom, t) } const $t = t => t * 1e3, on = t => t / 1e3, Nw = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, Mw = t => ({ type: "spring", stiffness: 550, damping: t === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), Lw = { type: "keyframes", duration: .8 }, Dw = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, jw = (t, { keyframes: r }) => r.length > 2 ? Lw : Cn.has(t) ? t.startsWith("scale") ? Mw(r[1]) : Nw : Dw; function Ow({ when: t, delay: r, delayChildren: o, staggerChildren: s, staggerDirection: l, repeat: d, repeatType: u, repeatDelay: f, from: h, elapsed: m, ...v }) { return !!Object.keys(v).length } function Ja(t, r) { return t[r] || t.default || t } const _w = t => t !== null; function Wi(t, { repeat: r, repeatType: o = "loop" }, s) { const l = t.filter(_w), d = r && o !== "loop" && r % 2 === 1 ? 0 : l.length - 1; return !d || s === void 0 ? l[d] : s } const sf = t => /^0[^.\s]+$/u.test(t); function Iw(t) { return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || sf(t) : !0 } const af = t => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t), Vw = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function Fw(t) { const r = Vw.exec(t); if (!r) return [,]; const [, o, s, l] = r; return [`--${o ?? s}`, l] } function lf(t, r, o = 1) { const [s, l] = Fw(t); if (!s) return; const d = window.getComputedStyle(r).getPropertyValue(s); if (d) { const u = d.trim(); return af(u) ? parseFloat(u) : u } return za(l) ? lf(l, r, o + 1) : l } const zw = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]), uf = t => t === Er || t === pe, cf = (t, r) => parseFloat(t.split(", ")[r]), df = (t, r) => (o, { transform: s }) => { if (s === "none" || !s) return 0; const l = s.match(/^matrix3d\((.+)\)$/u); if (l) return cf(l[1], r); { const d = s.match(/^matrix\((.+)\)$/u); return d ? cf(d[1], t) : 0 } }, Bw = new Set(["x", "y", "z"]), Uw = bo.filter(t => !Bw.has(t)); function Ww(t) { const r = []; return Uw.forEach(o => { const s = t.getValue(o); s !== void 0 && (r.push([o, s.get()]), s.set(o.startsWith("scale") ? 1 : 0)) }), r } const Tr = { width: ({ x: t }, { paddingLeft: r = "0", paddingRight: o = "0" }) => t.max - t.min - parseFloat(r) - parseFloat(o), height: ({ y: t }, { paddingTop: r = "0", paddingBottom: o = "0" }) => t.max - t.min - parseFloat(r) - parseFloat(o), top: (t, { top: r }) => parseFloat(r), left: (t, { left: r }) => parseFloat(r), bottom: ({ y: t }, { top: r }) => parseFloat(r) + (t.max - t.min), right: ({ x: t }, { left: r }) => parseFloat(r) + (t.max - t.min), x: df(4, 13), y: df(5, 14) }; Tr.translateX = Tr.x, Tr.translateY = Tr.y; const ff = t => r => r.test(t), pf = [Er, pe, Wt, kn, H0, $0, { test: t => t === "auto", parse: t => t }], hf = t => pf.find(ff(t)), er = new Set; let el = !1, tl = !1; function mf() { if (tl) { const t = Array.from(er).filter(s => s.needsMeasurement), r = new Set(t.map(s => s.element)), o = new Map; r.forEach(s => { const l = Ww(s); l.length && (o.set(s, l), s.render()) }), t.forEach(s => s.measureInitialState()), r.forEach(s => { s.render(); const l = o.get(s); l && l.forEach(([d, u]) => { var f; (f = s.getValue(d)) === null || f === void 0 || f.set(u) }) }), t.forEach(s => s.measureEndState()), t.forEach(s => { s.suspendedScrollY !== void 0 && window.scrollTo(0, s.suspendedScrollY) }) } tl = !1, el = !1, er.forEach(t => t.complete()), er.clear() } function gf() { er.forEach(t => { t.readKeyframes(), t.needsMeasurement && (tl = !0) }) } function $w() { gf(), mf() } class nl { constructor(r, o, s, l, d, u = !1) { this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...r], this.onComplete = o, this.name = s, this.motionValue = l, this.element = d, this.isAsync = u } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (er.add(this), el || (el = !0, Te.read(gf), Te.resolveKeyframes(mf))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: r, name: o, element: s, motionValue: l } = this; for (let d = 0; d < r.length; d++)if (r[d] === null) if (d === 0) { const u = l?.get(), f = r[r.length - 1]; if (u !== void 0) r[0] = u; else if (s && o) { const h = s.readValue(o, f); h != null && (r[0] = h) } r[0] === void 0 && (r[0] = f), l && u === void 0 && l.set(r[0]) } else r[d] = r[d - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), er.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, er.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } } const rl = (t, r) => o => !!(Eo(o) && U0.test(o) && o.startsWith(t) || r && !W0(o) && Object.prototype.hasOwnProperty.call(o, r)), vf = (t, r, o) => s => { if (!Eo(s)) return s; const [l, d, u, f] = s.match(Va); return { [t]: parseFloat(l), [r]: parseFloat(d), [o]: parseFloat(u), alpha: f !== void 0 ? parseFloat(f) : 1 } }, Hw = t => bn(0, 255, t), ol = { ...Er, transform: t => Math.round(Hw(t)) }, tr = { test: rl("rgb", "red"), parse: vf("red", "green", "blue"), transform: ({ red: t, green: r, blue: o, alpha: s = 1 }) => "rgba(" + ol.transform(t) + ", " + ol.transform(r) + ", " + ol.transform(o) + ", " + Po(ko.transform(s)) + ")" }; function Kw(t) { let r = "", o = "", s = "", l = ""; return t.length > 5 ? (r = t.substring(1, 3), o = t.substring(3, 5), s = t.substring(5, 7), l = t.substring(7, 9)) : (r = t.substring(1, 2), o = t.substring(2, 3), s = t.substring(3, 4), l = t.substring(4, 5), r += r, o += o, s += s, l += l), { red: parseInt(r, 16), green: parseInt(o, 16), blue: parseInt(s, 16), alpha: l ? parseInt(l, 16) / 255 : 1 } } const il = { test: rl("#"), parse: Kw, transform: tr.transform }, Rr = { test: rl("hsl", "hue"), parse: vf("hue", "saturation", "lightness"), transform: ({ hue: t, saturation: r, lightness: o, alpha: s = 1 }) => "hsla(" + Math.round(t) + ", " + Wt.transform(Po(r)) + ", " + Wt.transform(Po(o)) + ", " + Po(ko.transform(s)) + ")" }, rt = { test: t => tr.test(t) || il.test(t) || Rr.test(t), parse: t => tr.test(t) ? tr.parse(t) : Rr.test(t) ? Rr.parse(t) : il.parse(t), transform: t => Eo(t) ? t : t.hasOwnProperty("red") ? tr.transform(t) : Rr.transform(t) }; function Gw(t) { var r, o; return isNaN(t) && Eo(t) && (((r = t.match(Va)) === null || r === void 0 ? void 0 : r.length) || 0) + (((o = t.match(B0)) === null || o === void 0 ? void 0 : o.length) || 0) > 0 } const yf = "number", wf = "color", Yw = "var", Xw = "var(", xf = "${}", Qw = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function Ro(t) { const r = t.toString(), o = [], s = { color: [], number: [], var: [] }, l = []; let d = 0; const f = r.replace(Qw, h => (rt.test(h) ? (s.color.push(d), l.push(wf), o.push(rt.parse(h))) : h.startsWith(Xw) ? (s.var.push(d), l.push(Yw), o.push(h)) : (s.number.push(d), l.push(yf), o.push(parseFloat(h))), ++d, xf)).split(xf); return { values: o, split: f, indexes: s, types: l } } function Sf(t) { return Ro(t).values } function Cf(t) { const { split: r, types: o } = Ro(t), s = r.length; return l => { let d = ""; for (let u = 0; u < s; u++)if (d += r[u], l[u] !== void 0) { const f = o[u]; f === yf ? d += Po(l[u]) : f === wf ? d += rt.transform(l[u]) : d += l[u] } return d } } const qw = t => typeof t == "number" ? 0 : t; function Zw(t) { const r = Sf(t); return Cf(t)(r.map(qw)) } const En = { test: Gw, parse: Sf, createTransformer: Cf, getAnimatableNone: Zw }, Jw = new Set(["brightness", "contrast", "saturate", "opacity"]); function ex(t) { const [r, o] = t.slice(0, -1).split("("); if (r === "drop-shadow") return t; const [s] = o.match(Va) || []; if (!s) return t; const l = o.replace(s, ""); let d = Jw.has(r) ? 1 : 0; return s !== o && (d *= 100), r + "(" + d + l + ")" } const tx = /\b([a-z-]*)\(.*?\)/gu, sl = { ...En, getAnimatableNone: t => { const r = t.match(tx); return r ? r.map(ex).join(" ") : t } }, nx = { ...Fa, color: rt, backgroundColor: rt, outlineColor: rt, fill: rt, stroke: rt, borderColor: rt, borderTopColor: rt, borderRightColor: rt, borderBottomColor: rt, borderLeftColor: rt, filter: sl, WebkitFilter: sl }, al = t => nx[t]; function bf(t, r) { let o = al(t); return o !== sl && (o = En), o.getAnimatableNone ? o.getAnimatableNone(r) : void 0 } const rx = new Set(["auto", "none", "0"]); function ox(t, r, o) { let s = 0, l; for (; s < t.length && !l;) { const d = t[s]; typeof d == "string" && !rx.has(d) && Ro(d).values.length && (l = t[s]), s++ } if (l && o) for (const d of r) t[d] = bf(o, l) } class kf extends nl { constructor(r, o, s, l, d) { super(r, o, s, l, d, !0) } readKeyframes() { const { unresolvedKeyframes: r, element: o, name: s } = this; if (!o || !o.current) return; super.readKeyframes(); for (let h = 0; h < r.length; h++) { let m = r[h]; if (typeof m == "string" && (m = m.trim(), za(m))) { const v = lf(m, o.current); v !== void 0 && (r[h] = v), h === r.length - 1 && (this.finalKeyframe = m) } } if (this.resolveNoneKeyframes(), !zw.has(s) || r.length !== 2) return; const [l, d] = r, u = hf(l), f = hf(d); if (u !== f) if (uf(u) && uf(f)) for (let h = 0; h < r.length; h++) { const m = r[h]; typeof m == "string" && (r[h] = parseFloat(m)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { const { unresolvedKeyframes: r, name: o } = this, s = []; for (let l = 0; l < r.length; l++)Iw(r[l]) && s.push(l); s.length && ox(r, s, o) } measureInitialState() { const { element: r, unresolvedKeyframes: o, name: s } = this; if (!r || !r.current) return; s === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Tr[s](r.measureViewportBox(), window.getComputedStyle(r.current)), o[0] = this.measuredOrigin; const l = o[o.length - 1]; l !== void 0 && r.getValue(s, l).jump(l, !1) } measureEndState() { var r; const { element: o, name: s, unresolvedKeyframes: l } = this; if (!o || !o.current) return; const d = o.getValue(s); d && d.jump(this.measuredOrigin, !1); const u = l.length - 1, f = l[u]; l[u] = Tr[s](o.measureViewportBox(), window.getComputedStyle(o.current)), f !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = f), !((r = this.removedTransforms) === null || r === void 0) && r.length && this.removedTransforms.forEach(([h, m]) => { o.getValue(h).set(m) }), this.resolveNoneKeyframes() } } function Pf(t) { let r; return () => (r === void 0 && (r = t()), r) } let $i; function ix() { $i = void 0 } const sn = { now: () => ($i === void 0 && sn.set(Ze.isProcessing || C0.useManualTiming ? Ze.timestamp : performance.now()), $i), set: t => { $i = t, queueMicrotask(ix) } }, Ef = (t, r) => r === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && (En.test(t) || t === "0") && !t.startsWith("url(")); function sx(t) { const r = t[0]; if (t.length === 1) return !0; for (let o = 0; o < t.length; o++)if (t[o] !== r) return !0 } function ax(t, r, o, s) { const l = t[0]; if (l === null) return !1; if (r === "display" || r === "visibility") return !0; const d = t[t.length - 1], u = Ef(l, r), f = Ef(d, r); return !u || !f ? !1 : sx(t) || o === "spring" && s } const lx = 40; class Tf { constructor({ autoplay: r = !0, delay: o = 0, type: s = "keyframes", repeat: l = 0, repeatDelay: d = 0, repeatType: u = "loop", ...f }) { this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = sn.now(), this.options = { autoplay: r, delay: o, type: s, repeat: l, repeatDelay: d, repeatType: u, ...f }, this.updateFinishedPromise() } calcStartTime() { return this.resolvedAt ? this.resolvedAt - this.createdAt > lx ? this.resolvedAt : this.createdAt : this.createdAt } get resolved() { return !this._resolved && !this.hasAttemptedResolve && $w(), this._resolved } onKeyframesResolved(r, o) { this.resolvedAt = sn.now(), this.hasAttemptedResolve = !0; const { name: s, type: l, velocity: d, delay: u, onComplete: f, onUpdate: h, isGenerator: m } = this.options; if (!m && !ax(r, s, l, d)) if (u) this.options.duration = 0; else { h?.(Wi(r, this.options, o)), f?.(), this.resolveFinishedPromise(); return } const v = this.initPlayback(r, o); v !== !1 && (this._resolved = { keyframes: r, finalKeyframe: o, ...v }, this.onPostResolved()) } onPostResolved() { } then(r, o) { return this.currentFinishedPromise.then(r, o) } updateFinishedPromise() { this.currentFinishedPromise = new Promise(r => { this.resolveFinishedPromise = r }) } } function Rf(t, r) { return r ? t * (1e3 / r) : 0 } const ux = 5; function Af(t, r, o) { const s = Math.max(r - ux, 0); return Rf(o - t(s), r - s) } const ll = .001, cx = .01, Nf = 10, dx = .05, fx = 1; function px({ duration: t = 800, bounce: r = .25, velocity: o = 0, mass: s = 1 }) { let l, d; D0(t <= $t(Nf)); let u = 1 - r; u = bn(dx, fx, u), t = bn(cx, Nf, on(t)), u < 1 ? (l = m => { const v = m * u, g = v * t, w = v - o, C = ul(m, u), b = Math.exp(-g); return ll - w / C * b }, d = m => { const g = m * u * t, w = g * o + o, C = Math.pow(u, 2) * Math.pow(m, 2) * t, b = Math.exp(-g), S = ul(Math.pow(m, 2), u); return (-l(m) + ll > 0 ? -1 : 1) * ((w - C) * b) / S }) : (l = m => { const v = Math.exp(-m * t), g = (m - o) * t + 1; return -ll + v * g }, d = m => { const v = Math.exp(-m * t), g = (o - m) * (t * t); return v * g }); const f = 5 / t, h = mx(l, d, f); if (t = $t(t), isNaN(h)) return { stiffness: 100, damping: 10, duration: t }; { const m = Math.pow(h, 2) * s; return { stiffness: m, damping: u * 2 * Math.sqrt(s * m), duration: t } } } const hx = 12; function mx(t, r, o) { let s = o; for (let l = 1; l < hx; l++)s = s - t(s) / r(s); return s } function ul(t, r) { return t * Math.sqrt(1 - r * r) } const gx = ["duration", "bounce"], vx = ["stiffness", "damping", "mass"]; function Mf(t, r) { return r.some(o => t[o] !== void 0) } function yx(t) { let r = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...t }; if (!Mf(t, vx) && Mf(t, gx)) { const o = px(t); r = { ...r, ...o, mass: 1 }, r.isResolvedFromDuration = !0 } return r } function Lf({ keyframes: t, restDelta: r, restSpeed: o, ...s }) { const l = t[0], d = t[t.length - 1], u = { done: !1, value: l }, { stiffness: f, damping: h, mass: m, duration: v, velocity: g, isResolvedFromDuration: w } = yx({ ...s, velocity: -on(s.velocity || 0) }), C = g || 0, b = h / (2 * Math.sqrt(f * m)), S = d - l, P = on(Math.sqrt(f / m)), R = Math.abs(S) < 5; o || (o = R ? .01 : 2), r || (r = R ? .005 : .5); let N; if (b < 1) { const L = ul(P, b); N = j => { const I = Math.exp(-b * P * j); return d - I * ((C + b * P * S) / L * Math.sin(L * j) + S * Math.cos(L * j)) } } else if (b === 1) N = L => d - Math.exp(-P * L) * (S + (C + P * S) * L); else { const L = P * Math.sqrt(b * b - 1); N = j => { const I = Math.exp(-b * P * j), K = Math.min(L * j, 300); return d - I * ((C + b * P * S) * Math.sinh(K) + L * S * Math.cosh(K)) / L } } return { calculatedDuration: w && v || null, next: L => { const j = N(L); if (w) u.done = L >= v; else { let I = 0; b < 1 && (I = L === 0 ? $t(C) : Af(N, L, j)); const K = Math.abs(I) <= o, H = Math.abs(d - j) <= r; u.done = K && H } return u.value = u.done ? d : j, u } } } function Df({ keyframes: t, velocity: r = 0, power: o = .8, timeConstant: s = 325, bounceDamping: l = 10, bounceStiffness: d = 500, modifyTarget: u, min: f, max: h, restDelta: m = .5, restSpeed: v }) { const g = t[0], w = { done: !1, value: g }, C = W => f !== void 0 && W < f || h !== void 0 && W > h, b = W => f === void 0 ? h : h === void 0 || Math.abs(f - W) < Math.abs(h - W) ? f : h; let S = o * r; const P = g + S, R = u === void 0 ? P : u(P); R !== P && (S = R - g); const N = W => -S * Math.exp(-W / s), L = W => R + N(W), j = W => { const le = N(W), ie = L(W); w.done = Math.abs(le) <= m, w.value = w.done ? R : ie }; let I, K; const H = W => { C(w.value) && (I = W, K = Lf({ keyframes: [w.value, b(w.value)], velocity: Af(L, W, w.value), damping: l, stiffness: d, restDelta: m, restSpeed: v })) }; return H(0), { calculatedDuration: null, next: W => { let le = !1; return !K && I === void 0 && (le = !0, j(W), H(W)), I !== void 0 && W >= I ? K.next(W - I) : (!le && j(W), w) } } } const jf = (t, r, o) => (((1 - 3 * o + 3 * r) * t + (3 * o - 6 * r)) * t + 3 * r) * t, wx = 1e-7, xx = 12; function Sx(t, r, o, s, l) { let d, u, f = 0; do u = r + (o - r) / 2, d = jf(u, s, l) - t, d > 0 ? o = u : r = u; while (Math.abs(d) > wx && ++f < xx); return u } function Ao(t, r, o, s) { if (t === r && o === s) return qe; const l = d => Sx(d, 0, 1, t, o); return d => d === 0 || d === 1 ? d : jf(l(d), r, s) } const Cx = Ao(.42, 0, 1, 1), bx = Ao(0, 0, .58, 1), Of = Ao(.42, 0, .58, 1), kx = t => Array.isArray(t) && typeof t[0] != "number", _f = t => r => r <= .5 ? t(2 * r) / 2 : (2 - t(2 * (1 - r))) / 2, If = t => r => 1 - t(1 - r), cl = t => 1 - Math.sin(Math.acos(t)), Vf = If(cl), Px = _f(cl), Ff = Ao(.33, 1.53, .69, .99), dl = If(Ff), Ex = _f(dl), Tx = { linear: qe, easeIn: Cx, easeInOut: Of, easeOut: bx, circIn: cl, circInOut: Px, circOut: Vf, backIn: dl, backInOut: Ex, backOut: Ff, anticipate: t => (t *= 2) < 1 ? .5 * dl(t) : .5 * (2 - Math.pow(2, -10 * (t - 1))) }, zf = t => { if (Array.isArray(t)) { Nd(t.length === 4); const [r, o, s, l] = t; return Ao(r, o, s, l) } else if (typeof t == "string") return Tx[t]; return t }, No = (t, r, o) => { const s = r - t; return s === 0 ? 1 : (o - t) / s }, je = (t, r, o) => t + (r - t) * o; function fl(t, r, o) { return o < 0 && (o += 1), o > 1 && (o -= 1), o < 1 / 6 ? t + (r - t) * 6 * o : o < 1 / 2 ? r : o < 2 / 3 ? t + (r - t) * (2 / 3 - o) * 6 : t } function Rx({ hue: t, saturation: r, lightness: o, alpha: s }) { t /= 360, r /= 100, o /= 100; let l = 0, d = 0, u = 0; if (!r) l = d = u = o; else { const f = o < .5 ? o * (1 + r) : o + r - o * r, h = 2 * o - f; l = fl(h, f, t + 1 / 3), d = fl(h, f, t), u = fl(h, f, t - 1 / 3) } return { red: Math.round(l * 255), green: Math.round(d * 255), blue: Math.round(u * 255), alpha: s } } function Hi(t, r) { return o => o > 0 ? r : t } const pl = (t, r, o) => { const s = t * t, l = o * (r * r - s) + s; return l < 0 ? 0 : Math.sqrt(l) }, Ax = [il, tr, Rr], Nx = t => Ax.find(r => r.test(t)); function Bf(t) { const r = Nx(t); if (!r) return !1; let o = r.parse(t); return r === Rr && (o = Rx(o)), o } const Uf = (t, r) => { const o = Bf(t), s = Bf(r); if (!o || !s) return Hi(t, r); const l = { ...o }; return d => (l.red = pl(o.red, s.red, d), l.green = pl(o.green, s.green, d), l.blue = pl(o.blue, s.blue, d), l.alpha = je(o.alpha, s.alpha, d), tr.transform(l)) }, hl = new Set(["none", "hidden"]); function Mx(t, r) { return hl.has(t) ? o => o <= 0 ? t : r : o => o >= 1 ? r : t } function Lx(t, r) { return o => je(t, r, o) } function ml(t) { return typeof t == "number" ? Lx : typeof t == "string" ? za(t) ? Hi : rt.test(t) ? Uf : Ox : Array.isArray(t) ? Wf : typeof t == "object" ? rt.test(t) ? Uf : Dx : Hi } function Wf(t, r) { const o = [...t], s = o.length, l = t.map((d, u) => ml(d)(d, r[u])); return d => { for (let u = 0; u < s; u++)o[u] = l[u](d); return o } } function Dx(t, r) { const o = { ...t, ...r }, s = {}; for (const l in o) t[l] !== void 0 && r[l] !== void 0 && (s[l] = ml(t[l])(t[l], r[l])); return l => { for (const d in s) o[d] = s[d](l); return o } } function jx(t, r) { var o; const s = [], l = { color: 0, var: 0, number: 0 }; for (let d = 0; d < r.values.length; d++) { const u = r.types[d], f = t.indexes[u][l[u]], h = (o = t.values[f]) !== null && o !== void 0 ? o : 0; s[d] = h, l[u]++ } return s } const Ox = (t, r) => { const o = En.createTransformer(r), s = Ro(t), l = Ro(r); return s.indexes.var.length === l.indexes.var.length && s.indexes.color.length === l.indexes.color.length && s.indexes.number.length >= l.indexes.number.length ? hl.has(t) && !l.values.length || hl.has(r) && !s.values.length ? Mx(t, r) : rn(Wf(jx(s, l), l.values), o) : Hi(t, r) }; function $f(t, r, o) { return typeof t == "number" && typeof r == "number" && typeof o == "number" ? je(t, r, o) : ml(t)(t, r) } function _x(t, r, o) { const s = [], l = o || $f, d = t.length - 1; for (let u = 0; u < d; u++) { let f = l(t[u], t[u + 1]); if (r) { const h = Array.isArray(r) ? r[u] || qe : r; f = rn(h, f) } s.push(f) } return s } function Ix(t, r, { clamp: o = !0, ease: s, mixer: l } = {}) { const d = t.length; if (Nd(d === r.length), d === 1) return () => r[0]; if (d === 2 && t[0] === t[1]) return () => r[1]; t[0] > t[d - 1] && (t = [...t].reverse(), r = [...r].reverse()); const u = _x(r, s, l), f = u.length, h = m => { let v = 0; if (f > 1) for (; v < t.length - 2 && !(m < t[v + 1]); v++); const g = No(t[v], t[v + 1], m); return u[v](g) }; return o ? m => h(bn(t[0], t[d - 1], m)) : h } function Vx(t, r) { const o = t[t.length - 1]; for (let s = 1; s <= r; s++) { const l = No(0, r, s); t.push(je(o, 1, l)) } } function Fx(t) { const r = [0]; return Vx(r, t.length - 1), r } function zx(t, r) { return t.map(o => o * r) } function Bx(t, r) { return t.map(() => r || Of).splice(0, t.length - 1) } function Ki({ duration: t = 300, keyframes: r, times: o, ease: s = "easeInOut" }) { const l = kx(s) ? s.map(zf) : zf(s), d = { done: !1, value: r[0] }, u = zx(o && o.length === r.length ? o : Fx(r), t), f = Ix(u, r, { ease: Array.isArray(l) ? l : Bx(r, l) }); return { calculatedDuration: t, next: h => (d.value = f(h), d.done = h >= t, d) } } const Hf = 2e4; function Ux(t) { let r = 0; const o = 50; let s = t.next(r); for (; !s.done && r < Hf;)r += o, s = t.next(r); return r >= Hf ? 1 / 0 : r } const Wx = t => { const r = ({ timestamp: o }) => t(o); return { start: () => Te.update(r, !0), stop: () => en(r), now: () => Ze.isProcessing ? Ze.timestamp : sn.now() } }, $x = { decay: Df, inertia: Df, tween: Ki, keyframes: Ki, spring: Lf }, Hx = t => t / 100; class gl extends Tf { constructor(r) { super(r), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.teardown(); const { onStop: h } = this.options; h && h() }; const { name: o, motionValue: s, element: l, keyframes: d } = this.options, u = l?.KeyframeResolver || nl, f = (h, m) => this.onKeyframesResolved(h, m); this.resolver = new u(d, f, o, s, l), this.resolver.scheduleResolve() } initPlayback(r) { const { type: o = "keyframes", repeat: s = 0, repeatDelay: l = 0, repeatType: d, velocity: u = 0 } = this.options, f = $x[o] || Ki; let h, m; f !== Ki && typeof r[0] != "number" && (h = rn(Hx, $f(r[0], r[1])), r = [0, 100]); const v = f({ ...this.options, keyframes: r }); d === "mirror" && (m = f({ ...this.options, keyframes: [...r].reverse(), velocity: -u })), v.calculatedDuration === null && (v.calculatedDuration = Ux(v)); const { calculatedDuration: g } = v, w = g + l, C = w * (s + 1) - l; return { generator: v, mirroredGenerator: m, mapPercentToKeyframes: h, calculatedDuration: g, resolvedDuration: w, totalDuration: C } } onPostResolved() { const { autoplay: r = !0 } = this.options; this.play(), this.pendingPlayState === "paused" || !r ? this.pause() : this.state = this.pendingPlayState } tick(r, o = !1) { const { resolved: s } = this; if (!s) { const { keyframes: W } = this.options; return { done: !0, value: W[W.length - 1] } } const { finalKeyframe: l, generator: d, mirroredGenerator: u, mapPercentToKeyframes: f, keyframes: h, calculatedDuration: m, totalDuration: v, resolvedDuration: g } = s; if (this.startTime === null) return d.next(0); const { delay: w, repeat: C, repeatType: b, repeatDelay: S, onUpdate: P } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, r) : this.speed < 0 && (this.startTime = Math.min(r - v / this.speed, this.startTime)), o ? this.currentTime = r : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(r - this.startTime) * this.speed; const R = this.currentTime - w * (this.speed >= 0 ? 1 : -1), N = this.speed >= 0 ? R < 0 : R > v; this.currentTime = Math.max(R, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = v); let L = this.currentTime, j = d; if (C) { const W = Math.min(this.currentTime, v) / g; let le = Math.floor(W), ie = W % 1; !ie && W >= 1 && (ie = 1), ie === 1 && le--, le = Math.min(le, C + 1), !!(le % 2) && (b === "reverse" ? (ie = 1 - ie, S && (ie -= S / g)) : b === "mirror" && (j = u)), L = bn(0, 1, ie) * g } const I = N ? { done: !1, value: h[0] } : j.next(L); f && (I.value = f(I.value)); let { done: K } = I; !N && m !== null && (K = this.speed >= 0 ? this.currentTime >= v : this.currentTime <= 0); const H = this.holdTime === null && (this.state === "finished" || this.state === "running" && K); return H && l !== void 0 && (I.value = Wi(h, this.options, l)), P && P(I.value), H && this.finish(), I } get duration() { const { resolved: r } = this; return r ? on(r.calculatedDuration) : 0 } get time() { return on(this.currentTime) } set time(r) { r = $t(r), this.currentTime = r, this.holdTime !== null || this.speed === 0 ? this.holdTime = r : this.driver && (this.startTime = this.driver.now() - r / this.speed) } get speed() { return this.playbackSpeed } set speed(r) { const o = this.playbackSpeed !== r; this.playbackSpeed = r, o && (this.time = on(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) { this.pendingPlayState = "running"; return } if (this.isStopped) return; const { driver: r = Wx, onPlay: o, startTime: s } = this.options; this.driver || (this.driver = r(d => this.tick(d))), o && o(); const l = this.driver.now(); this.holdTime !== null ? this.startTime = l - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = l) : this.startTime = s ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var r; if (!this._resolved) { this.pendingPlayState = "paused"; return } this.state = "paused", this.holdTime = (r = this.currentTime) !== null && r !== void 0 ? r : 0 } complete() { this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; const { onComplete: r } = this.options; r && r() } cancel() { this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(r) { return this.startTime = 0, this.tick(r, !0) } } const Kf = t => Array.isArray(t) && typeof t[0] == "number"; function Gf(t) { return !!(!t || typeof t == "string" && t in vl || Kf(t) || Array.isArray(t) && t.every(Gf)) } const Mo = ([t, r, o, s]) => `cubic-bezier(${t}, ${r}, ${o}, ${s})`, vl = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: Mo([0, .65, .55, 1]), circOut: Mo([.55, 0, 1, .45]), backIn: Mo([.31, .01, .66, -.59]), backOut: Mo([.33, 1.53, .69, .99]) }; function Kx(t) { return Yf(t) || vl.easeOut } function Yf(t) { if (t) return Kf(t) ? Mo(t) : Array.isArray(t) ? t.map(Kx) : vl[t] } function Gx(t, r, o, { delay: s = 0, duration: l = 300, repeat: d = 0, repeatType: u = "loop", ease: f, times: h } = {}) { const m = { [r]: o }; h && (m.offset = h); const v = Yf(f); return Array.isArray(v) && (m.easing = v), t.animate(m, { delay: s, duration: l, easing: Array.isArray(v) ? "linear" : v, fill: "both", iterations: d + 1, direction: u === "reverse" ? "alternate" : "normal" }) } const Yx = Pf(() => Object.hasOwnProperty.call(Element.prototype, "animate")), Gi = 10, Xx = 2e4; function Qx(t) { return t.type === "spring" || !Gf(t.ease) } function qx(t, r) { const o = new gl({ ...r, keyframes: t, repeat: 0, delay: 0, isGenerator: !0 }); let s = { done: !1, value: t[0] }; const l = []; let d = 0; for (; !s.done && d < Xx;)s = o.sample(d), l.push(s.value), d += Gi; return { times: void 0, keyframes: l, duration: d - Gi, ease: "linear" } } class Xf extends Tf { constructor(r) { super(r); const { name: o, motionValue: s, element: l, keyframes: d } = this.options; this.resolver = new kf(d, (u, f) => this.onKeyframesResolved(u, f), o, s, l), this.resolver.scheduleResolve() } initPlayback(r, o) { var s; let { duration: l = 300, times: d, ease: u, type: f, motionValue: h, name: m, startTime: v } = this.options; if (!(!((s = h.owner) === null || s === void 0) && s.current)) return !1; if (Qx(this.options)) { const { onComplete: w, onUpdate: C, motionValue: b, element: S, ...P } = this.options, R = qx(r, P); r = R.keyframes, r.length === 1 && (r[1] = r[0]), l = R.duration, d = R.times, u = R.ease, f = "keyframes" } const g = Gx(h.owner.current, m, r, { ...this.options, duration: l, times: d, ease: u }); return g.startTime = v ?? this.calcStartTime(), this.pendingTimeline ? (g.timeline = this.pendingTimeline, this.pendingTimeline = void 0) : g.onfinish = () => { const { onComplete: w } = this.options; h.set(Wi(r, this.options, o)), w && w(), this.cancel(), this.resolveFinishedPromise() }, { animation: g, duration: l, times: d, type: f, ease: u, keyframes: r } } get duration() { const { resolved: r } = this; if (!r) return 0; const { duration: o } = r; return on(o) } get time() { const { resolved: r } = this; if (!r) return 0; const { animation: o } = r; return on(o.currentTime || 0) } set time(r) { const { resolved: o } = this; if (!o) return; const { animation: s } = o; s.currentTime = $t(r) } get speed() { const { resolved: r } = this; if (!r) return 1; const { animation: o } = r; return o.playbackRate } set speed(r) { const { resolved: o } = this; if (!o) return; const { animation: s } = o; s.playbackRate = r } get state() { const { resolved: r } = this; if (!r) return "idle"; const { animation: o } = r; return o.playState } get startTime() { const { resolved: r } = this; if (!r) return null; const { animation: o } = r; return o.startTime } attachTimeline(r) { if (!this._resolved) this.pendingTimeline = r; else { const { resolved: o } = this; if (!o) return qe; const { animation: s } = o; s.timeline = r, s.onfinish = null } return qe } play() { if (this.isStopped) return; const { resolved: r } = this; if (!r) return; const { animation: o } = r; o.playState === "finished" && this.updateFinishedPromise(), o.play() } pause() { const { resolved: r } = this; if (!r) return; const { animation: o } = r; o.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.resolveFinishedPromise(), this.updateFinishedPromise(); const { resolved: r } = this; if (!r) return; const { animation: o, keyframes: s, duration: l, type: d, ease: u, times: f } = r; if (o.playState === "idle" || o.playState === "finished") return; if (this.time) { const { motionValue: m, onUpdate: v, onComplete: g, element: w, ...C } = this.options, b = new gl({ ...C, keyframes: s, duration: l, type: d, ease: u, times: f, isGenerator: !0 }), S = $t(this.time); m.setWithVelocity(b.sample(S - Gi).value, b.sample(S).value, Gi) } const { onStop: h } = this.options; h && h(), this.cancel() } complete() { const { resolved: r } = this; r && r.animation.finish() } cancel() { const { resolved: r } = this; r && r.animation.cancel() } static supports(r) { const { motionValue: o, name: s, repeatDelay: l, repeatType: d, damping: u, type: f } = r; return Yx() && s && Kd.has(s) && o && o.owner && o.owner.current instanceof HTMLElement && !o.owner.getProps().onUpdate && !l && d !== "mirror" && u !== 0 && f !== "inertia" } } function Zx(t, r) { let o; const s = () => { const { currentTime: l } = r, u = (l === null ? 0 : l.value) / 100; o !== u && t(u), o = u }; return Te.update(s, !0), () => en(s) } const Jx = Pf(() => window.ScrollTimeline !== void 0); class e1 { constructor(r) { this.stop = () => this.runAll("stop"), this.animations = r.filter(Boolean) } then(r, o) { return Promise.all(this.animations).then(r).catch(o) } getAll(r) { return this.animations[0][r] } setAll(r, o) { for (let s = 0; s < this.animations.length; s++)this.animations[s][r] = o } attachTimeline(r) { const o = this.animations.map(s => { if (Jx() && s.attachTimeline) s.attachTimeline(r); else return s.pause(), Zx(l => { s.time = s.duration * l }, r) }); return () => { o.forEach((s, l) => { s && s(), this.animations[l].stop() }) } } get time() { return this.getAll("time") } set time(r) { this.setAll("time", r) } get speed() { return this.getAll("speed") } set speed(r) { this.setAll("speed", r) } get startTime() { return this.getAll("startTime") } get duration() { let r = 0; for (let o = 0; o < this.animations.length; o++)r = Math.max(r, this.animations[o].duration); return r } runAll(r) { this.animations.forEach(o => o[r]()) } play() { this.runAll("play") } pause() { this.runAll("pause") } cancel() { this.runAll("cancel") } complete() { this.runAll("complete") } } const yl = (t, r, o, s = {}, l, d, u) => f => { const h = Ja(s, t) || {}, m = h.delay || s.delay || 0; let { elapsed: v = 0 } = s; v = v - $t(m); let g = { keyframes: Array.isArray(o) ? o : [null, o], ease: "easeOut", velocity: r.getVelocity(), ...h, delay: -v, onUpdate: C => { r.set(C), h.onUpdate && h.onUpdate(C) }, onComplete: () => { f(), h.onComplete && h.onComplete(), u && u() }, onStop: u, name: t, motionValue: r, element: d ? void 0 : l }; Ow(h) || (g = { ...g, ...jw(t, g) }), g.duration && (g.duration = $t(g.duration)), g.repeatDelay && (g.repeatDelay = $t(g.repeatDelay)), g.from !== void 0 && (g.keyframes[0] = g.from); let w = !1; if ((g.type === !1 || g.duration === 0 && !g.repeatDelay) && (g.duration = 0, g.delay === 0 && (w = !0)), w && !d && r.get() !== void 0) { const C = Wi(g.keyframes, h); if (C !== void 0) return Te.update(() => { g.onUpdate(C), g.onComplete() }), new e1([]) } return !d && Xf.supports(g) ? new Xf(g) : new gl(g) }; class wl { constructor() { this.subscriptions = [] } add(r) { return Fi(this.subscriptions, r), () => zi(this.subscriptions, r) } notify(r, o, s) { const l = this.subscriptions.length; if (l) if (l === 1) this.subscriptions[0](r, o, s); else for (let d = 0; d < l; d++) { const u = this.subscriptions[d]; u && u(r, o, s) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const Qf = 30, t1 = t => !isNaN(parseFloat(t)); class qf { constructor(r, o = {}) { this.version = "11.3.29", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (s, l = !0) => { const d = sn.now(); this.updatedAt !== d && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(s), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), l && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(r), this.owner = o.owner } setCurrent(r) { this.current = r, this.updatedAt = sn.now(), this.canTrackVelocity === null && r !== void 0 && (this.canTrackVelocity = t1(this.current)) } setPrevFrameValue(r = this.current) { this.prevFrameValue = r, this.prevUpdatedAt = this.updatedAt } onChange(r) { return this.on("change", r) } on(r, o) { this.events[r] || (this.events[r] = new wl); const s = this.events[r].add(o); return r === "change" ? () => { s(), Te.read(() => { this.events.change.getSize() || this.stop() }) } : s } clearListeners() { for (const r in this.events) this.events[r].clear() } attach(r, o) { this.passiveEffect = r, this.stopPassiveEffect = o } set(r, o = !0) { !o || !this.passiveEffect ? this.updateAndNotify(r, o) : this.passiveEffect(r, this.updateAndNotify) } setWithVelocity(r, o, s) { this.set(o), this.prev = void 0, this.prevFrameValue = r, this.prevUpdatedAt = this.updatedAt - s } jump(r, o = !0) { this.updateAndNotify(r), this.prev = r, this.prevUpdatedAt = this.prevFrameValue = void 0, o && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const r = sn.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || r - this.updatedAt > Qf) return 0; const o = Math.min(this.updatedAt - this.prevUpdatedAt, Qf); return Rf(parseFloat(this.current) - parseFloat(this.prevFrameValue), o) } start(r) { return this.stop(), new Promise(o => { this.hasAnimated = !0, this.animation = r(o), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function Lo(t, r) { return new qf(t, r) } function n1(t, r, o) { t.hasValue(r) ? t.getValue(r).set(o) : t.addValue(r, Lo(o)) } function r1(t, r) { const o = Ui(t, r); let { transitionEnd: s = {}, transition: l = {}, ...d } = o || {}; d = { ...d, ...s }; for (const u in d) { const f = cw(d[u]); n1(t, u, f) } } function Zf(t) { return t.getProps()[Cd] } class o1 extends qf { constructor() { super(...arguments), this.output = [], this.counts = new Map } add(r) { const o = Gd(r); if (!o) return; const s = this.counts.get(o) || 0; this.counts.set(o, s + 1), s === 0 && (this.output.push(o), this.update()); let l = !1; return () => { if (l) return; l = !0; const d = this.counts.get(o) - 1; this.counts.set(o, d), d === 0 && (zi(this.output, o), this.update()) } } update() { this.set(this.output.length ? this.output.join(", ") : "auto") } } function i1(t) { return !!(nt(t) && t.add) } function xl(t, r) { var o; if (!t.applyWillChange) return; let s = t.getValue("willChange"); if (!s && !(!((o = t.props.style) === null || o === void 0) && o.willChange) && (s = new o1("auto"), t.addValue("willChange", s)), i1(s)) return s.add(r) } function s1({ protectedKeys: t, needsAnimating: r }, o) { const s = t.hasOwnProperty(o) && r[o] !== !0; return r[o] = !1, s } function Jf(t, r, { delay: o = 0, transitionOverride: s, type: l } = {}) { var d; let { transition: u = t.getDefaultTransition(), transitionEnd: f, ...h } = r; s && (u = s); const m = [], v = l && t.animationState && t.animationState.getState()[l]; for (const g in h) { const w = t.getValue(g, (d = t.latestValues[g]) !== null && d !== void 0 ? d : null), C = h[g]; if (C === void 0 || v && s1(v, g)) continue; const b = { delay: o, ...Ja(u || {}, g) }; let S = !1; if (window.MotionHandoffAnimation) { const R = Zf(t); if (R) { const N = window.MotionHandoffAnimation(R, g, Te); N !== null && (b.startTime = N, S = !0) } } w.start(yl(g, w, C, t.shouldReduceMotion && Cn.has(g) ? { type: !1 } : b, t, S, xl(t, g))); const P = w.animation; P && m.push(P) } return f && Promise.all(m).then(() => { Te.update(() => { f && r1(t, f) }) }), m } function Sl(t, r, o = {}) { var s; const l = Ui(t, r, o.type === "exit" ? (s = t.presenceContext) === null || s === void 0 ? void 0 : s.custom : void 0); let { transition: d = t.getDefaultTransition() || {} } = l || {}; o.transitionOverride && (d = o.transitionOverride); const u = l ? () => Promise.all(Jf(t, l, o)) : () => Promise.resolve(), f = t.variantChildren && t.variantChildren.size ? (m = 0) => { const { delayChildren: v = 0, staggerChildren: g, staggerDirection: w } = d; return a1(t, r, v + m, g, w, o) } : () => Promise.resolve(), { when: h } = d; if (h) { const [m, v] = h === "beforeChildren" ? [u, f] : [f, u]; return m().then(() => v()) } else return Promise.all([u(), f(o.delay)]) } function a1(t, r, o = 0, s = 0, l = 1, d) { const u = [], f = (t.variantChildren.size - 1) * s, h = l === 1 ? (m = 0) => m * s : (m = 0) => f - m * s; return Array.from(t.variantChildren).sort(l1).forEach((m, v) => { m.notify("AnimationStart", r), u.push(Sl(m, r, { ...d, delay: o + h(v) }).then(() => m.notify("AnimationComplete", r))) }), Promise.all(u) } function l1(t, r) { return t.sortNodePosition(r) } function u1(t, r, o = {}) { t.notify("AnimationStart", r); let s; if (Array.isArray(r)) { const l = r.map(d => Sl(t, d, o)); s = Promise.all(l) } else if (typeof r == "string") s = Sl(t, r, o); else { const l = typeof r == "function" ? Ui(t, r, o.custom) : r; s = Promise.all(Jf(t, l, o)) } return s.then(() => { t.notify("AnimationComplete", r) }) } const c1 = [...ja].reverse(), d1 = ja.length; function f1(t) { return r => Promise.all(r.map(({ animation: o, options: s }) => u1(t, o, s))) } function p1(t) { let r = f1(t), o = ep(), s = !0; const l = h => (m, v) => { var g; const w = Ui(t, v, h === "exit" ? (g = t.presenceContext) === null || g === void 0 ? void 0 : g.custom : void 0); if (w) { const { transition: C, transitionEnd: b, ...S } = w; m = { ...m, ...S, ...b } } return m }; function d(h) { r = h(t) } function u(h) { const m = t.getProps(), v = t.getVariantContext(!0) || {}, g = [], w = new Set; let C = {}, b = 1 / 0; for (let P = 0; P < d1; P++) { const R = c1[P], N = o[R], L = m[R] !== void 0 ? m[R] : v[R], j = So(L), I = R === h ? N.isActive : null; I === !1 && (b = P); let K = L === v[R] && L !== m[R] && j; if (K && s && t.manuallyAnimateOnMount && (K = !1), N.protectedKeys = { ...C }, !N.isActive && I === null || !L && !N.prevProp || Co(L) || typeof L == "boolean") continue; let W = h1(N.prevProp, L) || R === h && N.isActive && !K && j || P > b && j, le = !1; const ie = Array.isArray(L) ? L : [L]; let ge = ie.reduce(l(R), {}); I === !1 && (ge = {}); const { prevResolvedValues: J = {} } = N, Se = { ...J, ...ge }, ne = oe => { W = !0, w.has(oe) && (le = !0, w.delete(oe)), N.needsAnimating[oe] = !0; const ue = t.getValue(oe); ue && (ue.liveStyle = !1) }; for (const oe in Se) { const ue = ge[oe], G = J[oe]; if (C.hasOwnProperty(oe)) continue; let F = !1; Ya(ue) && Ya(G) ? F = !of(ue, G) : F = ue !== G, F ? ue != null ? ne(oe) : w.add(oe) : ue !== void 0 && w.has(oe) ? ne(oe) : N.protectedKeys[oe] = !0 } N.prevProp = L, N.prevResolvedValues = ge, N.isActive && (C = { ...C, ...ge }), s && t.blockInitialAnimation && (W = !1), W && (!K || le) && g.push(...ie.map(oe => ({ animation: oe, options: { type: R } }))) } if (w.size) { const P = {}; w.forEach(R => { const N = t.getBaseTarget(R), L = t.getValue(R); L && (L.liveStyle = !0), P[R] = N ?? null }), g.push({ animation: P }) } let S = !!g.length; return s && (m.initial === !1 || m.initial === m.animate) && !t.manuallyAnimateOnMount && (S = !1), s = !1, S ? r(g) : Promise.resolve() } function f(h, m) { var v; if (o[h].isActive === m) return Promise.resolve(); (v = t.variantChildren) === null || v === void 0 || v.forEach(w => { var C; return (C = w.animationState) === null || C === void 0 ? void 0 : C.setActive(h, m) }), o[h].isActive = m; const g = u(h); for (const w in o) o[w].protectedKeys = {}; return g } return { animateChanges: u, setActive: f, setAnimateFunction: d, getState: () => o, reset: () => { o = ep(), s = !0 } } } function h1(t, r) { return typeof r == "string" ? r !== t : Array.isArray(r) ? !of(r, t) : !1 } function nr(t = !1) { return { isActive: t, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function ep() { return { animate: nr(!0), whileInView: nr(), whileHover: nr(), whileTap: nr(), whileDrag: nr(), whileFocus: nr(), exit: nr() } } class m1 extends Pn { constructor(r) { super(r), r.animationState || (r.animationState = p1(r)) } updateAnimationControlsSubscription() { const { animate: r } = this.node.getProps(); Co(r) && (this.unmountControls = r.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: r } = this.node.getProps(), { animate: o } = this.node.prevProps || {}; r !== o && this.updateAnimationControlsSubscription() } unmount() { var r; this.node.animationState.reset(), (r = this.unmountControls) === null || r === void 0 || r.call(this) } } let g1 = 0; class v1 extends Pn { constructor() { super(...arguments), this.id = g1++ } update() { if (!this.node.presenceContext) return; const { isPresent: r, onExitComplete: o } = this.node.presenceContext, { isPresent: s } = this.node.prevPresenceContext || {}; if (!this.node.animationState || r === s) return; const l = this.node.animationState.setActive("exit", !r); o && !r && l.then(() => o(this.id)) } mount() { const { register: r } = this.node.presenceContext || {}; r && (this.unmount = r(this.id)) } unmount() { } } const y1 = { animation: { Feature: m1 }, exit: { Feature: v1 } }, tp = (t, r) => Math.abs(t - r); function w1(t, r) { const o = tp(t.x, r.x), s = tp(t.y, r.y); return Math.sqrt(o ** 2 + s ** 2) } class np { constructor(r, o, { transformPagePoint: s, contextWindow: l, dragSnapToOrigin: d = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const g = bl(this.lastMoveEventInfo, this.history), w = this.startEvent !== null, C = w1(g.offset, { x: 0, y: 0 }) >= 3; if (!w && !C) return; const { point: b } = g, { timestamp: S } = Ze; this.history.push({ ...b, timestamp: S }); const { onStart: P, onMove: R } = this.handlers; w || (P && P(this.lastMoveEvent, g), this.startEvent = this.lastMoveEvent), R && R(this.lastMoveEvent, g) }, this.handlePointerMove = (g, w) => { this.lastMoveEvent = g, this.lastMoveEventInfo = Cl(w, this.transformPagePoint), Te.update(this.updatePoint, !0) }, this.handlePointerUp = (g, w) => { this.end(); const { onEnd: C, onSessionEnd: b, resumeAnimation: S } = this.handlers; if (this.dragSnapToOrigin && S && S(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const P = bl(g.type === "pointercancel" ? this.lastMoveEventInfo : Cl(w, this.transformPagePoint), this.history); this.startEvent && C && C(g, P), b && b(g, P) }, !Qd(r)) return; this.dragSnapToOrigin = d, this.handlers = o, this.transformPagePoint = s, this.contextWindow = l || window; const u = Bi(r), f = Cl(u, this.transformPagePoint), { point: h } = f, { timestamp: m } = Ze; this.history = [{ ...h, timestamp: m }]; const { onSessionStart: v } = o; v && v(r, bl(f, this.history)), this.removeListeners = rn(nn(this.contextWindow, "pointermove", this.handlePointerMove), nn(this.contextWindow, "pointerup", this.handlePointerUp), nn(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(r) { this.handlers = r } end() { this.removeListeners && this.removeListeners(), en(this.updatePoint) } } function Cl(t, r) { return r ? { point: r(t.point) } : t } function rp(t, r) { return { x: t.x - r.x, y: t.y - r.y } } function bl({ point: t }, r) { return { point: t, delta: rp(t, op(r)), offset: rp(t, x1(r)), velocity: S1(r, .1) } } function x1(t) { return t[0] } function op(t) { return t[t.length - 1] } function S1(t, r) { if (t.length < 2) return { x: 0, y: 0 }; let o = t.length - 1, s = null; const l = op(t); for (; o >= 0 && (s = t[o], !(l.timestamp - s.timestamp > $t(r)));)o--; if (!s) return { x: 0, y: 0 }; const d = on(l.timestamp - s.timestamp); if (d === 0) return { x: 0, y: 0 }; const u = { x: (l.x - s.x) / d, y: (l.y - s.y) / d }; return u.x === 1 / 0 && (u.x = 0), u.y === 1 / 0 && (u.y = 0), u } const ip = 1e-4, C1 = 1 - ip, b1 = 1 + ip, sp = .01, k1 = 0 - sp, P1 = 0 + sp; function vt(t) { return t.max - t.min } function E1(t, r, o) { return Math.abs(t - r) <= o } function ap(t, r, o, s = .5) { t.origin = s, t.originPoint = je(r.min, r.max, t.origin), t.scale = vt(o) / vt(r), t.translate = je(o.min, o.max, t.origin) - t.originPoint, (t.scale >= C1 && t.scale <= b1 || isNaN(t.scale)) && (t.scale = 1), (t.translate >= k1 && t.translate <= P1 || isNaN(t.translate)) && (t.translate = 0) } function Do(t, r, o, s) { ap(t.x, r.x, o.x, s ? s.originX : void 0), ap(t.y, r.y, o.y, s ? s.originY : void 0) } function lp(t, r, o) { t.min = o.min + r.min, t.max = t.min + vt(r) } function T1(t, r, o) { lp(t.x, r.x, o.x), lp(t.y, r.y, o.y) } function up(t, r, o) { t.min = r.min - o.min, t.max = t.min + vt(r) } function jo(t, r, o) { up(t.x, r.x, o.x), up(t.y, r.y, o.y) } function R1(t, { min: r, max: o }, s) { return r !== void 0 && t < r ? t = s ? je(r, t, s.min) : Math.max(t, r) : o !== void 0 && t > o && (t = s ? je(o, t, s.max) : Math.min(t, o)), t } function cp(t, r, o) { return { min: r !== void 0 ? t.min + r : void 0, max: o !== void 0 ? t.max + o - (t.max - t.min) : void 0 } } function A1(t, { top: r, left: o, bottom: s, right: l }) { return { x: cp(t.x, o, l), y: cp(t.y, r, s) } } function dp(t, r) { let o = r.min - t.min, s = r.max - t.max; return r.max - r.min < t.max - t.min && ([o, s] = [s, o]), { min: o, max: s } } function N1(t, r) { return { x: dp(t.x, r.x), y: dp(t.y, r.y) } } function M1(t, r) { let o = .5; const s = vt(t), l = vt(r); return l > s ? o = No(r.min, r.max - s, t.min) : s > l && (o = No(t.min, t.max - l, r.min)), bn(0, 1, o) } function L1(t, r) { const o = {}; return r.min !== void 0 && (o.min = r.min - t.min), r.max !== void 0 && (o.max = r.max - t.min), o } const kl = .35; function D1(t = kl) { return t === !1 ? t = 0 : t === !0 && (t = kl), { x: fp(t, "left", "right"), y: fp(t, "top", "bottom") } } function fp(t, r, o) { return { min: pp(t, r), max: pp(t, o) } } function pp(t, r) { return typeof t == "number" ? t : t[r] || 0 } const hp = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), Ar = () => ({ x: hp(), y: hp() }), mp = () => ({ min: 0, max: 0 }), Fe = () => ({ x: mp(), y: mp() }); function kt(t) { return [t("x"), t("y")] } function gp({ top: t, left: r, right: o, bottom: s }) { return { x: { min: r, max: o }, y: { min: t, max: s } } } function j1({ x: t, y: r }) { return { top: r.min, right: t.max, bottom: r.max, left: t.min } } function O1(t, r) { if (!r) return t; const o = r({ x: t.left, y: t.top }), s = r({ x: t.right, y: t.bottom }); return { top: o.y, left: o.x, bottom: s.y, right: s.x } } function Pl(t) { return t === void 0 || t === 1 } function El({ scale: t, scaleX: r, scaleY: o }) { return !Pl(t) || !Pl(r) || !Pl(o) } function rr(t) { return El(t) || vp(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY } function vp(t) { return yp(t.x) || yp(t.y) } function yp(t) { return t && t !== "0%" } function Yi(t, r, o) { const s = t - o, l = r * s; return o + l } function wp(t, r, o, s, l) { return l !== void 0 && (t = Yi(t, l, s)), Yi(t, o, s) + r } function Tl(t, r = 0, o = 1, s, l) { t.min = wp(t.min, r, o, s, l), t.max = wp(t.max, r, o, s, l) } function xp(t, { x: r, y: o }) { Tl(t.x, r.translate, r.scale, r.originPoint), Tl(t.y, o.translate, o.scale, o.originPoint) } const Sp = .999999999999, Cp = 1.0000000000001; function _1(t, r, o, s = !1) { const l = o.length; if (!l) return; r.x = r.y = 1; let d, u; for (let f = 0; f < l; f++) { d = o[f], u = d.projectionDelta; const { visualElement: h } = d.options; h && h.props.style && h.props.style.display === "contents" || (s && d.options.layoutScroll && d.scroll && d !== d.root && Mr(t, { x: -d.scroll.offset.x, y: -d.scroll.offset.y }), u && (r.x *= u.x.scale, r.y *= u.y.scale, xp(t, u)), s && rr(d.latestValues) && Mr(t, d.latestValues)) } r.x < Cp && r.x > Sp && (r.x = 1), r.y < Cp && r.y > Sp && (r.y = 1) } function Nr(t, r) { t.min = t.min + r, t.max = t.max + r } function bp(t, r, o, s, l = .5) { const d = je(t.min, t.max, l); Tl(t, r, o, d, s) } function Mr(t, r) { bp(t.x, r.x, r.scaleX, r.scale, r.originX), bp(t.y, r.y, r.scaleY, r.scale, r.originY) } function kp(t, r) { return gp(O1(t.getBoundingClientRect(), r)) } function I1(t, r, o) { const s = kp(t, o), { scroll: l } = r; return l && (Nr(s.x, l.offset.x), Nr(s.y, l.offset.y)), s } const Pp = ({ current: t }) => t ? t.ownerDocument.defaultView : null, V1 = new WeakMap; class F1 { constructor(r) { this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Fe(), this.visualElement = r } start(r, { snapToCursor: o = !1 } = {}) { const { presenceContext: s } = this.visualElement; if (s && s.isPresent === !1) return; const l = v => { const { dragSnapToOrigin: g } = this.getProps(); g ? this.pauseAnimation() : this.stopAnimation(), o && this.snapToCursor(Bi(v, "page").point) }, d = (v, g) => { var w; const { drag: C, dragPropagation: b, onDragStart: S } = this.getProps(); if (C && !b && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = ef(C), !this.openGlobalLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), kt(R => { let N = this.getAxisMotionValue(R).get() || 0; if (Wt.test(N)) { const { projection: L } = this.visualElement; if (L && L.layout) { const j = L.layout.layoutBox[R]; j && (N = vt(j) * (parseFloat(N) / 100)) } } this.originPoint[R] = N }), S && Te.postRender(() => S(v, g)), (w = this.removeWillChange) === null || w === void 0 || w.call(this), this.removeWillChange = xl(this.visualElement, "transform"); const { animationState: P } = this.visualElement; P && P.setActive("whileDrag", !0) }, u = (v, g) => { const { dragPropagation: w, dragDirectionLock: C, onDirectionLock: b, onDrag: S } = this.getProps(); if (!w && !this.openGlobalLock) return; const { offset: P } = g; if (C && this.currentDirection === null) { this.currentDirection = z1(P), this.currentDirection !== null && b && b(this.currentDirection); return } this.updateAxis("x", g.point, P), this.updateAxis("y", g.point, P), this.visualElement.render(), S && S(v, g) }, f = (v, g) => this.stop(v, g), h = () => kt(v => { var g; return this.getAnimationState(v) === "paused" && ((g = this.getAxisMotionValue(v).animation) === null || g === void 0 ? void 0 : g.play()) }), { dragSnapToOrigin: m } = this.getProps(); this.panSession = new np(r, { onSessionStart: l, onStart: d, onMove: u, onSessionEnd: f, resumeAnimation: h }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: m, contextWindow: Pp(this.visualElement) }) } stop(r, o) { var s; (s = this.removeWillChange) === null || s === void 0 || s.call(this); const l = this.isDragging; if (this.cancel(), !l) return; const { velocity: d } = o; this.startAnimation(d); const { onDragEnd: u } = this.getProps(); u && Te.postRender(() => u(r, o)) } cancel() { this.isDragging = !1; const { projection: r, animationState: o } = this.visualElement; r && (r.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: s } = this.getProps(); !s && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), o && o.setActive("whileDrag", !1) } updateAxis(r, o, s) { const { drag: l } = this.getProps(); if (!s || !Xi(r, l, this.currentDirection)) return; const d = this.getAxisMotionValue(r); let u = this.originPoint[r] + s[r]; this.constraints && this.constraints[r] && (u = R1(u, this.constraints[r], this.elastic[r])), d.set(u) } resolveConstraints() { var r; const { dragConstraints: o, dragElastic: s } = this.getProps(), l = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (r = this.visualElement.projection) === null || r === void 0 ? void 0 : r.layout, d = this.constraints; o && kr(o) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : o && l ? this.constraints = A1(l.layoutBox, o) : this.constraints = !1, this.elastic = D1(s), d !== this.constraints && l && this.constraints && !this.hasMutatedConstraints && kt(u => { this.constraints !== !1 && this.getAxisMotionValue(u) && (this.constraints[u] = L1(l.layoutBox[u], this.constraints[u])) }) } resolveRefConstraints() { const { dragConstraints: r, onMeasureDragConstraints: o } = this.getProps(); if (!r || !kr(r)) return !1; const s = r.current, { projection: l } = this.visualElement; if (!l || !l.layout) return !1; const d = I1(s, l.root, this.visualElement.getTransformPagePoint()); let u = N1(l.layout.layoutBox, d); if (o) { const f = o(j1(u)); this.hasMutatedConstraints = !!f, f && (u = gp(f)) } return u } startAnimation(r) { const { drag: o, dragMomentum: s, dragElastic: l, dragTransition: d, dragSnapToOrigin: u, onDragTransitionEnd: f } = this.getProps(), h = this.constraints || {}, m = kt(v => { if (!Xi(v, o, this.currentDirection)) return; let g = h && h[v] || {}; u && (g = { min: 0, max: 0 }); const w = l ? 200 : 1e6, C = l ? 40 : 1e7, b = { type: "inertia", velocity: s ? r[v] : 0, bounceStiffness: w, bounceDamping: C, timeConstant: 750, restDelta: 1, restSpeed: 10, ...d, ...g }; return this.startAxisValueAnimation(v, b) }); return Promise.all(m).then(f) } startAxisValueAnimation(r, o) { const s = this.getAxisMotionValue(r); return s.start(yl(r, s, 0, o, this.visualElement, !1, xl(this.visualElement, r))) } stopAnimation() { kt(r => this.getAxisMotionValue(r).stop()) } pauseAnimation() { kt(r => { var o; return (o = this.getAxisMotionValue(r).animation) === null || o === void 0 ? void 0 : o.pause() }) } getAnimationState(r) { var o; return (o = this.getAxisMotionValue(r).animation) === null || o === void 0 ? void 0 : o.state } getAxisMotionValue(r) { const o = `_drag${r.toUpperCase()}`, s = this.visualElement.getProps(), l = s[o]; return l || this.visualElement.getValue(r, (s.initial ? s.initial[r] : void 0) || 0) } snapToCursor(r) { kt(o => { const { drag: s } = this.getProps(); if (!Xi(o, s, this.currentDirection)) return; const { projection: l } = this.visualElement, d = this.getAxisMotionValue(o); if (l && l.layout) { const { min: u, max: f } = l.layout.layoutBox[o]; d.set(r[o] - je(u, f, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: r, dragConstraints: o } = this.getProps(), { projection: s } = this.visualElement; if (!kr(o) || !s || !this.constraints) return; this.stopAnimation(); const l = { x: 0, y: 0 }; kt(u => { const f = this.getAxisMotionValue(u); if (f && this.constraints !== !1) { const h = f.get(); l[u] = M1({ min: h, max: h }, this.constraints[u]) } }); const { transformTemplate: d } = this.visualElement.getProps(); this.visualElement.current.style.transform = d ? d({}, "") : "none", s.root && s.root.updateScroll(), s.updateLayout(), this.resolveConstraints(), kt(u => { if (!Xi(u, r, null)) return; const f = this.getAxisMotionValue(u), { min: h, max: m } = this.constraints[u]; f.set(je(h, m, l[u])) }) } addListeners() { if (!this.visualElement.current) return; V1.set(this.visualElement, this); const r = this.visualElement.current, o = nn(r, "pointerdown", h => { const { drag: m, dragListener: v = !0 } = this.getProps(); m && v && this.start(h) }), s = () => { const { dragConstraints: h } = this.getProps(); kr(h) && h.current && (this.constraints = this.resolveRefConstraints()) }, { projection: l } = this.visualElement, d = l.addEventListener("measure", s); l && !l.layout && (l.root && l.root.updateScroll(), l.updateLayout()), Te.read(s); const u = tn(window, "resize", () => this.scalePositionWithinConstraints()), f = l.addEventListener("didUpdate", ({ delta: h, hasLayoutChanged: m }) => { this.isDragging && m && (kt(v => { const g = this.getAxisMotionValue(v); g && (this.originPoint[v] += h[v].translate, g.set(g.get() + h[v].translate)) }), this.visualElement.render()) }); return () => { u(), o(), d(), f && f() } } getProps() { const r = this.visualElement.getProps(), { drag: o = !1, dragDirectionLock: s = !1, dragPropagation: l = !1, dragConstraints: d = !1, dragElastic: u = kl, dragMomentum: f = !0 } = r; return { ...r, drag: o, dragDirectionLock: s, dragPropagation: l, dragConstraints: d, dragElastic: u, dragMomentum: f } } } function Xi(t, r, o) { return (r === !0 || r === t) && (o === null || o === t) } function z1(t, r = 10) { let o = null; return Math.abs(t.y) > r ? o = "y" : Math.abs(t.x) > r && (o = "x"), o } class B1 extends Pn { constructor(r) { super(r), this.removeGroupControls = qe, this.removeListeners = qe, this.controls = new F1(r) } mount() { const { dragControls: r } = this.node.getProps(); r && (this.removeGroupControls = r.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || qe } unmount() { this.removeGroupControls(), this.removeListeners() } } const Ep = t => (r, o) => { t && Te.postRender(() => t(r, o)) }; class U1 extends Pn { constructor() { super(...arguments), this.removePointerDownListener = qe } onPointerDown(r) { this.session = new np(r, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: Pp(this.node) }) } createPanHandlers() { const { onPanSessionStart: r, onPanStart: o, onPan: s, onPanEnd: l } = this.node.getProps(); return { onSessionStart: Ep(r), onStart: Ep(o), onMove: s, onEnd: (d, u) => { delete this.session, l && Te.postRender(() => l(d, u)) } } } mount() { this.removePointerDownListener = nn(this.node.current, "pointerdown", r => this.onPointerDown(r)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } function W1() { const t = x.useContext(Mi); if (t === null) return [!0, null]; const { isPresent: r, onExitComplete: o, register: s } = t, l = x.useId(); x.useEffect(() => s(l), []); const d = x.useCallback(() => o && o(l), [l, o]); return !r && o ? [!1, d] : [!0] } const Qi = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function Tp(t, r) { return r.max === r.min ? 0 : t / (r.max - r.min) * 100 } const Oo = { correct: (t, r) => { if (!r.target) return t; if (typeof t == "string") if (pe.test(t)) t = parseFloat(t); else return t; const o = Tp(t, r.target.x), s = Tp(t, r.target.y); return `${o}% ${s}%` } }, $1 = { correct: (t, { treeScale: r, projectionDelta: o }) => { const s = t, l = En.parse(t); if (l.length > 5) return s; const d = En.createTransformer(t), u = typeof l[0] != "number" ? 1 : 0, f = o.x.scale * r.x, h = o.y.scale * r.y; l[0 + u] /= f, l[1 + u] /= h; const m = je(f, h, .5); return typeof l[2 + u] == "number" && (l[2 + u] /= m), typeof l[3 + u] == "number" && (l[3 + u] /= m), d(l) } }; class H1 extends x.Component { componentDidMount() { const { visualElement: r, layoutGroup: o, switchLayoutGroup: s, layoutId: l } = this.props, { projection: d } = r; z0(K1), d && (o.group && o.group.add(d), s && s.register && l && s.register(d), d.root.didUpdate(), d.addEventListener("animationComplete", () => { this.safeToRemove() }), d.setOptions({ ...d.options, onExitComplete: () => this.safeToRemove() })), Qi.hasEverUpdated = !0 } getSnapshotBeforeUpdate(r) { const { layoutDependency: o, visualElement: s, drag: l, isPresent: d } = this.props, u = s.projection; return u && (u.isPresent = d, l || r.layoutDependency !== o || o === void 0 ? u.willUpdate() : this.safeToRemove(), r.isPresent !== d && (d ? u.promote() : u.relegate() || Te.postRender(() => { const f = u.getStack(); (!f || !f.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: r } = this.props.visualElement; r && (r.root.didUpdate(), Da.postRender(() => { !r.currentAnimation && r.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: r, layoutGroup: o, switchLayoutGroup: s } = this.props, { projection: l } = r; l && (l.scheduleCheckAfterUnmount(), o && o.group && o.group.remove(l), s && s.deregister && s.deregister(l)) } safeToRemove() { const { safeToRemove: r } = this.props; r && r() } render() { return null } } function Rp(t) { const [r, o] = W1(), s = x.useContext(_a); return T.jsx(H1, { ...t, layoutGroup: s, switchLayoutGroup: x.useContext(kd), isPresent: r, safeToRemove: o }) } const K1 = { borderRadius: { ...Oo, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: Oo, borderTopRightRadius: Oo, borderBottomLeftRadius: Oo, borderBottomRightRadius: Oo, boxShadow: $1 }, Ap = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], G1 = Ap.length, Np = t => typeof t == "string" ? parseFloat(t) : t, Mp = t => typeof t == "number" || pe.test(t); function Y1(t, r, o, s, l, d) { l ? (t.opacity = je(0, o.opacity !== void 0 ? o.opacity : 1, X1(s)), t.opacityExit = je(r.opacity !== void 0 ? r.opacity : 1, 0, Q1(s))) : d && (t.opacity = je(r.opacity !== void 0 ? r.opacity : 1, o.opacity !== void 0 ? o.opacity : 1, s)); for (let u = 0; u < G1; u++) { const f = `border${Ap[u]}Radius`; let h = Lp(r, f), m = Lp(o, f); if (h === void 0 && m === void 0) continue; h || (h = 0), m || (m = 0), h === 0 || m === 0 || Mp(h) === Mp(m) ? (t[f] = Math.max(je(Np(h), Np(m), s), 0), (Wt.test(m) || Wt.test(h)) && (t[f] += "%")) : t[f] = m } (r.rotate || o.rotate) && (t.rotate = je(r.rotate || 0, o.rotate || 0, s)) } function Lp(t, r) { return t[r] !== void 0 ? t[r] : t.borderRadius } const X1 = Dp(0, .5, Vf), Q1 = Dp(.5, .95, qe); function Dp(t, r, o) { return s => s < t ? 0 : s > r ? 1 : o(No(t, r, s)) } function jp(t, r) { t.min = r.min, t.max = r.max } function Pt(t, r) { jp(t.x, r.x), jp(t.y, r.y) } function Op(t, r) { t.translate = r.translate, t.scale = r.scale, t.originPoint = r.originPoint, t.origin = r.origin } function _p(t, r, o, s, l) { return t -= r, t = Yi(t, 1 / o, s), l !== void 0 && (t = Yi(t, 1 / l, s)), t } function q1(t, r = 0, o = 1, s = .5, l, d = t, u = t) { if (Wt.test(r) && (r = parseFloat(r), r = je(u.min, u.max, r / 100) - u.min), typeof r != "number") return; let f = je(d.min, d.max, s); t === d && (f -= r), t.min = _p(t.min, r, o, f, l), t.max = _p(t.max, r, o, f, l) } function Ip(t, r, [o, s, l], d, u) { q1(t, r[o], r[s], r[l], r.scale, d, u) } const Z1 = ["x", "scaleX", "originX"], J1 = ["y", "scaleY", "originY"]; function Vp(t, r, o, s) { Ip(t.x, r, Z1, o ? o.x : void 0, s ? s.x : void 0), Ip(t.y, r, J1, o ? o.y : void 0, s ? s.y : void 0) } function Fp(t) { return t.translate === 0 && t.scale === 1 } function zp(t) { return Fp(t.x) && Fp(t.y) } function Bp(t, r) { return t.min === r.min && t.max === r.max } function eS(t, r) { return Bp(t.x, r.x) && Bp(t.y, r.y) } function Up(t, r) { return Math.round(t.min) === Math.round(r.min) && Math.round(t.max) === Math.round(r.max) } function Wp(t, r) { return Up(t.x, r.x) && Up(t.y, r.y) } function $p(t) { return vt(t.x) / vt(t.y) } function Hp(t, r) { return t.translate === r.translate && t.scale === r.scale && t.originPoint === r.originPoint } class tS { constructor() { this.members = [] } add(r) { Fi(this.members, r), r.scheduleRender() } remove(r) { if (zi(this.members, r), r === this.prevLead && (this.prevLead = void 0), r === this.lead) { const o = this.members[this.members.length - 1]; o && this.promote(o) } } relegate(r) { const o = this.members.findIndex(l => r === l); if (o === 0) return !1; let s; for (let l = o; l >= 0; l--) { const d = this.members[l]; if (d.isPresent !== !1) { s = d; break } } return s ? (this.promote(s), !0) : !1 } promote(r, o) { const s = this.lead; if (r !== s && (this.prevLead = s, this.lead = r, r.show(), s)) { s.instance && s.scheduleRender(), r.scheduleRender(), r.resumeFrom = s, o && (r.resumeFrom.preserveOpacity = !0), s.snapshot && (r.snapshot = s.snapshot, r.snapshot.latestValues = s.animationValues || s.latestValues), r.root && r.root.isUpdating && (r.isLayoutDirty = !0); const { crossfade: l } = r.options; l === !1 && s.hide() } } exitAnimationComplete() { this.members.forEach(r => { const { options: o, resumingFrom: s } = r; o.onExitComplete && o.onExitComplete(), s && s.options.onExitComplete && s.options.onExitComplete() }) } scheduleRender() { this.members.forEach(r => { r.instance && r.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function nS(t, r, o) { let s = ""; const l = t.x.translate / r.x, d = t.y.translate / r.y, u = o?.z || 0; if ((l || d || u) && (s = `translate3d(${l}px, ${d}px, ${u}px) `), (r.x !== 1 || r.y !== 1) && (s += `scale(${1 / r.x}, ${1 / r.y}) `), o) { const { transformPerspective: m, rotate: v, rotateX: g, rotateY: w, skewX: C, skewY: b } = o; m && (s = `perspective(${m}px) ${s}`), v && (s += `rotate(${v}deg) `), g && (s += `rotateX(${g}deg) `), w && (s += `rotateY(${w}deg) `), C && (s += `skewX(${C}deg) `), b && (s += `skewY(${b}deg) `) } const f = t.x.scale * r.x, h = t.y.scale * r.y; return (f !== 1 || h !== 1) && (s += `scale(${f}, ${h})`), s || "none" } const rS = (t, r) => t.depth - r.depth; class oS { constructor() { this.children = [], this.isDirty = !1 } add(r) { Fi(this.children, r), this.isDirty = !0 } remove(r) { zi(this.children, r), this.isDirty = !0 } forEach(r) { this.isDirty && this.children.sort(rS), this.isDirty = !1, this.children.forEach(r) } } function iS(t, r) { const o = sn.now(), s = ({ timestamp: l }) => { const d = l - o; d >= r && (en(s), t(d - r)) }; return Te.read(s, !0), () => en(s) } function sS(t) { return t instanceof SVGElement && t.tagName !== "svg" } function aS(t, r, o) { const s = nt(t) ? t : Lo(t); return s.start(yl("", s, r, o)), s.animation } const or = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }, _o = typeof window < "u" && window.MotionDebug !== void 0, Rl = ["", "X", "Y", "Z"], lS = { visibility: "hidden" }, Kp = 1e3; let uS = 0; function Al(t, r, o, s) { const { latestValues: l } = r; l[t] && (o[t] = l[t], r.setStaticValue(t, 0), s && (s[t] = 0)) } function Gp(t) { if (t.hasCheckedOptimisedAppear = !0, t.root === t) return; const { visualElement: r } = t.options; if (!r) return; const o = Zf(r); window.MotionHasOptimisedTransformAnimation(o) && window.MotionCancelOptimisedTransform(o); const { parent: s } = t; s && !s.hasCheckedOptimisedAppear && Gp(s) } function Yp({ attachResizeListener: t, defaultParent: r, measureScroll: o, checkIsScrollRoot: s, resetTransform: l }) { return class { constructor(u = {}, f = r?.()) { this.id = uS++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, _o && (or.totalNodes = or.resolvedTargetDeltas = or.recalculatedProjection = 0), this.nodes.forEach(fS), this.nodes.forEach(vS), this.nodes.forEach(yS), this.nodes.forEach(pS), _o && window.MotionDebug.record(or) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = u, this.root = f ? f.root || f : this, this.path = f ? [...f.path, f] : [], this.parent = f, this.depth = f ? f.depth + 1 : 0; for (let h = 0; h < this.path.length; h++)this.path[h].shouldResetTransform = !0; this.root === this && (this.nodes = new oS) } addEventListener(u, f) { return this.eventHandlers.has(u) || this.eventHandlers.set(u, new wl), this.eventHandlers.get(u).add(f) } notifyListeners(u, ...f) { const h = this.eventHandlers.get(u); h && h.notify(...f) } hasListeners(u) { return this.eventHandlers.has(u) } mount(u, f = this.root.hasTreeAnimated) { if (this.instance) return; this.isSVG = sS(u), this.instance = u; const { layoutId: h, layout: m, visualElement: v } = this.options; if (v && !v.current && v.mount(u), this.root.nodes.add(this), this.parent && this.parent.children.add(this), f && (m || h) && (this.isLayoutDirty = !0), t) { let g; const w = () => this.root.updateBlockedByResize = !1; t(u, () => { this.root.updateBlockedByResize = !0, g && g(), g = iS(w, 250), Qi.hasAnimatedSinceResize && (Qi.hasAnimatedSinceResize = !1, this.nodes.forEach(Qp)) }) } h && this.root.registerSharedNode(h, this), this.options.animate !== !1 && v && (h || m) && this.addEventListener("didUpdate", ({ delta: g, hasLayoutChanged: w, hasRelativeTargetChanged: C, layout: b }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const S = this.options.transition || v.getDefaultTransition() || bS, { onLayoutAnimationStart: P, onLayoutAnimationComplete: R } = v.getProps(), N = !this.targetLayout || !Wp(this.targetLayout, b) || C, L = !w && C; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || L || w && (N || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(g, L); const j = { ...Ja(S, "layout"), onPlay: P, onComplete: R }; (v.shouldReduceMotion || this.options.layoutRoot) && (j.delay = 0, j.type = !1), this.startAnimation(j) } else w || Qp(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = b }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const u = this.getStack(); u && u.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, en(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(wS), this.animationId++) } getTransformTemplate() { const { visualElement: u } = this.options; return u && u.getProps().transformTemplate } willUpdate(u = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedTransform && !this.hasCheckedOptimisedAppear && Gp(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let v = 0; v < this.path.length; v++) { const g = this.path[v]; g.shouldResetTransform = !0, g.updateScroll("snapshot"), g.options.layoutRoot && g.willUpdate(!1) } const { layoutId: f, layout: h } = this.options; if (f === void 0 && !h) return; const m = this.getTransformTemplate(); this.prevTransformTemplateValue = m ? m(this.latestValues, "") : void 0, this.updateSnapshot(), u && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Xp); return } this.isUpdating || this.nodes.forEach(mS), this.isUpdating = !1, this.nodes.forEach(gS), this.nodes.forEach(cS), this.nodes.forEach(dS), this.clearAllSnapshots(); const f = sn.now(); Ze.delta = bn(0, 1e3 / 60, f - Ze.timestamp), Ze.timestamp = f, Ze.isProcessing = !0, Xa.update.process(Ze), Xa.preRender.process(Ze), Xa.render.process(Ze), Ze.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, Da.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(hS), this.sharedNodes.forEach(xS) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Te.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { Te.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let h = 0; h < this.path.length; h++)this.path[h].updateScroll(); const u = this.layout; this.layout = this.measure(!1), this.layoutCorrected = Fe(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: f } = this.options; f && f.notify("LayoutMeasure", this.layout.layoutBox, u ? u.layoutBox : void 0) } updateScroll(u = "measure") { let f = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === u && (f = !1), f) { const h = s(this.instance); this.scroll = { animationId: this.root.animationId, phase: u, isRoot: h, offset: o(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : h } } } resetTransform() { if (!l) return; const u = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, f = this.projectionDelta && !zp(this.projectionDelta), h = this.getTransformTemplate(), m = h ? h(this.latestValues, "") : void 0, v = m !== this.prevTransformTemplateValue; u && (f || rr(this.latestValues) || v) && (l(this.instance, m), this.shouldResetTransform = !1, this.scheduleRender()) } measure(u = !0) { const f = this.measurePageBox(); let h = this.removeElementScroll(f); return u && (h = this.removeTransform(h)), kS(h), { animationId: this.root.animationId, measuredBox: f, layoutBox: h, latestValues: {}, source: this.id } } measurePageBox() { var u; const { visualElement: f } = this.options; if (!f) return Fe(); const h = f.measureViewportBox(); if (!(((u = this.scroll) === null || u === void 0 ? void 0 : u.wasRoot) || this.path.some(PS))) { const { scroll: v } = this.root; v && (Nr(h.x, v.offset.x), Nr(h.y, v.offset.y)) } return h } removeElementScroll(u) { var f; const h = Fe(); if (Pt(h, u), !((f = this.scroll) === null || f === void 0) && f.wasRoot) return h; for (let m = 0; m < this.path.length; m++) { const v = this.path[m], { scroll: g, options: w } = v; v !== this.root && g && w.layoutScroll && (g.wasRoot && Pt(h, u), Nr(h.x, g.offset.x), Nr(h.y, g.offset.y)) } return h } applyTransform(u, f = !1) { const h = Fe(); Pt(h, u); for (let m = 0; m < this.path.length; m++) { const v = this.path[m]; !f && v.options.layoutScroll && v.scroll && v !== v.root && Mr(h, { x: -v.scroll.offset.x, y: -v.scroll.offset.y }), rr(v.latestValues) && Mr(h, v.latestValues) } return rr(this.latestValues) && Mr(h, this.latestValues), h } removeTransform(u) { const f = Fe(); Pt(f, u); for (let h = 0; h < this.path.length; h++) { const m = this.path[h]; if (!m.instance || !rr(m.latestValues)) continue; El(m.latestValues) && m.updateSnapshot(); const v = Fe(), g = m.measurePageBox(); Pt(v, g), Vp(f, m.latestValues, m.snapshot ? m.snapshot.layoutBox : void 0, v) } return rr(this.latestValues) && Vp(f, this.latestValues), f } setTargetDelta(u) { this.targetDelta = u, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(u) { this.options = { ...this.options, ...u, crossfade: u.crossfade !== void 0 ? u.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Ze.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(u = !1) { var f; const h = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = h.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = h.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = h.isSharedProjectionDirty); const m = !!this.resumingFrom || this !== h; if (!(u || m && this.isSharedProjectionDirty || this.isProjectionDirty || !((f = this.parent) === null || f === void 0) && f.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: g, layoutId: w } = this.options; if (!(!this.layout || !(g || w))) { if (this.resolvedRelativeTargetAt = Ze.timestamp, !this.targetDelta && !this.relativeTarget) { const C = this.getClosestProjectingParent(); C && C.layout && this.animationProgress !== 1 ? (this.relativeParent = C, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Fe(), this.relativeTargetOrigin = Fe(), jo(this.relativeTargetOrigin, this.layout.layoutBox, C.layout.layoutBox), Pt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = Fe(), this.targetWithTransforms = Fe()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), T1(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Pt(this.target, this.layout.layoutBox), xp(this.target, this.targetDelta)) : Pt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; const C = this.getClosestProjectingParent(); C && !!C.resumingFrom == !!this.resumingFrom && !C.options.layoutScroll && C.target && this.animationProgress !== 1 ? (this.relativeParent = C, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Fe(), this.relativeTargetOrigin = Fe(), jo(this.relativeTargetOrigin, this.target, C.target), Pt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } _o && or.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || El(this.parent.latestValues) || vp(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var u; const f = this.getLead(), h = !!this.resumingFrom || this !== f; let m = !0; if ((this.isProjectionDirty || !((u = this.parent) === null || u === void 0) && u.isProjectionDirty) && (m = !1), h && (this.isSharedProjectionDirty || this.isTransformDirty) && (m = !1), this.resolvedRelativeTargetAt === Ze.timestamp && (m = !1), m) return; const { layout: v, layoutId: g } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(v || g)) return; Pt(this.layoutCorrected, this.layout.layoutBox); const w = this.treeScale.x, C = this.treeScale.y; _1(this.layoutCorrected, this.treeScale, this.path, h), f.layout && !f.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (f.target = f.layout.layoutBox, f.targetWithTransforms = Fe()); const { target: b } = f; if (!b) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Op(this.prevProjectionDelta.x, this.projectionDelta.x), Op(this.prevProjectionDelta.y, this.projectionDelta.y)), Do(this.projectionDelta, this.layoutCorrected, b, this.latestValues), (this.treeScale.x !== w || this.treeScale.y !== C || !Hp(this.projectionDelta.x, this.prevProjectionDelta.x) || !Hp(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", b)), _o && or.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(u = !0) { var f; if ((f = this.options.visualElement) === null || f === void 0 || f.scheduleRender(), u) { const h = this.getStack(); h && h.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = Ar(), this.projectionDelta = Ar(), this.projectionDeltaWithTransform = Ar() } setAnimationOrigin(u, f = !1) { const h = this.snapshot, m = h ? h.latestValues : {}, v = { ...this.latestValues }, g = Ar(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !f; const w = Fe(), C = h ? h.source : void 0, b = this.layout ? this.layout.source : void 0, S = C !== b, P = this.getStack(), R = !P || P.members.length <= 1, N = !!(S && !R && this.options.crossfade === !0 && !this.path.some(CS)); this.animationProgress = 0; let L; this.mixTargetDelta = j => { const I = j / 1e3; qp(g.x, u.x, I), qp(g.y, u.y, I), this.setTargetDelta(g), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (jo(w, this.layout.layoutBox, this.relativeParent.layout.layoutBox), SS(this.relativeTarget, this.relativeTargetOrigin, w, I), L && eS(this.relativeTarget, L) && (this.isProjectionDirty = !1), L || (L = Fe()), Pt(L, this.relativeTarget)), S && (this.animationValues = v, Y1(v, m, this.latestValues, I, N, R)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = I }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(u) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (en(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Te.update(() => { Qi.hasAnimatedSinceResize = !0, this.currentAnimation = aS(0, Kp, { ...u, onUpdate: f => { this.mixTargetDelta(f), u.onUpdate && u.onUpdate(f) }, onComplete: () => { u.onComplete && u.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const u = this.getStack(); u && u.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Kp), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const u = this.getLead(); let { targetWithTransforms: f, target: h, layout: m, latestValues: v } = u; if (!(!f || !h || !m)) { if (this !== u && this.layout && m && nh(this.options.animationType, this.layout.layoutBox, m.layoutBox)) { h = this.target || Fe(); const g = vt(this.layout.layoutBox.x); h.x.min = u.target.x.min, h.x.max = h.x.min + g; const w = vt(this.layout.layoutBox.y); h.y.min = u.target.y.min, h.y.max = h.y.min + w } Pt(f, h), Mr(f, v), Do(this.projectionDeltaWithTransform, this.layoutCorrected, f, v) } } registerSharedNode(u, f) { this.sharedNodes.has(u) || this.sharedNodes.set(u, new tS), this.sharedNodes.get(u).add(f); const m = f.options.initialPromotionConfig; f.promote({ transition: m ? m.transition : void 0, preserveFollowOpacity: m && m.shouldPreserveFollowOpacity ? m.shouldPreserveFollowOpacity(f) : void 0 }) } isLead() { const u = this.getStack(); return u ? u.lead === this : !0 } getLead() { var u; const { layoutId: f } = this.options; return f ? ((u = this.getStack()) === null || u === void 0 ? void 0 : u.lead) || this : this } getPrevLead() { var u; const { layoutId: f } = this.options; return f ? (u = this.getStack()) === null || u === void 0 ? void 0 : u.prevLead : void 0 } getStack() { const { layoutId: u } = this.options; if (u) return this.root.sharedNodes.get(u) } promote({ needsReset: u, transition: f, preserveFollowOpacity: h } = {}) { const m = this.getStack(); m && m.promote(this, h), u && (this.projectionDelta = void 0, this.needsReset = !0), f && this.setOptions({ transition: f }) } relegate() { const u = this.getStack(); return u ? u.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: u } = this.options; if (!u) return; let f = !1; const { latestValues: h } = u; if ((h.z || h.rotate || h.rotateX || h.rotateY || h.rotateZ || h.skewX || h.skewY) && (f = !0), !f) return; const m = {}; h.z && Al("z", u, m, this.animationValues); for (let v = 0; v < Rl.length; v++)Al(`rotate${Rl[v]}`, u, m, this.animationValues), Al(`skew${Rl[v]}`, u, m, this.animationValues); u.render(); for (const v in m) u.setStaticValue(v, m[v]), this.animationValues && (this.animationValues[v] = m[v]); u.scheduleRender() } getProjectionStyles(u) { var f, h; if (!this.instance || this.isSVG) return; if (!this.isVisible) return lS; const m = { visibility: "" }, v = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, m.opacity = "", m.pointerEvents = Vi(u?.pointerEvents) || "", m.transform = v ? v(this.latestValues, "") : "none", m; const g = this.getLead(); if (!this.projectionDelta || !this.layout || !g.target) { const S = {}; return this.options.layoutId && (S.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, S.pointerEvents = Vi(u?.pointerEvents) || ""), this.hasProjected && !rr(this.latestValues) && (S.transform = v ? v({}, "") : "none", this.hasProjected = !1), S } const w = g.animationValues || g.latestValues; this.applyTransformsToTarget(), m.transform = nS(this.projectionDeltaWithTransform, this.treeScale, w), v && (m.transform = v(w, m.transform)); const { x: C, y: b } = this.projectionDelta; m.transformOrigin = `${C.origin * 100}% ${b.origin * 100}% 0`, g.animationValues ? m.opacity = g === this ? (h = (f = w.opacity) !== null && f !== void 0 ? f : this.latestValues.opacity) !== null && h !== void 0 ? h : 1 : this.preserveOpacity ? this.latestValues.opacity : w.opacityExit : m.opacity = g === this ? w.opacity !== void 0 ? w.opacity : "" : w.opacityExit !== void 0 ? w.opacityExit : 0; for (const S in Oi) { if (w[S] === void 0) continue; const { correct: P, applyTo: R } = Oi[S], N = m.transform === "none" ? w[S] : P(w[S], g); if (R) { const L = R.length; for (let j = 0; j < L; j++)m[R[j]] = N } else m[S] = N } return this.options.layoutId && (m.pointerEvents = g === this ? Vi(u?.pointerEvents) || "" : "none"), m } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(u => { var f; return (f = u.currentAnimation) === null || f === void 0 ? void 0 : f.stop() }), this.root.nodes.forEach(Xp), this.root.sharedNodes.clear() } } } function cS(t) { t.updateLayout() } function dS(t) { var r; const o = ((r = t.resumeFrom) === null || r === void 0 ? void 0 : r.snapshot) || t.snapshot; if (t.isLead() && t.layout && o && t.hasListeners("didUpdate")) { const { layoutBox: s, measuredBox: l } = t.layout, { animationType: d } = t.options, u = o.source !== t.layout.source; d === "size" ? kt(g => { const w = u ? o.measuredBox[g] : o.layoutBox[g], C = vt(w); w.min = s[g].min, w.max = w.min + C }) : nh(d, o.layoutBox, s) && kt(g => { const w = u ? o.measuredBox[g] : o.layoutBox[g], C = vt(s[g]); w.max = w.min + C, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[g].max = t.relativeTarget[g].min + C) }); const f = Ar(); Do(f, s, o.layoutBox); const h = Ar(); u ? Do(h, t.applyTransform(l, !0), o.measuredBox) : Do(h, s, o.layoutBox); const m = !zp(f); let v = !1; if (!t.resumeFrom) { const g = t.getClosestProjectingParent(); if (g && !g.resumeFrom) { const { snapshot: w, layout: C } = g; if (w && C) { const b = Fe(); jo(b, o.layoutBox, w.layoutBox); const S = Fe(); jo(S, s, C.layoutBox), Wp(b, S) || (v = !0), g.options.layoutRoot && (t.relativeTarget = S, t.relativeTargetOrigin = b, t.relativeParent = g) } } } t.notifyListeners("didUpdate", { layout: s, snapshot: o, delta: h, layoutDelta: f, hasLayoutChanged: m, hasRelativeTargetChanged: v }) } else if (t.isLead()) { const { onExitComplete: s } = t.options; s && s() } t.options.transition = void 0 } function fS(t) { _o && or.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty)) } function pS(t) { t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1 } function hS(t) { t.clearSnapshot() } function Xp(t) { t.clearMeasurements() } function mS(t) { t.isLayoutDirty = !1 } function gS(t) { const { visualElement: r } = t.options; r && r.getProps().onBeforeLayoutMeasure && r.notify("BeforeLayoutMeasure"), t.resetTransform() } function Qp(t) { t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0 } function vS(t) { t.resolveTargetDelta() } function yS(t) { t.calcProjection() } function wS(t) { t.resetSkewAndRotation() } function xS(t) { t.removeLeadSnapshot() } function qp(t, r, o) { t.translate = je(r.translate, 0, o), t.scale = je(r.scale, 1, o), t.origin = r.origin, t.originPoint = r.originPoint } function Zp(t, r, o, s) { t.min = je(r.min, o.min, s), t.max = je(r.max, o.max, s) } function SS(t, r, o, s) { Zp(t.x, r.x, o.x, s), Zp(t.y, r.y, o.y, s) } function CS(t) { return t.animationValues && t.animationValues.opacityExit !== void 0 } const bS = { duration: .45, ease: [.4, 0, .1, 1] }, Jp = t => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), eh = Jp("applewebkit/") && !Jp("chrome/") ? Math.round : qe; function th(t) { t.min = eh(t.min), t.max = eh(t.max) } function kS(t) { th(t.x), th(t.y) } function nh(t, r, o) { return t === "position" || t === "preserve-aspect" && !E1($p(r), $p(o), .2) } function PS(t) { var r; return t !== t.root && ((r = t.scroll) === null || r === void 0 ? void 0 : r.wasRoot) } const ES = Yp({ attachResizeListener: (t, r) => tn(t, "resize", r), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Nl = { current: void 0 }, rh = Yp({ measureScroll: t => ({ x: t.scrollLeft, y: t.scrollTop }), defaultParent: () => { if (!Nl.current) { const t = new ES({}); t.mount(window), t.setOptions({ layoutScroll: !0 }), Nl.current = t } return Nl.current }, resetTransform: (t, r) => { t.style.transform = r !== void 0 ? r : "none" }, checkIsScrollRoot: t => window.getComputedStyle(t).position === "fixed" }), TS = { pan: { Feature: U1 }, drag: { Feature: B1, ProjectionNode: rh, MeasureLayout: Rp } }, Ml = { current: null }, oh = { current: !1 }; function RS() { if (oh.current = !0, !!La) if (window.matchMedia) { const t = window.matchMedia("(prefers-reduced-motion)"), r = () => Ml.current = t.matches; t.addListener(r), r() } else Ml.current = !1 } function AS(t, r, o) { for (const s in r) { const l = r[s], d = o[s]; if (nt(l)) t.addValue(s, l); else if (nt(d)) t.addValue(s, Lo(l, { owner: t })); else if (d !== l) if (t.hasValue(s)) { const u = t.getValue(s); u.liveStyle === !0 ? u.jump(l) : u.hasAnimated || u.set(l) } else { const u = t.getStaticValue(s); t.addValue(s, Lo(u !== void 0 ? u : l, { owner: t })) } } for (const s in o) r[s] === void 0 && t.removeValue(s); return r } const ih = new WeakMap, NS = [...pf, rt, En], MS = t => NS.find(ff(t)), sh = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"], LS = Oa.length; class DS { scrapeMotionValuesFromProps(r, o, s) { return {} } constructor({ parent: r, props: o, presenceContext: s, reducedMotionConfig: l, blockInitialAnimation: d, visualState: u }, f = {}) { this.applyWillChange = !1, this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = nl, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.isRenderScheduled = !1, this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.isRenderScheduled = !1, this.scheduleRender = () => { this.isRenderScheduled || (this.isRenderScheduled = !0, Te.render(this.render, !1, !0)) }; const { latestValues: h, renderState: m } = u; this.latestValues = h, this.baseTarget = { ...h }, this.initialValues = o.initial ? { ...h } : {}, this.renderState = m, this.parent = r, this.props = o, this.presenceContext = s, this.depth = r ? r.depth + 1 : 0, this.reducedMotionConfig = l, this.options = f, this.blockInitialAnimation = !!d, this.isControllingVariants = ji(o), this.isVariantNode = Td(o), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(r && r.current); const { willChange: v, ...g } = this.scrapeMotionValuesFromProps(o, {}, this); for (const w in g) { const C = g[w]; h[w] !== void 0 && nt(C) && C.set(h[w], !1) } } mount(r) { this.current = r, ih.set(r, this), this.projection && !this.projection.instance && this.projection.mount(r), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((o, s) => this.bindToMotionValue(s, o)), oh.current || RS(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Ml.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { ih.delete(this.current), this.projection && this.projection.unmount(), en(this.notifyUpdate), en(this.render), this.valueSubscriptions.forEach(r => r()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const r in this.events) this.events[r].clear(); for (const r in this.features) { const o = this.features[r]; o && (o.unmount(), o.isMounted = !1) } this.current = null } bindToMotionValue(r, o) { const s = Cn.has(r), l = o.on("change", u => { this.latestValues[r] = u, this.props.onUpdate && Te.preRender(this.notifyUpdate), s && this.projection && (this.projection.isTransformDirty = !0) }), d = o.on("renderRequest", this.scheduleRender); this.valueSubscriptions.set(r, () => { l(), d(), o.owner && o.stop() }) } sortNodePosition(r) { return !this.current || !this.sortInstanceNodePosition || this.type !== r.type ? 0 : this.sortInstanceNodePosition(this.current, r.current) } updateFeatures() { let r = "animation"; for (r in Pr) { const o = Pr[r]; if (!o) continue; const { isEnabled: s, Feature: l } = o; if (!this.features[r] && l && s(this.props) && (this.features[r] = new l(this)), this.features[r]) { const d = this.features[r]; d.isMounted ? d.update() : (d.mount(), d.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Fe() } getStaticValue(r) { return this.latestValues[r] } setStaticValue(r, o) { this.latestValues[r] = o } update(r, o) { (r.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = r, this.prevPresenceContext = this.presenceContext, this.presenceContext = o; for (let s = 0; s < sh.length; s++) { const l = sh[s]; this.propEventSubscriptions[l] && (this.propEventSubscriptions[l](), delete this.propEventSubscriptions[l]); const d = "on" + l, u = r[d]; u && (this.propEventSubscriptions[l] = this.on(l, u)) } this.prevMotionValues = AS(this, this.scrapeMotionValuesFromProps(r, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(r) { return this.props.variants ? this.props.variants[r] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } getVariantContext(r = !1) { if (r) return this.parent ? this.parent.getVariantContext() : void 0; if (!this.isControllingVariants) { const s = this.parent ? this.parent.getVariantContext() || {} : {}; return this.props.initial !== void 0 && (s.initial = this.props.initial), s } const o = {}; for (let s = 0; s < LS; s++) { const l = Oa[s], d = this.props[l]; (So(d) || d === !1) && (o[l] = d) } return o } addVariantChild(r) { const o = this.getClosestVariantNode(); if (o) return o.variantChildren && o.variantChildren.add(r), () => o.variantChildren.delete(r) } addValue(r, o) { const s = this.values.get(r); o !== s && (s && this.removeValue(r), this.bindToMotionValue(r, o), this.values.set(r, o), this.latestValues[r] = o.get()) } removeValue(r) { this.values.delete(r); const o = this.valueSubscriptions.get(r); o && (o(), this.valueSubscriptions.delete(r)), delete this.latestValues[r], this.removeValueFromRenderState(r, this.renderState) } hasValue(r) { return this.values.has(r) } getValue(r, o) { if (this.props.values && this.props.values[r]) return this.props.values[r]; let s = this.values.get(r); return s === void 0 && o !== void 0 && (s = Lo(o === null ? void 0 : o, { owner: this }), this.addValue(r, s)), s } readValue(r, o) { var s; let l = this.latestValues[r] !== void 0 || !this.current ? this.latestValues[r] : (s = this.getBaseTargetFromProps(this.props, r)) !== null && s !== void 0 ? s : this.readValueFromInstance(this.current, r, this.options); return l != null && (typeof l == "string" && (af(l) || sf(l)) ? l = parseFloat(l) : !MS(l) && En.test(o) && (l = bf(r, o)), this.setBaseTarget(r, nt(l) ? l.get() : l)), nt(l) ? l.get() : l } setBaseTarget(r, o) { this.baseTarget[r] = o } getBaseTarget(r) { var o; const { initial: s } = this.props; let l; if (typeof s == "string" || typeof s == "object") { const u = Ka(this.props, s, (o = this.presenceContext) === null || o === void 0 ? void 0 : o.custom); u && (l = u[r]) } if (s && l !== void 0) return l; const d = this.getBaseTargetFromProps(this.props, r); return d !== void 0 && !nt(d) ? d : this.initialValues[r] !== void 0 && l === void 0 ? void 0 : this.baseTarget[r] } on(r, o) { return this.events[r] || (this.events[r] = new wl), this.events[r].add(o) } notify(r, ...o) { this.events[r] && this.events[r].notify(...o) } } class ah extends DS { constructor() { super(...arguments), this.KeyframeResolver = kf } sortInstanceNodePosition(r, o) { return r.compareDocumentPosition(o) & 2 ? 1 : -1 } getBaseTargetFromProps(r, o) { return r.style ? r.style[o] : void 0 } removeValueFromRenderState(r, { vars: o, style: s }) { delete o[r], delete s[r] } } function jS(t) { return window.getComputedStyle(t) } class OS extends ah { constructor() { super(...arguments), this.type = "html", this.applyWillChange = !0, this.renderInstance = Bd } readValueFromInstance(r, o) { if (Cn.has(o)) { const s = al(o); return s && s.default || 0 } else { const s = jS(r), l = (_d(o) ? s.getPropertyValue(o) : s[o]) || 0; return typeof l == "string" ? l.trim() : l } } measureInstanceViewportBox(r, { transformPagePoint: o }) { return kp(r, o) } build(r, o, s) { Ba(r, o, s.transformTemplate) } scrapeMotionValuesFromProps(r, o, s) { return Ha(r, o, s) } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: r } = this.props; nt(r) && (this.childSubscription = r.on("change", o => { this.current && (this.current.textContent = `${o}`) })) } } class _S extends ah { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Fe } getBaseTargetFromProps(r, o) { return r[o] } readValueFromInstance(r, o) { if (Cn.has(o)) { const s = al(o); return s && s.default || 0 } return o = Ud.has(o) ? o : Li(o), r.getAttribute(o) } scrapeMotionValuesFromProps(r, o, s) { return $d(r, o, s) } build(r, o, s) { Wa(r, o, this.isSVGTag, s.transformTemplate) } renderInstance(r, o, s, l) { Wd(r, o, s, l) } mount(r) { this.isSVGTag = $a(r.tagName), super.mount(r) } } const IS = (t, r) => Ia(t) ? new _S(r) : new OS(r, { allowProjection: t !== x.Fragment }), VS = { ...y1, ...Aw, ...TS, ...{ layout: { ProjectionNode: rh, MeasureLayout: Rp } } }, ir = V0((t, r) => gw(t, r, VS, IS)); class FS extends x.Component { getSnapshotBeforeUpdate(r) { const o = this.props.childRef.current; if (o && r.isPresent && !this.props.isPresent) { const s = this.props.sizeRef.current; s.height = o.offsetHeight || 0, s.width = o.offsetWidth || 0, s.top = o.offsetTop, s.left = o.offsetLeft } return null } componentDidUpdate() { } render() { return this.props.children } } function zS({ children: t, isPresent: r }) {
    const o = x.useId(), s = x.useRef(null), l = x.useRef({ width: 0, height: 0, top: 0, left: 0 }), { nonce: d } = x.useContext(Ma); return x.useInsertionEffect(() => {
      const { width: u, height: f, top: h, left: m } = l.current; if (r || !s.current || !u || !f) return; s.current.dataset.motionPopId = o; const v = document.createElement("style"); return d && (v.nonce = d), document.head.appendChild(v), v.sheet && v.sheet.insertRule(`
          [data-motion-pop-id="${o}"] {
            position: absolute !important;
            width: ${u}px !important;
            height: ${f}px !important;
            top: ${h}px !important;
            left: ${m}px !important;
          }
        `), () => { document.head.removeChild(v) }
    }, [r]), T.jsx(FS, { isPresent: r, childRef: s, sizeRef: l, children: x.cloneElement(t, { ref: s }) })
  } const BS = ({ children: t, initial: r, isPresent: o, onExitComplete: s, custom: l, presenceAffectsLayout: d, mode: u }) => { const f = Ga(US), h = x.useId(), m = x.useMemo(() => ({ id: h, initial: r, isPresent: o, custom: l, onExitComplete: v => { f.set(v, !0); for (const g of f.values()) if (!g) return; s && s() }, register: v => (f.set(v, !1), () => f.delete(v)) }), d ? [Math.random()] : [o]); return x.useMemo(() => { f.forEach((v, g) => f.set(g, !1)) }, [o]), x.useEffect(() => { !o && !f.size && s && s() }, [o]), u === "popLayout" && (t = T.jsx(zS, { isPresent: o, children: t })), T.jsx(Mi.Provider, { value: m, children: t }) }; function US() { return new Map } const qi = t => t.key || ""; function lh(t) { const r = []; return x.Children.forEach(t, o => { x.isValidElement(o) && r.push(o) }), r } const WS = ({ children: t, exitBeforeEnter: r, custom: o, initial: s = !0, onExitComplete: l, presenceAffectsLayout: d = !0, mode: u = "sync" }) => { const f = x.useMemo(() => lh(t), [t]), h = f.map(qi), m = x.useRef(!0), v = x.useRef(f), g = Ga(() => new Map), [w, C] = x.useState(f), [b, S] = x.useState(f); xd(() => { m.current = !1, v.current = f; for (let N = 0; N < b.length; N++) { const L = qi(b[N]); h.includes(L) ? g.delete(L) : g.get(L) !== !0 && g.set(L, !1) } }, [b, h.length, h.join("-")]); const P = []; if (f !== w) { let N = [...f]; for (let L = 0; L < b.length; L++) { const j = b[L], I = qi(j); h.includes(I) || (N.splice(L, 0, j), P.push(j)) } u === "wait" && P.length && (N = P), S(lh(N)), C(f); return } const { forceRender: R } = x.useContext(_a); return T.jsx(T.Fragment, { children: b.map(N => { const L = qi(N), j = f === b || h.includes(L), I = () => { if (g.has(L)) g.set(L, !0); else return; let K = !0; g.forEach(H => { H || (K = !1) }), K && (R?.(), S(v.current), l && l()) }; return T.jsx(BS, { isPresent: j, initial: !m.current || s ? void 0 : !1, custom: j ? void 0 : o, presenceAffectsLayout: d, mode: u, onExitComplete: j ? void 0 : I, children: N }, L) }) }) }, Ll = "-", $S = t => { const r = KS(t), { conflictingClassGroups: o, conflictingClassGroupModifiers: s } = t; return { getClassGroupId: u => { const f = u.split(Ll); return f[0] === "" && f.length !== 1 && f.shift(), uh(f, r) || HS(u) }, getConflictingClassGroupIds: (u, f) => { const h = o[u] || []; return f && s[u] ? [...h, ...s[u]] : h } } }, uh = (t, r) => { if (t.length === 0) return r.classGroupId; const o = t[0], s = r.nextPart.get(o), l = s ? uh(t.slice(1), s) : void 0; if (l) return l; if (r.validators.length === 0) return; const d = t.join(Ll); return r.validators.find(({ validator: u }) => u(d))?.classGroupId }, ch = /^\[(.+)\]$/, HS = t => { if (ch.test(t)) { const r = ch.exec(t)[1], o = r?.substring(0, r.indexOf(":")); if (o) return "arbitrary.." + o } }, KS = t => { const { theme: r, prefix: o } = t, s = { nextPart: new Map, validators: [] }; return YS(Object.entries(t.classGroups), o).forEach(([d, u]) => { Dl(u, s, d, r) }), s }, Dl = (t, r, o, s) => { t.forEach(l => { if (typeof l == "string") { const d = l === "" ? r : dh(r, l); d.classGroupId = o; return } if (typeof l == "function") { if (GS(l)) { Dl(l(s), r, o, s); return } r.validators.push({ validator: l, classGroupId: o }); return } Object.entries(l).forEach(([d, u]) => { Dl(u, dh(r, d), o, s) }) }) }, dh = (t, r) => { let o = t; return r.split(Ll).forEach(s => { o.nextPart.has(s) || o.nextPart.set(s, { nextPart: new Map, validators: [] }), o = o.nextPart.get(s) }), o }, GS = t => t.isThemeGetter, YS = (t, r) => r ? t.map(([o, s]) => { const l = s.map(d => typeof d == "string" ? r + d : typeof d == "object" ? Object.fromEntries(Object.entries(d).map(([u, f]) => [r + u, f])) : d); return [o, l] }) : t, XS = t => { if (t < 1) return { get: () => { }, set: () => { } }; let r = 0, o = new Map, s = new Map; const l = (d, u) => { o.set(d, u), r++, r > t && (r = 0, s = o, o = new Map) }; return { get(d) { let u = o.get(d); if (u !== void 0) return u; if ((u = s.get(d)) !== void 0) return l(d, u), u }, set(d, u) { o.has(d) ? o.set(d, u) : l(d, u) } } }, fh = "!", QS = t => { const { separator: r, experimentalParseClassName: o } = t, s = r.length === 1, l = r[0], d = r.length, u = f => { const h = []; let m = 0, v = 0, g; for (let P = 0; P < f.length; P++) { let R = f[P]; if (m === 0) { if (R === l && (s || f.slice(P, P + d) === r)) { h.push(f.slice(v, P)), v = P + d; continue } if (R === "/") { g = P; continue } } R === "[" ? m++ : R === "]" && m-- } const w = h.length === 0 ? f : f.substring(v), C = w.startsWith(fh), b = C ? w.substring(1) : w, S = g && g > v ? g - v : void 0; return { modifiers: h, hasImportantModifier: C, baseClassName: b, maybePostfixModifierPosition: S } }; return o ? f => o({ className: f, parseClassName: u }) : u }, qS = t => { if (t.length <= 1) return t; const r = []; let o = []; return t.forEach(s => { s[0] === "[" ? (r.push(...o.sort(), s), o = []) : o.push(s) }), r.push(...o.sort()), r }, ZS = t => ({ cache: XS(t.cacheSize), parseClassName: QS(t), ...$S(t) }), JS = /\s+/, eC = (t, r) => { const { parseClassName: o, getClassGroupId: s, getConflictingClassGroupIds: l } = r, d = [], u = t.trim().split(JS); let f = ""; for (let h = u.length - 1; h >= 0; h -= 1) { const m = u[h], { modifiers: v, hasImportantModifier: g, baseClassName: w, maybePostfixModifierPosition: C } = o(m); let b = !!C, S = s(b ? w.substring(0, C) : w); if (!S) { if (!b) { f = m + (f.length > 0 ? " " + f : f); continue } if (S = s(w), !S) { f = m + (f.length > 0 ? " " + f : f); continue } b = !1 } const P = qS(v).join(":"), R = g ? P + fh : P, N = R + S; if (d.includes(N)) continue; d.push(N); const L = l(S, b); for (let j = 0; j < L.length; ++j) { const I = L[j]; d.push(R + I) } f = m + (f.length > 0 ? " " + f : f) } return f }; function tC() { let t = 0, r, o, s = ""; for (; t < arguments.length;)(r = arguments[t++]) && (o = ph(r)) && (s && (s += " "), s += o); return s } const ph = t => { if (typeof t == "string") return t; let r, o = ""; for (let s = 0; s < t.length; s++)t[s] && (r = ph(t[s])) && (o && (o += " "), o += r); return o }; function nC(t, ...r) { let o, s, l, d = u; function u(h) { const m = r.reduce((v, g) => g(v), t()); return o = ZS(m), s = o.cache.get, l = o.cache.set, d = f, f(h) } function f(h) { const m = s(h); if (m) return m; const v = eC(h, o); return l(h, v), v } return function () { return d(tC.apply(null, arguments)) } } const Ne = t => { const r = o => o[t] || []; return r.isThemeGetter = !0, r }, hh = /^\[(?:([a-z-]+):)?(.+)\]$/i, rC = /^\d+\/\d+$/, oC = new Set(["px", "full", "screen"]), iC = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, sC = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, aC = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, lC = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, uC = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, an = t => Lr(t) || oC.has(t) || rC.test(t), Tn = t => Dr(t, "length", vC), Lr = t => !!t && !Number.isNaN(Number(t)), jl = t => Dr(t, "number", Lr), Io = t => !!t && Number.isInteger(Number(t)), cC = t => t.endsWith("%") && Lr(t.slice(0, -1)), we = t => hh.test(t), Rn = t => iC.test(t), dC = new Set(["length", "size", "percentage"]), fC = t => Dr(t, dC, mh), pC = t => Dr(t, "position", mh), hC = new Set(["image", "url"]), mC = t => Dr(t, hC, wC), gC = t => Dr(t, "", yC), Vo = () => !0, Dr = (t, r, o) => { const s = hh.exec(t); return s ? s[1] ? typeof r == "string" ? s[1] === r : r.has(s[1]) : o(s[2]) : !1 }, vC = t => sC.test(t) && !aC.test(t), mh = () => !1, yC = t => lC.test(t), wC = t => uC.test(t), ot = nC(() => { const t = Ne("colors"), r = Ne("spacing"), o = Ne("blur"), s = Ne("brightness"), l = Ne("borderColor"), d = Ne("borderRadius"), u = Ne("borderSpacing"), f = Ne("borderWidth"), h = Ne("contrast"), m = Ne("grayscale"), v = Ne("hueRotate"), g = Ne("invert"), w = Ne("gap"), C = Ne("gradientColorStops"), b = Ne("gradientColorStopPositions"), S = Ne("inset"), P = Ne("margin"), R = Ne("opacity"), N = Ne("padding"), L = Ne("saturate"), j = Ne("scale"), I = Ne("sepia"), K = Ne("skew"), H = Ne("space"), W = Ne("translate"), le = () => ["auto", "contain", "none"], ie = () => ["auto", "hidden", "clip", "visible", "scroll"], ge = () => ["auto", we, r], J = () => [we, r], Se = () => ["", an, Tn], ne = () => ["auto", Lr, we], oe = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], ue = () => ["solid", "dashed", "dotted", "double", "none"], G = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], F = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], Y = () => ["", "0", we], X = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], E = () => [Lr, we]; return { cacheSize: 500, separator: ":", theme: { colors: [Vo], spacing: [an, Tn], blur: ["none", "", Rn, we], brightness: E(), borderColor: [t], borderRadius: ["none", "", "full", Rn, we], borderSpacing: J(), borderWidth: Se(), contrast: E(), grayscale: Y(), hueRotate: E(), invert: Y(), gap: J(), gradientColorStops: [t], gradientColorStopPositions: [cC, Tn], inset: ge(), margin: ge(), opacity: E(), padding: J(), saturate: E(), scale: E(), sepia: Y(), skew: E(), space: J(), translate: J() }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", we] }], container: ["container"], columns: [{ columns: [Rn] }], "break-after": [{ "break-after": X() }], "break-before": [{ "break-before": X() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: [...oe(), we] }], overflow: [{ overflow: ie() }], "overflow-x": [{ "overflow-x": ie() }], "overflow-y": [{ "overflow-y": ie() }], overscroll: [{ overscroll: le() }], "overscroll-x": [{ "overscroll-x": le() }], "overscroll-y": [{ "overscroll-y": le() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [S] }], "inset-x": [{ "inset-x": [S] }], "inset-y": [{ "inset-y": [S] }], start: [{ start: [S] }], end: [{ end: [S] }], top: [{ top: [S] }], right: [{ right: [S] }], bottom: [{ bottom: [S] }], left: [{ left: [S] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", Io, we] }], basis: [{ basis: ge() }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", we] }], grow: [{ grow: Y() }], shrink: [{ shrink: Y() }], order: [{ order: ["first", "last", "none", Io, we] }], "grid-cols": [{ "grid-cols": [Vo] }], "col-start-end": [{ col: ["auto", { span: ["full", Io, we] }, we] }], "col-start": [{ "col-start": ne() }], "col-end": [{ "col-end": ne() }], "grid-rows": [{ "grid-rows": [Vo] }], "row-start-end": [{ row: ["auto", { span: [Io, we] }, we] }], "row-start": [{ "row-start": ne() }], "row-end": [{ "row-end": ne() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", we] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", we] }], gap: [{ gap: [w] }], "gap-x": [{ "gap-x": [w] }], "gap-y": [{ "gap-y": [w] }], "justify-content": [{ justify: ["normal", ...F()] }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal", ...F(), "baseline"] }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": [...F(), "baseline"] }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [N] }], px: [{ px: [N] }], py: [{ py: [N] }], ps: [{ ps: [N] }], pe: [{ pe: [N] }], pt: [{ pt: [N] }], pr: [{ pr: [N] }], pb: [{ pb: [N] }], pl: [{ pl: [N] }], m: [{ m: [P] }], mx: [{ mx: [P] }], my: [{ my: [P] }], ms: [{ ms: [P] }], me: [{ me: [P] }], mt: [{ mt: [P] }], mr: [{ mr: [P] }], mb: [{ mb: [P] }], ml: [{ ml: [P] }], "space-x": [{ "space-x": [H] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [H] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", we, r] }], "min-w": [{ "min-w": [we, r, "min", "max", "fit"] }], "max-w": [{ "max-w": [we, r, "none", "full", "min", "max", "fit", "prose", { screen: [Rn] }, Rn] }], h: [{ h: [we, r, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }], "min-h": [{ "min-h": [we, r, "min", "max", "fit", "svh", "lvh", "dvh"] }], "max-h": [{ "max-h": [we, r, "min", "max", "fit", "svh", "lvh", "dvh"] }], size: [{ size: [we, r, "auto", "min", "max", "fit"] }], "font-size": [{ text: ["base", Rn, Tn] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", jl] }], "font-family": [{ font: [Vo] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractons"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", we] }], "line-clamp": [{ "line-clamp": ["none", Lr, jl] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", an, we] }], "list-image": [{ "list-image": ["none", we] }], "list-style-type": [{ list: ["none", "disc", "decimal", we] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [t] }], "placeholder-opacity": [{ "placeholder-opacity": [R] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [t] }], "text-opacity": [{ "text-opacity": [R] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...ue(), "wavy"] }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", an, Tn] }], "underline-offset": [{ "underline-offset": ["auto", an, we] }], "text-decoration-color": [{ decoration: [t] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: J() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", we] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", we] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [R] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: [...oe(), pC] }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", fC] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, mC] }], "bg-color": [{ bg: [t] }], "gradient-from-pos": [{ from: [b] }], "gradient-via-pos": [{ via: [b] }], "gradient-to-pos": [{ to: [b] }], "gradient-from": [{ from: [C] }], "gradient-via": [{ via: [C] }], "gradient-to": [{ to: [C] }], rounded: [{ rounded: [d] }], "rounded-s": [{ "rounded-s": [d] }], "rounded-e": [{ "rounded-e": [d] }], "rounded-t": [{ "rounded-t": [d] }], "rounded-r": [{ "rounded-r": [d] }], "rounded-b": [{ "rounded-b": [d] }], "rounded-l": [{ "rounded-l": [d] }], "rounded-ss": [{ "rounded-ss": [d] }], "rounded-se": [{ "rounded-se": [d] }], "rounded-ee": [{ "rounded-ee": [d] }], "rounded-es": [{ "rounded-es": [d] }], "rounded-tl": [{ "rounded-tl": [d] }], "rounded-tr": [{ "rounded-tr": [d] }], "rounded-br": [{ "rounded-br": [d] }], "rounded-bl": [{ "rounded-bl": [d] }], "border-w": [{ border: [f] }], "border-w-x": [{ "border-x": [f] }], "border-w-y": [{ "border-y": [f] }], "border-w-s": [{ "border-s": [f] }], "border-w-e": [{ "border-e": [f] }], "border-w-t": [{ "border-t": [f] }], "border-w-r": [{ "border-r": [f] }], "border-w-b": [{ "border-b": [f] }], "border-w-l": [{ "border-l": [f] }], "border-opacity": [{ "border-opacity": [R] }], "border-style": [{ border: [...ue(), "hidden"] }], "divide-x": [{ "divide-x": [f] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [f] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [R] }], "divide-style": [{ divide: ue() }], "border-color": [{ border: [l] }], "border-color-x": [{ "border-x": [l] }], "border-color-y": [{ "border-y": [l] }], "border-color-t": [{ "border-t": [l] }], "border-color-r": [{ "border-r": [l] }], "border-color-b": [{ "border-b": [l] }], "border-color-l": [{ "border-l": [l] }], "divide-color": [{ divide: [l] }], "outline-style": [{ outline: ["", ...ue()] }], "outline-offset": [{ "outline-offset": [an, we] }], "outline-w": [{ outline: [an, Tn] }], "outline-color": [{ outline: [t] }], "ring-w": [{ ring: Se() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [t] }], "ring-opacity": [{ "ring-opacity": [R] }], "ring-offset-w": [{ "ring-offset": [an, Tn] }], "ring-offset-color": [{ "ring-offset": [t] }], shadow: [{ shadow: ["", "inner", "none", Rn, gC] }], "shadow-color": [{ shadow: [Vo] }], opacity: [{ opacity: [R] }], "mix-blend": [{ "mix-blend": [...G(), "plus-lighter", "plus-darker"] }], "bg-blend": [{ "bg-blend": G() }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [o] }], brightness: [{ brightness: [s] }], contrast: [{ contrast: [h] }], "drop-shadow": [{ "drop-shadow": ["", "none", Rn, we] }], grayscale: [{ grayscale: [m] }], "hue-rotate": [{ "hue-rotate": [v] }], invert: [{ invert: [g] }], saturate: [{ saturate: [L] }], sepia: [{ sepia: [I] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [o] }], "backdrop-brightness": [{ "backdrop-brightness": [s] }], "backdrop-contrast": [{ "backdrop-contrast": [h] }], "backdrop-grayscale": [{ "backdrop-grayscale": [m] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [v] }], "backdrop-invert": [{ "backdrop-invert": [g] }], "backdrop-opacity": [{ "backdrop-opacity": [R] }], "backdrop-saturate": [{ "backdrop-saturate": [L] }], "backdrop-sepia": [{ "backdrop-sepia": [I] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [u] }], "border-spacing-x": [{ "border-spacing-x": [u] }], "border-spacing-y": [{ "border-spacing-y": [u] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", we] }], duration: [{ duration: E() }], ease: [{ ease: ["linear", "in", "out", "in-out", we] }], delay: [{ delay: E() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", we] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [j] }], "scale-x": [{ "scale-x": [j] }], "scale-y": [{ "scale-y": [j] }], rotate: [{ rotate: [Io, we] }], "translate-x": [{ "translate-x": [W] }], "translate-y": [{ "translate-y": [W] }], "skew-x": [{ "skew-x": [K] }], "skew-y": [{ "skew-y": [K] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", we] }], accent: [{ accent: ["auto", t] }], appearance: [{ appearance: ["none", "auto"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", we] }], "caret-color": [{ caret: [t] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": J() }], "scroll-mx": [{ "scroll-mx": J() }], "scroll-my": [{ "scroll-my": J() }], "scroll-ms": [{ "scroll-ms": J() }], "scroll-me": [{ "scroll-me": J() }], "scroll-mt": [{ "scroll-mt": J() }], "scroll-mr": [{ "scroll-mr": J() }], "scroll-mb": [{ "scroll-mb": J() }], "scroll-ml": [{ "scroll-ml": J() }], "scroll-p": [{ "scroll-p": J() }], "scroll-px": [{ "scroll-px": J() }], "scroll-py": [{ "scroll-py": J() }], "scroll-ps": [{ "scroll-ps": J() }], "scroll-pe": [{ "scroll-pe": J() }], "scroll-pt": [{ "scroll-pt": J() }], "scroll-pr": [{ "scroll-pr": J() }], "scroll-pb": [{ "scroll-pb": J() }], "scroll-pl": [{ "scroll-pl": J() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", we] }], fill: [{ fill: [t, "none"] }], "stroke-w": [{ stroke: [an, Tn, jl] }], stroke: [{ stroke: [t, "none"] }], sr: ["sr-only", "not-sr-only"], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } } }); function gh(t) { var r, o, s = ""; if (typeof t == "string" || typeof t == "number") s += t; else if (typeof t == "object") if (Array.isArray(t)) { var l = t.length; for (r = 0; r < l; r++)t[r] && (o = gh(t[r])) && (s && (s += " "), s += o) } else for (o in t) t[o] && (s && (s += " "), s += o); return s } function xC() { for (var t, r, o = 0, s = "", l = arguments.length; o < l; o++)(t = arguments[o]) && (r = gh(t)) && (s && (s += " "), s += r); return s } function Oe(...t) { return ot(xC(t)) } function jr({ className: t, ...r }) { return T.jsx("div", { className: Oe("animate-pulse rounded-md bg-muted", t), ...r }) } function SC(t, r) { typeof t == "function" ? t(r) : t != null && (t.current = r) } function vh(...t) { return r => t.forEach(o => SC(o, r)) } function Je(...t) { return x.useCallback(vh(...t), t) } var Or = x.forwardRef((t, r) => { const { children: o, ...s } = t, l = x.Children.toArray(o), d = l.find(bC); if (d) { const u = d.props.children, f = l.map(h => h === d ? x.Children.count(u) > 1 ? x.Children.only(null) : x.isValidElement(u) ? u.props.children : null : h); return T.jsx(Ol, { ...s, ref: r, children: x.isValidElement(u) ? x.cloneElement(u, void 0, f) : null }) } return T.jsx(Ol, { ...s, ref: r, children: o }) }); Or.displayName = "Slot"; var Ol = x.forwardRef((t, r) => { const { children: o, ...s } = t; if (x.isValidElement(o)) { const l = PC(o); return x.cloneElement(o, { ...kC(s, o.props), ref: r ? vh(r, l) : l }) } return x.Children.count(o) > 1 ? x.Children.only(null) : null }); Ol.displayName = "SlotClone"; var CC = ({ children: t }) => T.jsx(T.Fragment, { children: t }); function bC(t) { return x.isValidElement(t) && t.type === CC } function kC(t, r) { const o = { ...r }; for (const s in r) { const l = t[s], d = r[s]; /^on[A-Z]/.test(s) ? l && d ? o[s] = (...f) => { d(...f), l(...f) } : l && (o[s] = l) : s === "style" ? o[s] = { ...l, ...d } : s === "className" && (o[s] = [l, d].filter(Boolean).join(" ")) } return { ...t, ...o } } function PC(t) { let r = Object.getOwnPropertyDescriptor(t.props, "ref")?.get, o = r && "isReactWarning" in r && r.isReactWarning; return o ? t.ref : (r = Object.getOwnPropertyDescriptor(t, "ref")?.get, o = r && "isReactWarning" in r && r.isReactWarning, o ? t.props.ref : t.props.ref || t.ref) } function yh(t) { var r, o, s = ""; if (typeof t == "string" || typeof t == "number") s += t; else if (typeof t == "object") if (Array.isArray(t)) for (r = 0; r < t.length; r++)t[r] && (o = yh(t[r])) && (s && (s += " "), s += o); else for (r in t) t[r] && (s && (s += " "), s += r); return s } function EC() { for (var t, r, o = 0, s = ""; o < arguments.length;)(t = arguments[o++]) && (r = yh(t)) && (s && (s += " "), s += r); return s } const wh = t => typeof t == "boolean" ? "".concat(t) : t === 0 ? "0" : t, xh = EC, _l = (t, r) => o => { var s; if (r?.variants == null) return xh(t, o?.class, o?.className); const { variants: l, defaultVariants: d } = r, u = Object.keys(l).map(m => { const v = o?.[m], g = d?.[m]; if (v === null) return null; const w = wh(v) || wh(g); return l[m][w] }), f = o && Object.entries(o).reduce((m, v) => { let [g, w] = v; return w === void 0 || (m[g] = w), m }, {}), h = r == null || (s = r.compoundVariants) === null || s === void 0 ? void 0 : s.reduce((m, v) => { let { class: g, className: w, ...C } = v; return Object.entries(C).every(b => { let [S, P] = b; return Array.isArray(P) ? P.includes({ ...d, ...f }[S]) : { ...d, ...f }[S] === P }) ? [...m, g, w] : m }, []); return xh(t, u, h, o?.class, o?.className) }, TC = _l("inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50", { variants: { variant: { default: "bg-primary text-primary-foreground hover:bg-primary/90", destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90", outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground", secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80", ghost: "hover:bg-accent hover:text-accent-foreground", link: "text-primary underline-offset-4 hover:underline" }, size: { default: "h-10 px-4 py-2", sm: "h-9 rounded-md px-3", lg: "h-11 rounded-md px-8", icon: "h-10 w-10" } }, defaultVariants: { variant: "default", size: "default" } }), Fo = x.forwardRef(({ className: t, variant: r, size: o, asChild: s = !1, ...l }, d) => { const u = s ? Or : "button"; return T.jsx(u, { className: Oe(TC({ variant: r, size: o, className: t })), ref: d, ...l }) }); Fo.displayName = "Button"; const ln = x.forwardRef(({ className: t, type: r, ...o }, s) => T.jsx("input", { type: r, className: Oe("flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", t), ref: s, ...o })); ln.displayName = "Input"; var RC = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"], ze = RC.reduce((t, r) => { const o = x.forwardRef((s, l) => { const { asChild: d, ...u } = s, f = d ? Or : r; return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), T.jsx(f, { ...u, ref: l }) }); return o.displayName = `Primitive.${r}`, { ...t, [r]: o } }, {}); function AC(t, r) { t && xo.flushSync(() => t.dispatchEvent(r)) } var NC = "Label", Sh = x.forwardRef((t, r) => T.jsx(ze.label, { ...t, ref: r, onMouseDown: o => { o.target.closest("button, input, select, textarea") || (t.onMouseDown?.(o), !o.defaultPrevented && o.detail > 1 && o.preventDefault()) } })); Sh.displayName = NC; var Ch = Sh; const MC = _l("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"), Dt = x.forwardRef(({ className: t, ...r }, o) => T.jsx(Ch, { ref: o, className: Oe(MC(), t), ...r })); Dt.displayName = Ch.displayName; const bh = x.forwardRef(({ className: t, ...r }, o) => T.jsx("textarea", { className: Oe("flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", t), ref: o, ...r })); bh.displayName = "Textarea"; var LC = "Separator", kh = "horizontal", DC = ["horizontal", "vertical"], Ph = x.forwardRef((t, r) => { const { decorative: o, orientation: s = kh, ...l } = t, d = jC(s) ? s : kh, f = o ? { role: "none" } : { "aria-orientation": d === "vertical" ? d : void 0, role: "separator" }; return T.jsx(ze.div, { "data-orientation": d, ...f, ...l, ref: r }) }); Ph.displayName = LC; function jC(t) { return DC.includes(t) } var Eh = Ph; const Th = x.forwardRef(({ className: t, orientation: r = "horizontal", decorative: o = !0, ...s }, l) => T.jsx(Eh, { ref: l, decorative: o, orientation: r, className: Oe("shrink-0 bg-border", r === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]", t), ...s })); Th.displayName = Eh.displayName; const OC = _l("relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground", { variants: { variant: { default: "bg-background text-foreground", destructive: "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive" } }, defaultVariants: { variant: "default" } }), Rh = x.forwardRef(({ className: t, variant: r, ...o }, s) => T.jsx("div", { ref: s, role: "alert", className: Oe(OC({ variant: r }), t), ...o })); Rh.displayName = "Alert"; const Ah = x.forwardRef(({ className: t, ...r }, o) => T.jsx("h5", { ref: o, className: Oe("mb-1 font-medium leading-none tracking-tight", t), ...r })); Ah.displayName = "AlertTitle"; const Nh = x.forwardRef(({ className: t, ...r }, o) => T.jsx("div", { ref: o, className: Oe("text-sm [&_p]:leading-relaxed", t), ...r })); Nh.displayName = "AlertDescription"; function Mh(t, [r, o]) { return Math.min(o, Math.max(r, t)) } function Ge(t, r, { checkForDefaultPrevented: o = !0 } = {}) { return function (l) { if (t?.(l), o === !1 || !l.defaultPrevented) return r?.(l) } } function Il(t, r = []) { let o = []; function s(d, u) { const f = x.createContext(u), h = o.length; o = [...o, u]; function m(g) { const { scope: w, children: C, ...b } = g, S = w?.[t][h] || f, P = x.useMemo(() => b, Object.values(b)); return T.jsx(S.Provider, { value: P, children: C }) } function v(g, w) { const C = w?.[t][h] || f, b = x.useContext(C); if (b) return b; if (u !== void 0) return u; throw new Error(`\`${g}\` must be used within \`${d}\``) } return m.displayName = d + "Provider", [m, v] } const l = () => { const d = o.map(u => x.createContext(u)); return function (f) { const h = f?.[t] || d; return x.useMemo(() => ({ [`__scope${t}`]: { ...f, [t]: h } }), [f, h]) } }; return l.scopeName = t, [s, _C(l, ...r)] } function _C(...t) { const r = t[0]; if (t.length === 1) return r; const o = () => { const s = t.map(l => ({ useScope: l(), scopeName: l.scopeName })); return function (d) { const u = s.reduce((f, { useScope: h, scopeName: m }) => { const g = h(d)[`__scope${m}`]; return { ...f, ...g } }, {}); return x.useMemo(() => ({ [`__scope${r.scopeName}`]: u }), [u]) } }; return o.scopeName = r.scopeName, o } function IC(t) { const r = t + "CollectionProvider", [o, s] = Il(r), [l, d] = o(r, { collectionRef: { current: null }, itemMap: new Map }), u = C => { const { scope: b, children: S } = C, P = Sn.useRef(null), R = Sn.useRef(new Map).current; return T.jsx(l, { scope: b, itemMap: R, collectionRef: P, children: S }) }; u.displayName = r; const f = t + "CollectionSlot", h = Sn.forwardRef((C, b) => { const { scope: S, children: P } = C, R = d(f, S), N = Je(b, R.collectionRef); return T.jsx(Or, { ref: N, children: P }) }); h.displayName = f; const m = t + "CollectionItemSlot", v = "data-radix-collection-item", g = Sn.forwardRef((C, b) => { const { scope: S, children: P, ...R } = C, N = Sn.useRef(null), L = Je(b, N), j = d(m, S); return Sn.useEffect(() => (j.itemMap.set(N, { ref: N, ...R }), () => void j.itemMap.delete(N))), T.jsx(Or, { [v]: "", ref: L, children: P }) }); g.displayName = m; function w(C) { const b = d(t + "CollectionConsumer", C); return Sn.useCallback(() => { const P = b.collectionRef.current; if (!P) return []; const R = Array.from(P.querySelectorAll(`[${v}]`)); return Array.from(b.itemMap.values()).sort((j, I) => R.indexOf(j.ref.current) - R.indexOf(I.ref.current)) }, [b.collectionRef, b.itemMap]) } return [{ Provider: u, Slot: h, ItemSlot: g }, w, s] } function sr(t) { const r = x.useRef(t); return x.useEffect(() => { r.current = t }), x.useMemo(() => (...o) => r.current?.(...o), []) } function VC(t, r = globalThis?.document) { const o = sr(t); x.useEffect(() => { const s = l => { l.key === "Escape" && o(l) }; return r.addEventListener("keydown", s, { capture: !0 }), () => r.removeEventListener("keydown", s, { capture: !0 }) }, [o, r]) } var FC = "DismissableLayer", Vl = "dismissableLayer.update", zC = "dismissableLayer.pointerDownOutside", BC = "dismissableLayer.focusOutside", Lh, Dh = x.createContext({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), jh = x.forwardRef((t, r) => { const { disableOutsidePointerEvents: o = !1, onEscapeKeyDown: s, onPointerDownOutside: l, onFocusOutside: d, onInteractOutside: u, onDismiss: f, ...h } = t, m = x.useContext(Dh), [v, g] = x.useState(null), w = v?.ownerDocument ?? globalThis?.document, [, C] = x.useState({}), b = Je(r, H => g(H)), S = Array.from(m.layers), [P] = [...m.layersWithOutsidePointerEventsDisabled].slice(-1), R = S.indexOf(P), N = v ? S.indexOf(v) : -1, L = m.layersWithOutsidePointerEventsDisabled.size > 0, j = N >= R, I = $C(H => { const W = H.target, le = [...m.branches].some(ie => ie.contains(W)); !j || le || (l?.(H), u?.(H), H.defaultPrevented || f?.()) }, w), K = HC(H => { const W = H.target;[...m.branches].some(ie => ie.contains(W)) || (d?.(H), u?.(H), H.defaultPrevented || f?.()) }, w); return VC(H => { N === m.layers.size - 1 && (s?.(H), !H.defaultPrevented && f && (H.preventDefault(), f())) }, w), x.useEffect(() => { if (v) return o && (m.layersWithOutsidePointerEventsDisabled.size === 0 && (Lh = w.body.style.pointerEvents, w.body.style.pointerEvents = "none"), m.layersWithOutsidePointerEventsDisabled.add(v)), m.layers.add(v), Oh(), () => { o && m.layersWithOutsidePointerEventsDisabled.size === 1 && (w.body.style.pointerEvents = Lh) } }, [v, w, o, m]), x.useEffect(() => () => { v && (m.layers.delete(v), m.layersWithOutsidePointerEventsDisabled.delete(v), Oh()) }, [v, m]), x.useEffect(() => { const H = () => C({}); return document.addEventListener(Vl, H), () => document.removeEventListener(Vl, H) }, []), T.jsx(ze.div, { ...h, ref: b, style: { pointerEvents: L ? j ? "auto" : "none" : void 0, ...t.style }, onFocusCapture: Ge(t.onFocusCapture, K.onFocusCapture), onBlurCapture: Ge(t.onBlurCapture, K.onBlurCapture), onPointerDownCapture: Ge(t.onPointerDownCapture, I.onPointerDownCapture) }) }); jh.displayName = FC; var UC = "DismissableLayerBranch", WC = x.forwardRef((t, r) => { const o = x.useContext(Dh), s = x.useRef(null), l = Je(r, s); return x.useEffect(() => { const d = s.current; if (d) return o.branches.add(d), () => { o.branches.delete(d) } }, [o.branches]), T.jsx(ze.div, { ...t, ref: l }) }); WC.displayName = UC; function $C(t, r = globalThis?.document) { const o = sr(t), s = x.useRef(!1), l = x.useRef(() => { }); return x.useEffect(() => { const d = f => { if (f.target && !s.current) { let h = function () { _h(zC, o, m, { discrete: !0 }) }; const m = { originalEvent: f }; f.pointerType === "touch" ? (r.removeEventListener("click", l.current), l.current = h, r.addEventListener("click", l.current, { once: !0 })) : h() } else r.removeEventListener("click", l.current); s.current = !1 }, u = window.setTimeout(() => { r.addEventListener("pointerdown", d) }, 0); return () => { window.clearTimeout(u), r.removeEventListener("pointerdown", d), r.removeEventListener("click", l.current) } }, [r, o]), { onPointerDownCapture: () => s.current = !0 } } function HC(t, r = globalThis?.document) { const o = sr(t), s = x.useRef(!1); return x.useEffect(() => { const l = d => { d.target && !s.current && _h(BC, o, { originalEvent: d }, { discrete: !1 }) }; return r.addEventListener("focusin", l), () => r.removeEventListener("focusin", l) }, [r, o]), { onFocusCapture: () => s.current = !0, onBlurCapture: () => s.current = !1 } } function Oh() { const t = new CustomEvent(Vl); document.dispatchEvent(t) } function _h(t, r, o, { discrete: s }) { const l = o.originalEvent.target, d = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: o }); r && l.addEventListener(t, r, { once: !0 }), s ? AC(l, d) : l.dispatchEvent(d) } var Fl = 0; function KC() { x.useEffect(() => { const t = document.querySelectorAll("[data-radix-focus-guard]"); return document.body.insertAdjacentElement("afterbegin", t[0] ?? Ih()), document.body.insertAdjacentElement("beforeend", t[1] ?? Ih()), Fl++, () => { Fl === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(r => r.remove()), Fl-- } }, []) } function Ih() { const t = document.createElement("span"); return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", t } var zl = "focusScope.autoFocusOnMount", Bl = "focusScope.autoFocusOnUnmount", Vh = { bubbles: !1, cancelable: !0 }, GC = "FocusScope", Fh = x.forwardRef((t, r) => { const { loop: o = !1, trapped: s = !1, onMountAutoFocus: l, onUnmountAutoFocus: d, ...u } = t, [f, h] = x.useState(null), m = sr(l), v = sr(d), g = x.useRef(null), w = Je(r, S => h(S)), C = x.useRef({ paused: !1, pause() { this.paused = !0 }, resume() { this.paused = !1 } }).current; x.useEffect(() => { if (s) { let S = function (L) { if (C.paused || !f) return; const j = L.target; f.contains(j) ? g.current = j : An(g.current, { select: !0 }) }, P = function (L) { if (C.paused || !f) return; const j = L.relatedTarget; j !== null && (f.contains(j) || An(g.current, { select: !0 })) }, R = function (L) { if (document.activeElement === document.body) for (const I of L) I.removedNodes.length > 0 && An(f) }; document.addEventListener("focusin", S), document.addEventListener("focusout", P); const N = new MutationObserver(R); return f && N.observe(f, { childList: !0, subtree: !0 }), () => { document.removeEventListener("focusin", S), document.removeEventListener("focusout", P), N.disconnect() } } }, [s, f, C.paused]), x.useEffect(() => { if (f) { Uh.add(C); const S = document.activeElement; if (!f.contains(S)) { const R = new CustomEvent(zl, Vh); f.addEventListener(zl, m), f.dispatchEvent(R), R.defaultPrevented || (YC(JC(zh(f)), { select: !0 }), document.activeElement === S && An(f)) } return () => { f.removeEventListener(zl, m), setTimeout(() => { const R = new CustomEvent(Bl, Vh); f.addEventListener(Bl, v), f.dispatchEvent(R), R.defaultPrevented || An(S ?? document.body, { select: !0 }), f.removeEventListener(Bl, v), Uh.remove(C) }, 0) } } }, [f, m, v, C]); const b = x.useCallback(S => { if (!o && !s || C.paused) return; const P = S.key === "Tab" && !S.altKey && !S.ctrlKey && !S.metaKey, R = document.activeElement; if (P && R) { const N = S.currentTarget, [L, j] = XC(N); L && j ? !S.shiftKey && R === j ? (S.preventDefault(), o && An(L, { select: !0 })) : S.shiftKey && R === L && (S.preventDefault(), o && An(j, { select: !0 })) : R === N && S.preventDefault() } }, [o, s, C.paused]); return T.jsx(ze.div, { tabIndex: -1, ...u, ref: w, onKeyDown: b }) }); Fh.displayName = GC; function YC(t, { select: r = !1 } = {}) { const o = document.activeElement; for (const s of t) if (An(s, { select: r }), document.activeElement !== o) return } function XC(t) { const r = zh(t), o = Bh(r, t), s = Bh(r.reverse(), t); return [o, s] } function zh(t) { const r = [], o = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, { acceptNode: s => { const l = s.tagName === "INPUT" && s.type === "hidden"; return s.disabled || s.hidden || l ? NodeFilter.FILTER_SKIP : s.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; o.nextNode();)r.push(o.currentNode); return r } function Bh(t, r) { for (const o of t) if (!QC(o, { upTo: r })) return o } function QC(t, { upTo: r }) { if (getComputedStyle(t).visibility === "hidden") return !0; for (; t;) { if (r !== void 0 && t === r) return !1; if (getComputedStyle(t).display === "none") return !0; t = t.parentElement } return !1 } function qC(t) { return t instanceof HTMLInputElement && "select" in t } function An(t, { select: r = !1 } = {}) { if (t && t.focus) { const o = document.activeElement; t.focus({ preventScroll: !0 }), t !== o && qC(t) && r && t.select() } } var Uh = ZC(); function ZC() { let t = []; return { add(r) { const o = t[0]; r !== o && o?.pause(), t = Wh(t, r), t.unshift(r) }, remove(r) { t = Wh(t, r), t[0]?.resume() } } } function Wh(t, r) { const o = [...t], s = o.indexOf(r); return s !== -1 && o.splice(s, 1), o } function JC(t) { return t.filter(r => r.tagName !== "A") } var Et = globalThis?.document ? x.useLayoutEffect : () => { }, eb = h0["useId".toString()] || (() => { }), tb = 0; function $h(t) { const [r, o] = x.useState(eb()); return Et(() => { t || o(s => s ?? String(tb++)) }, [t]), t || (r ? `radix-${r}` : "") } const nb = ["top", "right", "bottom", "left"], Ht = Math.min, yt = Math.max, Zi = Math.round, Ji = Math.floor, Nn = t => ({ x: t, y: t }), rb = { left: "right", right: "left", bottom: "top", top: "bottom" }, ob = { start: "end", end: "start" }; function Ul(t, r, o) { return yt(t, Ht(r, o)) } function un(t, r) { return typeof t == "function" ? t(r) : t } function cn(t) { return t.split("-")[0] } function _r(t) { return t.split("-")[1] } function Wl(t) { return t === "x" ? "y" : "x" } function $l(t) { return t === "y" ? "height" : "width" } function Mn(t) { return ["top", "bottom"].includes(cn(t)) ? "y" : "x" } function Hl(t) { return Wl(Mn(t)) } function ib(t, r, o) { o === void 0 && (o = !1); const s = _r(t), l = Hl(t), d = $l(l); let u = l === "x" ? s === (o ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top"; return r.reference[d] > r.floating[d] && (u = es(u)), [u, es(u)] } function sb(t) { const r = es(t); return [Kl(t), r, Kl(r)] } function Kl(t) { return t.replace(/start|end/g, r => ob[r]) } function ab(t, r, o) { const s = ["left", "right"], l = ["right", "left"], d = ["top", "bottom"], u = ["bottom", "top"]; switch (t) { case "top": case "bottom": return o ? r ? l : s : r ? s : l; case "left": case "right": return r ? d : u; default: return [] } } function lb(t, r, o, s) { const l = _r(t); let d = ab(cn(t), o === "start", s); return l && (d = d.map(u => u + "-" + l), r && (d = d.concat(d.map(Kl)))), d } function es(t) { return t.replace(/left|right|bottom|top/g, r => rb[r]) } function ub(t) { return { top: 0, right: 0, bottom: 0, left: 0, ...t } } function Hh(t) { return typeof t != "number" ? ub(t) : { top: t, right: t, bottom: t, left: t } } function ts(t) { const { x: r, y: o, width: s, height: l } = t; return { width: s, height: l, top: o, left: r, right: r + s, bottom: o + l, x: r, y: o } } function Kh(t, r, o) { let { reference: s, floating: l } = t; const d = Mn(r), u = Hl(r), f = $l(u), h = cn(r), m = d === "y", v = s.x + s.width / 2 - l.width / 2, g = s.y + s.height / 2 - l.height / 2, w = s[f] / 2 - l[f] / 2; let C; switch (h) { case "top": C = { x: v, y: s.y - l.height }; break; case "bottom": C = { x: v, y: s.y + s.height }; break; case "right": C = { x: s.x + s.width, y: g }; break; case "left": C = { x: s.x - l.width, y: g }; break; default: C = { x: s.x, y: s.y } }switch (_r(r)) { case "start": C[u] -= w * (o && m ? -1 : 1); break; case "end": C[u] += w * (o && m ? -1 : 1); break }return C } const cb = async (t, r, o) => { const { placement: s = "bottom", strategy: l = "absolute", middleware: d = [], platform: u } = o, f = d.filter(Boolean), h = await (u.isRTL == null ? void 0 : u.isRTL(r)); let m = await u.getElementRects({ reference: t, floating: r, strategy: l }), { x: v, y: g } = Kh(m, s, h), w = s, C = {}, b = 0; for (let S = 0; S < f.length; S++) { const { name: P, fn: R } = f[S], { x: N, y: L, data: j, reset: I } = await R({ x: v, y: g, initialPlacement: s, placement: w, strategy: l, middlewareData: C, rects: m, platform: u, elements: { reference: t, floating: r } }); v = N ?? v, g = L ?? g, C = { ...C, [P]: { ...C[P], ...j } }, I && b <= 50 && (b++, typeof I == "object" && (I.placement && (w = I.placement), I.rects && (m = I.rects === !0 ? await u.getElementRects({ reference: t, floating: r, strategy: l }) : I.rects), { x: v, y: g } = Kh(m, w, h)), S = -1) } return { x: v, y: g, placement: w, strategy: l, middlewareData: C } }; async function zo(t, r) { var o; r === void 0 && (r = {}); const { x: s, y: l, platform: d, rects: u, elements: f, strategy: h } = t, { boundary: m = "clippingAncestors", rootBoundary: v = "viewport", elementContext: g = "floating", altBoundary: w = !1, padding: C = 0 } = un(r, t), b = Hh(C), P = f[w ? g === "floating" ? "reference" : "floating" : g], R = ts(await d.getClippingRect({ element: (o = await (d.isElement == null ? void 0 : d.isElement(P))) == null || o ? P : P.contextElement || await (d.getDocumentElement == null ? void 0 : d.getDocumentElement(f.floating)), boundary: m, rootBoundary: v, strategy: h })), N = g === "floating" ? { x: s, y: l, width: u.floating.width, height: u.floating.height } : u.reference, L = await (d.getOffsetParent == null ? void 0 : d.getOffsetParent(f.floating)), j = await (d.isElement == null ? void 0 : d.isElement(L)) ? await (d.getScale == null ? void 0 : d.getScale(L)) || { x: 1, y: 1 } : { x: 1, y: 1 }, I = ts(d.convertOffsetParentRelativeRectToViewportRelativeRect ? await d.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: f, rect: N, offsetParent: L, strategy: h }) : N); return { top: (R.top - I.top + b.top) / j.y, bottom: (I.bottom - R.bottom + b.bottom) / j.y, left: (R.left - I.left + b.left) / j.x, right: (I.right - R.right + b.right) / j.x } } const db = t => ({ name: "arrow", options: t, async fn(r) { const { x: o, y: s, placement: l, rects: d, platform: u, elements: f, middlewareData: h } = r, { element: m, padding: v = 0 } = un(t, r) || {}; if (m == null) return {}; const g = Hh(v), w = { x: o, y: s }, C = Hl(l), b = $l(C), S = await u.getDimensions(m), P = C === "y", R = P ? "top" : "left", N = P ? "bottom" : "right", L = P ? "clientHeight" : "clientWidth", j = d.reference[b] + d.reference[C] - w[C] - d.floating[b], I = w[C] - d.reference[C], K = await (u.getOffsetParent == null ? void 0 : u.getOffsetParent(m)); let H = K ? K[L] : 0; (!H || !await (u.isElement == null ? void 0 : u.isElement(K))) && (H = f.floating[L] || d.floating[b]); const W = j / 2 - I / 2, le = H / 2 - S[b] / 2 - 1, ie = Ht(g[R], le), ge = Ht(g[N], le), J = ie, Se = H - S[b] - ge, ne = H / 2 - S[b] / 2 + W, oe = Ul(J, ne, Se), ue = !h.arrow && _r(l) != null && ne !== oe && d.reference[b] / 2 - (ne < J ? ie : ge) - S[b] / 2 < 0, G = ue ? ne < J ? ne - J : ne - Se : 0; return { [C]: w[C] + G, data: { [C]: oe, centerOffset: ne - oe - G, ...ue && { alignmentOffset: G } }, reset: ue } } }), fb = function (t) { return t === void 0 && (t = {}), { name: "flip", options: t, async fn(r) { var o, s; const { placement: l, middlewareData: d, rects: u, initialPlacement: f, platform: h, elements: m } = r, { mainAxis: v = !0, crossAxis: g = !0, fallbackPlacements: w, fallbackStrategy: C = "bestFit", fallbackAxisSideDirection: b = "none", flipAlignment: S = !0, ...P } = un(t, r); if ((o = d.arrow) != null && o.alignmentOffset) return {}; const R = cn(l), N = Mn(f), L = cn(f) === f, j = await (h.isRTL == null ? void 0 : h.isRTL(m.floating)), I = w || (L || !S ? [es(f)] : sb(f)), K = b !== "none"; !w && K && I.push(...lb(f, S, b, j)); const H = [f, ...I], W = await zo(r, P), le = []; let ie = ((s = d.flip) == null ? void 0 : s.overflows) || []; if (v && le.push(W[R]), g) { const ne = ib(l, u, j); le.push(W[ne[0]], W[ne[1]]) } if (ie = [...ie, { placement: l, overflows: le }], !le.every(ne => ne <= 0)) { var ge, J; const ne = (((ge = d.flip) == null ? void 0 : ge.index) || 0) + 1, oe = H[ne]; if (oe) return { data: { index: ne, overflows: ie }, reset: { placement: oe } }; let ue = (J = ie.filter(G => G.overflows[0] <= 0).sort((G, F) => G.overflows[1] - F.overflows[1])[0]) == null ? void 0 : J.placement; if (!ue) switch (C) { case "bestFit": { var Se; const G = (Se = ie.filter(F => { if (K) { const Y = Mn(F.placement); return Y === N || Y === "y" } return !0 }).map(F => [F.placement, F.overflows.filter(Y => Y > 0).reduce((Y, X) => Y + X, 0)]).sort((F, Y) => F[1] - Y[1])[0]) == null ? void 0 : Se[0]; G && (ue = G); break } case "initialPlacement": ue = f; break }if (l !== ue) return { reset: { placement: ue } } } return {} } } }; function Gh(t, r) { return { top: t.top - r.height, right: t.right - r.width, bottom: t.bottom - r.height, left: t.left - r.width } } function Yh(t) { return nb.some(r => t[r] >= 0) } const pb = function (t) { return t === void 0 && (t = {}), { name: "hide", options: t, async fn(r) { const { rects: o } = r, { strategy: s = "referenceHidden", ...l } = un(t, r); switch (s) { case "referenceHidden": { const d = await zo(r, { ...l, elementContext: "reference" }), u = Gh(d, o.reference); return { data: { referenceHiddenOffsets: u, referenceHidden: Yh(u) } } } case "escaped": { const d = await zo(r, { ...l, altBoundary: !0 }), u = Gh(d, o.floating); return { data: { escapedOffsets: u, escaped: Yh(u) } } } default: return {} } } } }; async function hb(t, r) { const { placement: o, platform: s, elements: l } = t, d = await (s.isRTL == null ? void 0 : s.isRTL(l.floating)), u = cn(o), f = _r(o), h = Mn(o) === "y", m = ["left", "top"].includes(u) ? -1 : 1, v = d && h ? -1 : 1, g = un(r, t); let { mainAxis: w, crossAxis: C, alignmentAxis: b } = typeof g == "number" ? { mainAxis: g, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...g }; return f && typeof b == "number" && (C = f === "end" ? b * -1 : b), h ? { x: C * v, y: w * m } : { x: w * m, y: C * v } } const mb = function (t) { return t === void 0 && (t = 0), { name: "offset", options: t, async fn(r) { var o, s; const { x: l, y: d, placement: u, middlewareData: f } = r, h = await hb(r, t); return u === ((o = f.offset) == null ? void 0 : o.placement) && (s = f.arrow) != null && s.alignmentOffset ? {} : { x: l + h.x, y: d + h.y, data: { ...h, placement: u } } } } }, gb = function (t) { return t === void 0 && (t = {}), { name: "shift", options: t, async fn(r) { const { x: o, y: s, placement: l } = r, { mainAxis: d = !0, crossAxis: u = !1, limiter: f = { fn: P => { let { x: R, y: N } = P; return { x: R, y: N } } }, ...h } = un(t, r), m = { x: o, y: s }, v = await zo(r, h), g = Mn(cn(l)), w = Wl(g); let C = m[w], b = m[g]; if (d) { const P = w === "y" ? "top" : "left", R = w === "y" ? "bottom" : "right", N = C + v[P], L = C - v[R]; C = Ul(N, C, L) } if (u) { const P = g === "y" ? "top" : "left", R = g === "y" ? "bottom" : "right", N = b + v[P], L = b - v[R]; b = Ul(N, b, L) } const S = f.fn({ ...r, [w]: C, [g]: b }); return { ...S, data: { x: S.x - o, y: S.y - s } } } } }, vb = function (t) { return t === void 0 && (t = {}), { options: t, fn(r) { const { x: o, y: s, placement: l, rects: d, middlewareData: u } = r, { offset: f = 0, mainAxis: h = !0, crossAxis: m = !0 } = un(t, r), v = { x: o, y: s }, g = Mn(l), w = Wl(g); let C = v[w], b = v[g]; const S = un(f, r), P = typeof S == "number" ? { mainAxis: S, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...S }; if (h) { const L = w === "y" ? "height" : "width", j = d.reference[w] - d.floating[L] + P.mainAxis, I = d.reference[w] + d.reference[L] - P.mainAxis; C < j ? C = j : C > I && (C = I) } if (m) { var R, N; const L = w === "y" ? "width" : "height", j = ["top", "left"].includes(cn(l)), I = d.reference[g] - d.floating[L] + (j && ((R = u.offset) == null ? void 0 : R[g]) || 0) + (j ? 0 : P.crossAxis), K = d.reference[g] + d.reference[L] + (j ? 0 : ((N = u.offset) == null ? void 0 : N[g]) || 0) - (j ? P.crossAxis : 0); b < I ? b = I : b > K && (b = K) } return { [w]: C, [g]: b } } } }, yb = function (t) { return t === void 0 && (t = {}), { name: "size", options: t, async fn(r) { const { placement: o, rects: s, platform: l, elements: d } = r, { apply: u = () => { }, ...f } = un(t, r), h = await zo(r, f), m = cn(o), v = _r(o), g = Mn(o) === "y", { width: w, height: C } = s.floating; let b, S; m === "top" || m === "bottom" ? (b = m, S = v === (await (l.isRTL == null ? void 0 : l.isRTL(d.floating)) ? "start" : "end") ? "left" : "right") : (S = m, b = v === "end" ? "top" : "bottom"); const P = C - h.top - h.bottom, R = w - h.left - h.right, N = Ht(C - h[b], P), L = Ht(w - h[S], R), j = !r.middlewareData.shift; let I = N, K = L; if (g ? K = v || j ? Ht(L, R) : R : I = v || j ? Ht(N, P) : P, j && !v) { const W = yt(h.left, 0), le = yt(h.right, 0), ie = yt(h.top, 0), ge = yt(h.bottom, 0); g ? K = w - 2 * (W !== 0 || le !== 0 ? W + le : yt(h.left, h.right)) : I = C - 2 * (ie !== 0 || ge !== 0 ? ie + ge : yt(h.top, h.bottom)) } await u({ ...r, availableWidth: K, availableHeight: I }); const H = await l.getDimensions(d.floating); return w !== H.width || C !== H.height ? { reset: { rects: !0 } } : {} } } }; function Ir(t) { return Xh(t) ? (t.nodeName || "").toLowerCase() : "#document" } function wt(t) { var r; return (t == null || (r = t.ownerDocument) == null ? void 0 : r.defaultView) || window } function dn(t) { var r; return (r = (Xh(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : r.documentElement } function Xh(t) { return t instanceof Node || t instanceof wt(t).Node } function Kt(t) { return t instanceof Element || t instanceof wt(t).Element } function Gt(t) { return t instanceof HTMLElement || t instanceof wt(t).HTMLElement } function Qh(t) { return typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof wt(t).ShadowRoot } function Bo(t) { const { overflow: r, overflowX: o, overflowY: s, display: l } = jt(t); return /auto|scroll|overlay|hidden|clip/.test(r + s + o) && !["inline", "contents"].includes(l) } function wb(t) { return ["table", "td", "th"].includes(Ir(t)) } function ns(t) { return [":popover-open", ":modal"].some(r => { try { return t.matches(r) } catch { return !1 } }) } function Gl(t) { const r = Yl(), o = jt(t); return o.transform !== "none" || o.perspective !== "none" || (o.containerType ? o.containerType !== "normal" : !1) || !r && (o.backdropFilter ? o.backdropFilter !== "none" : !1) || !r && (o.filter ? o.filter !== "none" : !1) || ["transform", "perspective", "filter"].some(s => (o.willChange || "").includes(s)) || ["paint", "layout", "strict", "content"].some(s => (o.contain || "").includes(s)) } function xb(t) { let r = Ln(t); for (; Gt(r) && !Vr(r);) { if (ns(r)) return null; if (Gl(r)) return r; r = Ln(r) } return null } function Yl() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } function Vr(t) { return ["html", "body", "#document"].includes(Ir(t)) } function jt(t) { return wt(t).getComputedStyle(t) } function rs(t) { return Kt(t) ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } : { scrollLeft: t.scrollX, scrollTop: t.scrollY } } function Ln(t) { if (Ir(t) === "html") return t; const r = t.assignedSlot || t.parentNode || Qh(t) && t.host || dn(t); return Qh(r) ? r.host : r } function qh(t) { const r = Ln(t); return Vr(r) ? t.ownerDocument ? t.ownerDocument.body : t.body : Gt(r) && Bo(r) ? r : qh(r) } function Uo(t, r, o) { var s; r === void 0 && (r = []), o === void 0 && (o = !0); const l = qh(t), d = l === ((s = t.ownerDocument) == null ? void 0 : s.body), u = wt(l); return d ? r.concat(u, u.visualViewport || [], Bo(l) ? l : [], u.frameElement && o ? Uo(u.frameElement) : []) : r.concat(l, Uo(l, [], o)) } function Zh(t) { const r = jt(t); let o = parseFloat(r.width) || 0, s = parseFloat(r.height) || 0; const l = Gt(t), d = l ? t.offsetWidth : o, u = l ? t.offsetHeight : s, f = Zi(o) !== d || Zi(s) !== u; return f && (o = d, s = u), { width: o, height: s, $: f } } function Xl(t) { return Kt(t) ? t : t.contextElement } function Fr(t) { const r = Xl(t); if (!Gt(r)) return Nn(1); const o = r.getBoundingClientRect(), { width: s, height: l, $: d } = Zh(r); let u = (d ? Zi(o.width) : o.width) / s, f = (d ? Zi(o.height) : o.height) / l; return (!u || !Number.isFinite(u)) && (u = 1), (!f || !Number.isFinite(f)) && (f = 1), { x: u, y: f } } const Sb = Nn(0); function Jh(t) { const r = wt(t); return !Yl() || !r.visualViewport ? Sb : { x: r.visualViewport.offsetLeft, y: r.visualViewport.offsetTop } } function Cb(t, r, o) { return r === void 0 && (r = !1), !o || r && o !== wt(t) ? !1 : r } function ar(t, r, o, s) { r === void 0 && (r = !1), o === void 0 && (o = !1); const l = t.getBoundingClientRect(), d = Xl(t); let u = Nn(1); r && (s ? Kt(s) && (u = Fr(s)) : u = Fr(t)); const f = Cb(d, o, s) ? Jh(d) : Nn(0); let h = (l.left + f.x) / u.x, m = (l.top + f.y) / u.y, v = l.width / u.x, g = l.height / u.y; if (d) { const w = wt(d), C = s && Kt(s) ? wt(s) : s; let b = w, S = b.frameElement; for (; S && s && C !== b;) { const P = Fr(S), R = S.getBoundingClientRect(), N = jt(S), L = R.left + (S.clientLeft + parseFloat(N.paddingLeft)) * P.x, j = R.top + (S.clientTop + parseFloat(N.paddingTop)) * P.y; h *= P.x, m *= P.y, v *= P.x, g *= P.y, h += L, m += j, b = wt(S), S = b.frameElement } } return ts({ width: v, height: g, x: h, y: m }) } function bb(t) { let { elements: r, rect: o, offsetParent: s, strategy: l } = t; const d = l === "fixed", u = dn(s), f = r ? ns(r.floating) : !1; if (s === u || f && d) return o; let h = { scrollLeft: 0, scrollTop: 0 }, m = Nn(1); const v = Nn(0), g = Gt(s); if ((g || !g && !d) && ((Ir(s) !== "body" || Bo(u)) && (h = rs(s)), Gt(s))) { const w = ar(s); m = Fr(s), v.x = w.x + s.clientLeft, v.y = w.y + s.clientTop } return { width: o.width * m.x, height: o.height * m.y, x: o.x * m.x - h.scrollLeft * m.x + v.x, y: o.y * m.y - h.scrollTop * m.y + v.y } } function kb(t) { return Array.from(t.getClientRects()) } function em(t) { return ar(dn(t)).left + rs(t).scrollLeft } function Pb(t) { const r = dn(t), o = rs(t), s = t.ownerDocument.body, l = yt(r.scrollWidth, r.clientWidth, s.scrollWidth, s.clientWidth), d = yt(r.scrollHeight, r.clientHeight, s.scrollHeight, s.clientHeight); let u = -o.scrollLeft + em(t); const f = -o.scrollTop; return jt(s).direction === "rtl" && (u += yt(r.clientWidth, s.clientWidth) - l), { width: l, height: d, x: u, y: f } } function Eb(t, r) { const o = wt(t), s = dn(t), l = o.visualViewport; let d = s.clientWidth, u = s.clientHeight, f = 0, h = 0; if (l) { d = l.width, u = l.height; const m = Yl(); (!m || m && r === "fixed") && (f = l.offsetLeft, h = l.offsetTop) } return { width: d, height: u, x: f, y: h } } function Tb(t, r) { const o = ar(t, !0, r === "fixed"), s = o.top + t.clientTop, l = o.left + t.clientLeft, d = Gt(t) ? Fr(t) : Nn(1), u = t.clientWidth * d.x, f = t.clientHeight * d.y, h = l * d.x, m = s * d.y; return { width: u, height: f, x: h, y: m } } function tm(t, r, o) { let s; if (r === "viewport") s = Eb(t, o); else if (r === "document") s = Pb(dn(t)); else if (Kt(r)) s = Tb(r, o); else { const l = Jh(t); s = { ...r, x: r.x - l.x, y: r.y - l.y } } return ts(s) } function nm(t, r) { const o = Ln(t); return o === r || !Kt(o) || Vr(o) ? !1 : jt(o).position === "fixed" || nm(o, r) } function Rb(t, r) { const o = r.get(t); if (o) return o; let s = Uo(t, [], !1).filter(f => Kt(f) && Ir(f) !== "body"), l = null; const d = jt(t).position === "fixed"; let u = d ? Ln(t) : t; for (; Kt(u) && !Vr(u);) { const f = jt(u), h = Gl(u); !h && f.position === "fixed" && (l = null), (d ? !h && !l : !h && f.position === "static" && !!l && ["absolute", "fixed"].includes(l.position) || Bo(u) && !h && nm(t, u)) ? s = s.filter(v => v !== u) : l = f, u = Ln(u) } return r.set(t, s), s } function Ab(t) { let { element: r, boundary: o, rootBoundary: s, strategy: l } = t; const u = [...o === "clippingAncestors" ? ns(r) ? [] : Rb(r, this._c) : [].concat(o), s], f = u[0], h = u.reduce((m, v) => { const g = tm(r, v, l); return m.top = yt(g.top, m.top), m.right = Ht(g.right, m.right), m.bottom = Ht(g.bottom, m.bottom), m.left = yt(g.left, m.left), m }, tm(r, f, l)); return { width: h.right - h.left, height: h.bottom - h.top, x: h.left, y: h.top } } function Nb(t) { const { width: r, height: o } = Zh(t); return { width: r, height: o } } function Mb(t, r, o) { const s = Gt(r), l = dn(r), d = o === "fixed", u = ar(t, !0, d, r); let f = { scrollLeft: 0, scrollTop: 0 }; const h = Nn(0); if (s || !s && !d) if ((Ir(r) !== "body" || Bo(l)) && (f = rs(r)), s) { const g = ar(r, !0, d, r); h.x = g.x + r.clientLeft, h.y = g.y + r.clientTop } else l && (h.x = em(l)); const m = u.left + f.scrollLeft - h.x, v = u.top + f.scrollTop - h.y; return { x: m, y: v, width: u.width, height: u.height } } function Ql(t) { return jt(t).position === "static" } function rm(t, r) { return !Gt(t) || jt(t).position === "fixed" ? null : r ? r(t) : t.offsetParent } function om(t, r) { const o = wt(t); if (ns(t)) return o; if (!Gt(t)) { let l = Ln(t); for (; l && !Vr(l);) { if (Kt(l) && !Ql(l)) return l; l = Ln(l) } return o } let s = rm(t, r); for (; s && wb(s) && Ql(s);)s = rm(s, r); return s && Vr(s) && Ql(s) && !Gl(s) ? o : s || xb(t) || o } const Lb = async function (t) { const r = this.getOffsetParent || om, o = this.getDimensions, s = await o(t.floating); return { reference: Mb(t.reference, await r(t.floating), t.strategy), floating: { x: 0, y: 0, width: s.width, height: s.height } } }; function Db(t) { return jt(t).direction === "rtl" } const jb = { convertOffsetParentRelativeRectToViewportRelativeRect: bb, getDocumentElement: dn, getClippingRect: Ab, getOffsetParent: om, getElementRects: Lb, getClientRects: kb, getDimensions: Nb, getScale: Fr, isElement: Kt, isRTL: Db }; function Ob(t, r) { let o = null, s; const l = dn(t); function d() { var f; clearTimeout(s), (f = o) == null || f.disconnect(), o = null } function u(f, h) { f === void 0 && (f = !1), h === void 0 && (h = 1), d(); const { left: m, top: v, width: g, height: w } = t.getBoundingClientRect(); if (f || r(), !g || !w) return; const C = Ji(v), b = Ji(l.clientWidth - (m + g)), S = Ji(l.clientHeight - (v + w)), P = Ji(m), N = { rootMargin: -C + "px " + -b + "px " + -S + "px " + -P + "px", threshold: yt(0, Ht(1, h)) || 1 }; let L = !0; function j(I) { const K = I[0].intersectionRatio; if (K !== h) { if (!L) return u(); K ? u(!1, K) : s = setTimeout(() => { u(!1, 1e-7) }, 1e3) } L = !1 } try { o = new IntersectionObserver(j, { ...N, root: l.ownerDocument }) } catch { o = new IntersectionObserver(j, N) } o.observe(t) } return u(!0), d } function _b(t, r, o, s) { s === void 0 && (s = {}); const { ancestorScroll: l = !0, ancestorResize: d = !0, elementResize: u = typeof ResizeObserver == "function", layoutShift: f = typeof IntersectionObserver == "function", animationFrame: h = !1 } = s, m = Xl(t), v = l || d ? [...m ? Uo(m) : [], ...Uo(r)] : []; v.forEach(R => { l && R.addEventListener("scroll", o, { passive: !0 }), d && R.addEventListener("resize", o) }); const g = m && f ? Ob(m, o) : null; let w = -1, C = null; u && (C = new ResizeObserver(R => { let [N] = R; N && N.target === m && C && (C.unobserve(r), cancelAnimationFrame(w), w = requestAnimationFrame(() => { var L; (L = C) == null || L.observe(r) })), o() }), m && !h && C.observe(m), C.observe(r)); let b, S = h ? ar(t) : null; h && P(); function P() { const R = ar(t); S && (R.x !== S.x || R.y !== S.y || R.width !== S.width || R.height !== S.height) && o(), S = R, b = requestAnimationFrame(P) } return o(), () => { var R; v.forEach(N => { l && N.removeEventListener("scroll", o), d && N.removeEventListener("resize", o) }), g?.(), (R = C) == null || R.disconnect(), C = null, h && cancelAnimationFrame(b) } } const Ib = mb, Vb = gb, Fb = fb, zb = yb, Bb = pb, im = db, Ub = vb, Wb = (t, r, o) => { const s = new Map, l = { platform: jb, ...o }, d = { ...l.platform, _c: s }; return cb(t, r, { ...l, platform: d }) }; var os = typeof document < "u" ? x.useLayoutEffect : x.useEffect; function is(t, r) { if (t === r) return !0; if (typeof t != typeof r) return !1; if (typeof t == "function" && t.toString() === r.toString()) return !0; let o, s, l; if (t && r && typeof t == "object") { if (Array.isArray(t)) { if (o = t.length, o !== r.length) return !1; for (s = o; s-- !== 0;)if (!is(t[s], r[s])) return !1; return !0 } if (l = Object.keys(t), o = l.length, o !== Object.keys(r).length) return !1; for (s = o; s-- !== 0;)if (!{}.hasOwnProperty.call(r, l[s])) return !1; for (s = o; s-- !== 0;) { const d = l[s]; if (!(d === "_owner" && t.$$typeof) && !is(t[d], r[d])) return !1 } return !0 } return t !== t && r !== r } function sm(t) { return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1 } function am(t, r) { const o = sm(t); return Math.round(r * o) / o } function lm(t) { const r = x.useRef(t); return os(() => { r.current = t }), r } function $b(t) { t === void 0 && (t = {}); const { placement: r = "bottom", strategy: o = "absolute", middleware: s = [], platform: l, elements: { reference: d, floating: u } = {}, transform: f = !0, whileElementsMounted: h, open: m } = t, [v, g] = x.useState({ x: 0, y: 0, strategy: o, placement: r, middlewareData: {}, isPositioned: !1 }), [w, C] = x.useState(s); is(w, s) || C(s); const [b, S] = x.useState(null), [P, R] = x.useState(null), N = x.useCallback(G => { G !== K.current && (K.current = G, S(G)) }, []), L = x.useCallback(G => { G !== H.current && (H.current = G, R(G)) }, []), j = d || b, I = u || P, K = x.useRef(null), H = x.useRef(null), W = x.useRef(v), le = h != null, ie = lm(h), ge = lm(l), J = x.useCallback(() => { if (!K.current || !H.current) return; const G = { placement: r, strategy: o, middleware: w }; ge.current && (G.platform = ge.current), Wb(K.current, H.current, G).then(F => { const Y = { ...F, isPositioned: !0 }; Se.current && !is(W.current, Y) && (W.current = Y, xo.flushSync(() => { g(Y) })) }) }, [w, r, o, ge]); os(() => { m === !1 && W.current.isPositioned && (W.current.isPositioned = !1, g(G => ({ ...G, isPositioned: !1 }))) }, [m]); const Se = x.useRef(!1); os(() => (Se.current = !0, () => { Se.current = !1 }), []), os(() => { if (j && (K.current = j), I && (H.current = I), j && I) { if (ie.current) return ie.current(j, I, J); J() } }, [j, I, J, ie, le]); const ne = x.useMemo(() => ({ reference: K, floating: H, setReference: N, setFloating: L }), [N, L]), oe = x.useMemo(() => ({ reference: j, floating: I }), [j, I]), ue = x.useMemo(() => { const G = { position: o, left: 0, top: 0 }; if (!oe.floating) return G; const F = am(oe.floating, v.x), Y = am(oe.floating, v.y); return f ? { ...G, transform: "translate(" + F + "px, " + Y + "px)", ...sm(oe.floating) >= 1.5 && { willChange: "transform" } } : { position: o, left: F, top: Y } }, [o, f, oe.floating, v.x, v.y]); return x.useMemo(() => ({ ...v, update: J, refs: ne, elements: oe, floatingStyles: ue }), [v, J, ne, oe, ue]) } const Hb = t => { function r(o) { return {}.hasOwnProperty.call(o, "current") } return { name: "arrow", options: t, fn(o) { const { element: s, padding: l } = typeof t == "function" ? t(o) : t; return s && r(s) ? s.current != null ? im({ element: s.current, padding: l }).fn(o) : {} : s ? im({ element: s, padding: l }).fn(o) : {} } } }, Kb = (t, r) => ({ ...Ib(t), options: [t, r] }), Gb = (t, r) => ({ ...Vb(t), options: [t, r] }), Yb = (t, r) => ({ ...Ub(t), options: [t, r] }), Xb = (t, r) => ({ ...Fb(t), options: [t, r] }), Qb = (t, r) => ({ ...zb(t), options: [t, r] }), qb = (t, r) => ({ ...Bb(t), options: [t, r] }), Zb = (t, r) => ({ ...Hb(t), options: [t, r] }); var Jb = "Arrow", um = x.forwardRef((t, r) => { const { children: o, width: s = 10, height: l = 5, ...d } = t; return T.jsx(ze.svg, { ...d, ref: r, width: s, height: l, viewBox: "0 0 30 10", preserveAspectRatio: "none", children: t.asChild ? o : T.jsx("polygon", { points: "0,0 30,0 15,10" }) }) }); um.displayName = Jb; var ek = um; function tk(t) { const [r, o] = x.useState(void 0); return Et(() => { if (t) { o({ width: t.offsetWidth, height: t.offsetHeight }); const s = new ResizeObserver(l => { if (!Array.isArray(l) || !l.length) return; const d = l[0]; let u, f; if ("borderBoxSize" in d) { const h = d.borderBoxSize, m = Array.isArray(h) ? h[0] : h; u = m.inlineSize, f = m.blockSize } else u = t.offsetWidth, f = t.offsetHeight; o({ width: u, height: f }) }); return s.observe(t, { box: "border-box" }), () => s.unobserve(t) } else o(void 0) }, [t]), r } var cm = "Popper", [dm, fm] = Il(cm), [jT, pm] = dm(cm), hm = "PopperAnchor", mm = x.forwardRef((t, r) => { const { __scopePopper: o, virtualRef: s, ...l } = t, d = pm(hm, o), u = x.useRef(null), f = Je(r, u); return x.useEffect(() => { d.onAnchorChange(s?.current || u.current) }), s ? null : T.jsx(ze.div, { ...l, ref: f }) }); mm.displayName = hm; var ql = "PopperContent", [nk, rk] = dm(ql), gm = x.forwardRef((t, r) => { const { __scopePopper: o, side: s = "bottom", sideOffset: l = 0, align: d = "center", alignOffset: u = 0, arrowPadding: f = 0, avoidCollisions: h = !0, collisionBoundary: m = [], collisionPadding: v = 0, sticky: g = "partial", hideWhenDetached: w = !1, updatePositionStrategy: C = "optimized", onPlaced: b, ...S } = t, P = pm(ql, o), [R, N] = x.useState(null), L = Je(r, Q => N(Q)), [j, I] = x.useState(null), K = tk(j), H = K?.width ?? 0, W = K?.height ?? 0, le = s + (d !== "center" ? "-" + d : ""), ie = typeof v == "number" ? v : { top: 0, right: 0, bottom: 0, left: 0, ...v }, ge = Array.isArray(m) ? m : [m], J = ge.length > 0, Se = { padding: ie, boundary: ge.filter(ik), altBoundary: J }, { refs: ne, floatingStyles: oe, placement: ue, isPositioned: G, middlewareData: F } = $b({ strategy: "fixed", placement: le, whileElementsMounted: (...Q) => _b(...Q, { animationFrame: C === "always" }), elements: { reference: P.anchor }, middleware: [Kb({ mainAxis: l + W, alignmentAxis: u }), h && Gb({ mainAxis: !0, crossAxis: !1, limiter: g === "partial" ? Yb() : void 0, ...Se }), h && Xb({ ...Se }), Qb({ ...Se, apply: ({ elements: Q, rects: ae, availableWidth: ve, availableHeight: ye }) => { const { width: be, height: Re } = ae.reference, Be = Q.floating.style; Be.setProperty("--radix-popper-available-width", `${ve}px`), Be.setProperty("--radix-popper-available-height", `${ye}px`), Be.setProperty("--radix-popper-anchor-width", `${be}px`), Be.setProperty("--radix-popper-anchor-height", `${Re}px`) } }), j && Zb({ element: j, padding: f }), sk({ arrowWidth: H, arrowHeight: W }), w && qb({ strategy: "referenceHidden", ...Se })] }), [Y, X] = wm(ue), E = sr(b); Et(() => { G && E?.() }, [G, E]); const V = F.arrow?.x, ce = F.arrow?.y, se = F.arrow?.centerOffset !== 0, [xe, me] = x.useState(); return Et(() => { R && me(window.getComputedStyle(R).zIndex) }, [R]), T.jsx("div", { ref: ne.setFloating, "data-radix-popper-content-wrapper": "", style: { ...oe, transform: G ? oe.transform : "translate(0, -200%)", minWidth: "max-content", zIndex: xe, "--radix-popper-transform-origin": [F.transformOrigin?.x, F.transformOrigin?.y].join(" "), ...F.hide?.referenceHidden && { visibility: "hidden", pointerEvents: "none" } }, dir: t.dir, children: T.jsx(nk, { scope: o, placedSide: Y, onArrowChange: I, arrowX: V, arrowY: ce, shouldHideArrow: se, children: T.jsx(ze.div, { "data-side": Y, "data-align": X, ...S, ref: L, style: { ...S.style, animation: G ? void 0 : "none" } }) }) }) }); gm.displayName = ql; var vm = "PopperArrow", ok = { top: "bottom", right: "left", bottom: "top", left: "right" }, ym = x.forwardRef(function (r, o) { const { __scopePopper: s, ...l } = r, d = rk(vm, s), u = ok[d.placedSide]; return T.jsx("span", { ref: d.onArrowChange, style: { position: "absolute", left: d.arrowX, top: d.arrowY, [u]: 0, transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[d.placedSide], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[d.placedSide], visibility: d.shouldHideArrow ? "hidden" : void 0 }, children: T.jsx(ek, { ...l, ref: o, style: { ...l.style, display: "block" } }) }) }); ym.displayName = vm; function ik(t) { return t !== null } var sk = t => ({ name: "transformOrigin", options: t, fn(r) { const { placement: o, rects: s, middlewareData: l } = r, u = l.arrow?.centerOffset !== 0, f = u ? 0 : t.arrowWidth, h = u ? 0 : t.arrowHeight, [m, v] = wm(o), g = { start: "0%", center: "50%", end: "100%" }[v], w = (l.arrow?.x ?? 0) + f / 2, C = (l.arrow?.y ?? 0) + h / 2; let b = "", S = ""; return m === "bottom" ? (b = u ? g : `${w}px`, S = `${-h}px`) : m === "top" ? (b = u ? g : `${w}px`, S = `${s.floating.height + h}px`) : m === "right" ? (b = `${-h}px`, S = u ? g : `${C}px`) : m === "left" && (b = `${s.floating.width + h}px`, S = u ? g : `${C}px`), { data: { x: b, y: S } } } }); function wm(t) { const [r, o = "center"] = t.split("-"); return [r, o] } var ak = mm, lk = gm, uk = ym; function ck(t) { const r = x.useRef({ value: t, previous: t }); return x.useMemo(() => (r.current.value !== t && (r.current.previous = r.current.value, r.current.value = t), r.current.previous), [t]) } var dk = "VisuallyHidden", xm = x.forwardRef((t, r) => T.jsx(ze.span, { ...t, ref: r, style: { position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal", ...t.style } })); xm.displayName = dk; var fk = function (t) { if (typeof document > "u") return null; var r = Array.isArray(t) ? t[0] : t; return r.ownerDocument.body }, zr = new WeakMap, ss = new WeakMap, as = {}, Zl = 0, Sm = function (t) { return t && (t.host || Sm(t.parentNode)) }, pk = function (t, r) { return r.map(function (o) { if (t.contains(o)) return o; var s = Sm(o); return s && t.contains(s) ? s : (console.error("aria-hidden", o, "in not contained inside", t, ". Doing nothing"), null) }).filter(function (o) { return !!o }) }, hk = function (t, r, o, s) { var l = pk(r, Array.isArray(t) ? t : [t]); as[o] || (as[o] = new WeakMap); var d = as[o], u = [], f = new Set, h = new Set(l), m = function (g) { !g || f.has(g) || (f.add(g), m(g.parentNode)) }; l.forEach(m); var v = function (g) { !g || h.has(g) || Array.prototype.forEach.call(g.children, function (w) { if (f.has(w)) v(w); else try { var C = w.getAttribute(s), b = C !== null && C !== "false", S = (zr.get(w) || 0) + 1, P = (d.get(w) || 0) + 1; zr.set(w, S), d.set(w, P), u.push(w), S === 1 && b && ss.set(w, !0), P === 1 && w.setAttribute(o, "true"), b || w.setAttribute(s, "true") } catch (R) { console.error("aria-hidden: cannot operate on ", w, R) } }) }; return v(r), f.clear(), Zl++, function () { u.forEach(function (g) { var w = zr.get(g) - 1, C = d.get(g) - 1; zr.set(g, w), d.set(g, C), w || (ss.has(g) || g.removeAttribute(s), ss.delete(g)), C || g.removeAttribute(o) }), Zl--, Zl || (zr = new WeakMap, zr = new WeakMap, ss = new WeakMap, as = {}) } }, mk = function (t, r, o) { o === void 0 && (o = "data-aria-hidden"); var s = Array.from(Array.isArray(t) ? t : [t]), l = r || fk(t); return l ? (s.push.apply(s, Array.from(l.querySelectorAll("[aria-live]"))), hk(s, l, o, "aria-hidden")) : function () { return null } }, Yt = function () { return Yt = Object.assign || function (r) { for (var o, s = 1, l = arguments.length; s < l; s++) { o = arguments[s]; for (var d in o) Object.prototype.hasOwnProperty.call(o, d) && (r[d] = o[d]) } return r }, Yt.apply(this, arguments) }; function Cm(t, r) { var o = {}; for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && r.indexOf(s) < 0 && (o[s] = t[s]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, s = Object.getOwnPropertySymbols(t); l < s.length; l++)r.indexOf(s[l]) < 0 && Object.prototype.propertyIsEnumerable.call(t, s[l]) && (o[s[l]] = t[s[l]]); return o } function gk(t, r, o) { if (o || arguments.length === 2) for (var s = 0, l = r.length, d; s < l; s++)(d || !(s in r)) && (d || (d = Array.prototype.slice.call(r, 0, s)), d[s] = r[s]); return t.concat(d || Array.prototype.slice.call(r)) } typeof SuppressedError == "function" && SuppressedError; var ls = "right-scroll-bar-position", us = "width-before-scroll-bar", vk = "with-scroll-bars-hidden", yk = "--removed-body-scroll-bar-size"; function Jl(t, r) { return typeof t == "function" ? t(r) : t && (t.current = r), t } function wk(t, r) { var o = x.useState(function () { return { value: t, callback: r, facade: { get current() { return o.value }, set current(s) { var l = o.value; l !== s && (o.value = s, o.callback(s, l)) } } } })[0]; return o.callback = r, o.facade } var xk = typeof window < "u" ? x.useLayoutEffect : x.useEffect, bm = new WeakMap; function Sk(t, r) { var o = wk(r || null, function (s) { return t.forEach(function (l) { return Jl(l, s) }) }); return xk(function () { var s = bm.get(o); if (s) { var l = new Set(s), d = new Set(t), u = o.current; l.forEach(function (f) { d.has(f) || Jl(f, null) }), d.forEach(function (f) { l.has(f) || Jl(f, u) }) } bm.set(o, t) }, [t]), o } function Ck(t) { return t } function bk(t, r) { r === void 0 && (r = Ck); var o = [], s = !1, l = { read: function () { if (s) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."); return o.length ? o[o.length - 1] : t }, useMedium: function (d) { var u = r(d, s); return o.push(u), function () { o = o.filter(function (f) { return f !== u }) } }, assignSyncMedium: function (d) { for (s = !0; o.length;) { var u = o; o = [], u.forEach(d) } o = { push: function (f) { return d(f) }, filter: function () { return o } } }, assignMedium: function (d) { s = !0; var u = []; if (o.length) { var f = o; o = [], f.forEach(d), u = o } var h = function () { var v = u; u = [], v.forEach(d) }, m = function () { return Promise.resolve().then(h) }; m(), o = { push: function (v) { u.push(v), m() }, filter: function (v) { return u = u.filter(v), o } } } }; return l } function kk(t) { t === void 0 && (t = {}); var r = bk(null); return r.options = Yt({ async: !0, ssr: !1 }, t), r } var km = function (t) { var r = t.sideCar, o = Cm(t, ["sideCar"]); if (!r) throw new Error("Sidecar: please provide `sideCar` property to import the right car"); var s = r.read(); if (!s) throw new Error("Sidecar medium not found"); return x.createElement(s, Yt({}, o)) }; km.isSideCarExport = !0; function Pk(t, r) { return t.useMedium(r), km } var Pm = kk(), eu = function () { }, cs = x.forwardRef(function (t, r) { var o = x.useRef(null), s = x.useState({ onScrollCapture: eu, onWheelCapture: eu, onTouchMoveCapture: eu }), l = s[0], d = s[1], u = t.forwardProps, f = t.children, h = t.className, m = t.removeScrollBar, v = t.enabled, g = t.shards, w = t.sideCar, C = t.noIsolation, b = t.inert, S = t.allowPinchZoom, P = t.as, R = P === void 0 ? "div" : P, N = t.gapMode, L = Cm(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), j = w, I = Sk([o, r]), K = Yt(Yt({}, L), l); return x.createElement(x.Fragment, null, v && x.createElement(j, { sideCar: Pm, removeScrollBar: m, shards: g, noIsolation: C, inert: b, setCallbacks: d, allowPinchZoom: !!S, lockRef: o, gapMode: N }), u ? x.cloneElement(x.Children.only(f), Yt(Yt({}, K), { ref: I })) : x.createElement(R, Yt({}, K, { className: h, ref: I }), f)) }); cs.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }, cs.classNames = { fullWidth: us, zeroRight: ls }; var Em, Ek = function () { if (Em) return Em; if (typeof __webpack_nonce__ < "u") return __webpack_nonce__ }; function Tk() { if (!document) return null; var t = document.createElement("style"); t.type = "text/css"; var r = Ek(); return r && t.setAttribute("nonce", r), t } function Rk(t, r) { t.styleSheet ? t.styleSheet.cssText = r : t.appendChild(document.createTextNode(r)) } function Ak(t) { var r = document.head || document.getElementsByTagName("head")[0]; r.appendChild(t) } var Nk = function () { var t = 0, r = null; return { add: function (o) { t == 0 && (r = Tk()) && (Rk(r, o), Ak(r)), t++ }, remove: function () { t--, !t && r && (r.parentNode && r.parentNode.removeChild(r), r = null) } } }, Mk = function () { var t = Nk(); return function (r, o) { x.useEffect(function () { return t.add(r), function () { t.remove() } }, [r && o]) } }, Tm = function () { var t = Mk(), r = function (o) { var s = o.styles, l = o.dynamic; return t(s, l), null }; return r }, Lk = { left: 0, top: 0, right: 0, gap: 0 }, tu = function (t) { return parseInt(t || "", 10) || 0 }, Dk = function (t) { var r = window.getComputedStyle(document.body), o = r[t === "padding" ? "paddingLeft" : "marginLeft"], s = r[t === "padding" ? "paddingTop" : "marginTop"], l = r[t === "padding" ? "paddingRight" : "marginRight"]; return [tu(o), tu(s), tu(l)] }, jk = function (t) { if (t === void 0 && (t = "margin"), typeof window > "u") return Lk; var r = Dk(t), o = document.documentElement.clientWidth, s = window.innerWidth; return { left: r[0], top: r[1], right: r[2], gap: Math.max(0, s - o + r[2] - r[0]) } }, Ok = Tm(), Br = "data-scroll-locked", _k = function (t, r, o, s) {
    var l = t.left, d = t.top, u = t.right, f = t.gap; return o === void 0 && (o = "margin"), `
  .`.concat(vk, ` {
   overflow: hidden `).concat(s, `;
   padding-right: `).concat(f, "px ").concat(s, `;
  }
  body[`).concat(Br, `] {
    overflow: hidden `).concat(s, `;
    overscroll-behavior: contain;
    `).concat([r && "position: relative ".concat(s, ";"), o === "margin" && `
    padding-left: `.concat(l, `px;
    padding-top: `).concat(d, `px;
    padding-right: `).concat(u, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(f, "px ").concat(s, `;
    `), o === "padding" && "padding-right: ".concat(f, "px ").concat(s, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(ls, ` {
    right: `).concat(f, "px ").concat(s, `;
  }
  
  .`).concat(us, ` {
    margin-right: `).concat(f, "px ").concat(s, `;
  }
  
  .`).concat(ls, " .").concat(ls, ` {
    right: 0 `).concat(s, `;
  }
  
  .`).concat(us, " .").concat(us, ` {
    margin-right: 0 `).concat(s, `;
  }
  
  body[`).concat(Br, `] {
    `).concat(yk, ": ").concat(f, `px;
  }
`)
  }, Rm = function () { var t = parseInt(document.body.getAttribute(Br) || "0", 10); return isFinite(t) ? t : 0 }, Ik = function () { x.useEffect(function () { return document.body.setAttribute(Br, (Rm() + 1).toString()), function () { var t = Rm() - 1; t <= 0 ? document.body.removeAttribute(Br) : document.body.setAttribute(Br, t.toString()) } }, []) }, Vk = function (t) { var r = t.noRelative, o = t.noImportant, s = t.gapMode, l = s === void 0 ? "margin" : s; Ik(); var d = x.useMemo(function () { return jk(l) }, [l]); return x.createElement(Ok, { styles: _k(d, !r, l, o ? "" : "!important") }) }, nu = !1; if (typeof window < "u") try { var ds = Object.defineProperty({}, "passive", { get: function () { return nu = !0, !0 } }); window.addEventListener("test", ds, ds), window.removeEventListener("test", ds, ds) } catch { nu = !1 } var Ur = nu ? { passive: !1 } : !1, Fk = function (t) { return t.tagName === "TEXTAREA" }, Am = function (t, r) { var o = window.getComputedStyle(t); return o[r] !== "hidden" && !(o.overflowY === o.overflowX && !Fk(t) && o[r] === "visible") }, zk = function (t) { return Am(t, "overflowY") }, Bk = function (t) { return Am(t, "overflowX") }, Nm = function (t, r) { var o = r.ownerDocument, s = r; do { typeof ShadowRoot < "u" && s instanceof ShadowRoot && (s = s.host); var l = Mm(t, s); if (l) { var d = Lm(t, s), u = d[1], f = d[2]; if (u > f) return !0 } s = s.parentNode } while (s && s !== o.body); return !1 }, Uk = function (t) { var r = t.scrollTop, o = t.scrollHeight, s = t.clientHeight; return [r, o, s] }, Wk = function (t) { var r = t.scrollLeft, o = t.scrollWidth, s = t.clientWidth; return [r, o, s] }, Mm = function (t, r) { return t === "v" ? zk(r) : Bk(r) }, Lm = function (t, r) { return t === "v" ? Uk(r) : Wk(r) }, $k = function (t, r) { return t === "h" && r === "rtl" ? -1 : 1 }, Hk = function (t, r, o, s, l) { var d = $k(t, window.getComputedStyle(r).direction), u = d * s, f = o.target, h = r.contains(f), m = !1, v = u > 0, g = 0, w = 0; do { var C = Lm(t, f), b = C[0], S = C[1], P = C[2], R = S - P - d * b; (b || R) && Mm(t, f) && (g += R, w += b), f instanceof ShadowRoot ? f = f.host : f = f.parentNode } while (!h && f !== document.body || h && (r.contains(f) || r === f)); return (v && (l && Math.abs(g) < 1 || !l && u > g) || !v && (l && Math.abs(w) < 1 || !l && -u > w)) && (m = !0), m }, fs = function (t) { return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0] }, Dm = function (t) { return [t.deltaX, t.deltaY] }, jm = function (t) { return t && "current" in t ? t.current : t }, Kk = function (t, r) { return t[0] === r[0] && t[1] === r[1] }, Gk = function (t) {
    return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`)
  }, Yk = 0, Wr = []; function Xk(t) { var r = x.useRef([]), o = x.useRef([0, 0]), s = x.useRef(), l = x.useState(Yk++)[0], d = x.useState(Tm)[0], u = x.useRef(t); x.useEffect(function () { u.current = t }, [t]), x.useEffect(function () { if (t.inert) { document.body.classList.add("block-interactivity-".concat(l)); var S = gk([t.lockRef.current], (t.shards || []).map(jm), !0).filter(Boolean); return S.forEach(function (P) { return P.classList.add("allow-interactivity-".concat(l)) }), function () { document.body.classList.remove("block-interactivity-".concat(l)), S.forEach(function (P) { return P.classList.remove("allow-interactivity-".concat(l)) }) } } }, [t.inert, t.lockRef.current, t.shards]); var f = x.useCallback(function (S, P) { if ("touches" in S && S.touches.length === 2) return !u.current.allowPinchZoom; var R = fs(S), N = o.current, L = "deltaX" in S ? S.deltaX : N[0] - R[0], j = "deltaY" in S ? S.deltaY : N[1] - R[1], I, K = S.target, H = Math.abs(L) > Math.abs(j) ? "h" : "v"; if ("touches" in S && H === "h" && K.type === "range") return !1; var W = Nm(H, K); if (!W) return !0; if (W ? I = H : (I = H === "v" ? "h" : "v", W = Nm(H, K)), !W) return !1; if (!s.current && "changedTouches" in S && (L || j) && (s.current = I), !I) return !0; var le = s.current || I; return Hk(le, P, S, le === "h" ? L : j, !0) }, []), h = x.useCallback(function (S) { var P = S; if (!(!Wr.length || Wr[Wr.length - 1] !== d)) { var R = "deltaY" in P ? Dm(P) : fs(P), N = r.current.filter(function (I) { return I.name === P.type && (I.target === P.target || P.target === I.shadowParent) && Kk(I.delta, R) })[0]; if (N && N.should) { P.cancelable && P.preventDefault(); return } if (!N) { var L = (u.current.shards || []).map(jm).filter(Boolean).filter(function (I) { return I.contains(P.target) }), j = L.length > 0 ? f(P, L[0]) : !u.current.noIsolation; j && P.cancelable && P.preventDefault() } } }, []), m = x.useCallback(function (S, P, R, N) { var L = { name: S, delta: P, target: R, should: N, shadowParent: Qk(R) }; r.current.push(L), setTimeout(function () { r.current = r.current.filter(function (j) { return j !== L }) }, 1) }, []), v = x.useCallback(function (S) { o.current = fs(S), s.current = void 0 }, []), g = x.useCallback(function (S) { m(S.type, Dm(S), S.target, f(S, t.lockRef.current)) }, []), w = x.useCallback(function (S) { m(S.type, fs(S), S.target, f(S, t.lockRef.current)) }, []); x.useEffect(function () { return Wr.push(d), t.setCallbacks({ onScrollCapture: g, onWheelCapture: g, onTouchMoveCapture: w }), document.addEventListener("wheel", h, Ur), document.addEventListener("touchmove", h, Ur), document.addEventListener("touchstart", v, Ur), function () { Wr = Wr.filter(function (S) { return S !== d }), document.removeEventListener("wheel", h, Ur), document.removeEventListener("touchmove", h, Ur), document.removeEventListener("touchstart", v, Ur) } }, []); var C = t.removeScrollBar, b = t.inert; return x.createElement(x.Fragment, null, b ? x.createElement(d, { styles: Gk(l) }) : null, C ? x.createElement(Vk, { gapMode: t.gapMode }) : null) } function Qk(t) { for (var r = null; t !== null;)t instanceof ShadowRoot && (r = t.host, t = t.host), t = t.parentNode; return r } const qk = Pk(Pm, Xk); var Om = x.forwardRef(function (t, r) { return x.createElement(cs, Yt({}, t, { ref: r, sideCar: qk })) }); Om.classNames = cs.classNames; const Zk = Om; var Jk = [" ", "Enter", "ArrowUp", "ArrowDown"], eP = [" ", "Enter"], ps = "Select", [ru, hs, tP] = IC(ps), [$r, OT] = Il(ps, [tP, fm]), ou = fm(), [_T, Dn] = $r(ps), [IT, nP] = $r(ps), _m = "SelectTrigger", Im = x.forwardRef((t, r) => { const { __scopeSelect: o, disabled: s = !1, ...l } = t, d = ou(o), u = Dn(_m, o), f = u.disabled || s, h = Je(r, u.onTriggerChange), m = hs(o), [v, g, w] = og(b => { const S = m().filter(N => !N.disabled), P = S.find(N => N.value === u.value), R = ig(S, b, P); R !== void 0 && u.onValueChange(R.value) }), C = () => { f || (u.onOpenChange(!0), w()) }; return T.jsx(ak, { asChild: !0, ...d, children: T.jsx(ze.button, { type: "button", role: "combobox", "aria-controls": u.contentId, "aria-expanded": u.open, "aria-required": u.required, "aria-autocomplete": "none", dir: u.dir, "data-state": u.open ? "open" : "closed", disabled: f, "data-disabled": f ? "" : void 0, "data-placeholder": rg(u.value) ? "" : void 0, ...l, ref: h, onClick: Ge(l.onClick, b => { b.currentTarget.focus() }), onPointerDown: Ge(l.onPointerDown, b => { const S = b.target; S.hasPointerCapture(b.pointerId) && S.releasePointerCapture(b.pointerId), b.button === 0 && b.ctrlKey === !1 && (C(), u.triggerPointerDownPosRef.current = { x: Math.round(b.pageX), y: Math.round(b.pageY) }, b.preventDefault()) }), onKeyDown: Ge(l.onKeyDown, b => { const S = v.current !== ""; !(b.ctrlKey || b.altKey || b.metaKey) && b.key.length === 1 && g(b.key), !(S && b.key === " ") && Jk.includes(b.key) && (C(), b.preventDefault()) }) }) }) }); Im.displayName = _m; var Vm = "SelectValue", rP = x.forwardRef((t, r) => { const { __scopeSelect: o, className: s, style: l, children: d, placeholder: u = "", ...f } = t, h = Dn(Vm, o), { onValueNodeHasChildrenChange: m } = h, v = d !== void 0, g = Je(r, h.onValueNodeChange); return Et(() => { m(v) }, [m, v]), T.jsx(ze.span, { ...f, ref: g, style: { pointerEvents: "none" }, children: rg(h.value) ? T.jsx(T.Fragment, { children: u }) : d }) }); rP.displayName = Vm; var oP = "SelectIcon", Fm = x.forwardRef((t, r) => { const { __scopeSelect: o, children: s, ...l } = t; return T.jsx(ze.span, { "aria-hidden": !0, ...l, ref: r, children: s || "" }) }); Fm.displayName = oP; var lr = "SelectContent", zm = x.forwardRef((t, r) => { const o = Dn(lr, t.__scopeSelect), [s, l] = x.useState(); if (Et(() => { l(new DocumentFragment) }, []), !o.open) { const d = s; return d ? xo.createPortal(T.jsx(Bm, { scope: t.__scopeSelect, children: T.jsx(ru.Slot, { scope: t.__scopeSelect, children: T.jsx("div", { children: t.children }) }) }), d) : null } return T.jsx(Um, { ...t, ref: r }) }); zm.displayName = lr; var fn = 10, [Bm, jn] = $r(lr), iP = "SelectContentImpl", Um = x.forwardRef((t, r) => { const { __scopeSelect: o, position: s = "item-aligned", onCloseAutoFocus: l, onEscapeKeyDown: d, onPointerDownOutside: u, side: f, sideOffset: h, align: m, alignOffset: v, arrowPadding: g, collisionBoundary: w, collisionPadding: C, sticky: b, hideWhenDetached: S, avoidCollisions: P, ...R } = t, N = Dn(lr, o), [L, j] = x.useState(null), [I, K] = x.useState(null), H = Je(r, Q => j(Q)), [W, le] = x.useState(null), [ie, ge] = x.useState(null), J = hs(o), [Se, ne] = x.useState(!1), oe = x.useRef(!1); x.useEffect(() => { if (L) return mk(L) }, [L]), KC(); const ue = x.useCallback(Q => { const [ae, ...ve] = J().map(Re => Re.ref.current), [ye] = ve.slice(-1), be = document.activeElement; for (const Re of Q) if (Re === be || (Re?.scrollIntoView({ block: "nearest" }), Re === ae && I && (I.scrollTop = 0), Re === ye && I && (I.scrollTop = I.scrollHeight), Re?.focus(), document.activeElement !== be)) return }, [J, I]), G = x.useCallback(() => ue([W, L]), [ue, W, L]); x.useEffect(() => { Se && G() }, [Se, G]); const { onOpenChange: F, triggerPointerDownPosRef: Y } = N; x.useEffect(() => { if (L) { let Q = { x: 0, y: 0 }; const ae = ye => { Q = { x: Math.abs(Math.round(ye.pageX) - (Y.current?.x ?? 0)), y: Math.abs(Math.round(ye.pageY) - (Y.current?.y ?? 0)) } }, ve = ye => { Q.x <= 10 && Q.y <= 10 ? ye.preventDefault() : L.contains(ye.target) || F(!1), document.removeEventListener("pointermove", ae), Y.current = null }; return Y.current !== null && (document.addEventListener("pointermove", ae), document.addEventListener("pointerup", ve, { capture: !0, once: !0 })), () => { document.removeEventListener("pointermove", ae), document.removeEventListener("pointerup", ve, { capture: !0 }) } } }, [L, F, Y]), x.useEffect(() => { const Q = () => F(!1); return window.addEventListener("blur", Q), window.addEventListener("resize", Q), () => { window.removeEventListener("blur", Q), window.removeEventListener("resize", Q) } }, [F]); const [X, E] = og(Q => { const ae = J().filter(be => !be.disabled), ve = ae.find(be => be.ref.current === document.activeElement), ye = ig(ae, Q, ve); ye && setTimeout(() => ye.ref.current.focus()) }), V = x.useCallback((Q, ae, ve) => { const ye = !oe.current && !ve; (N.value !== void 0 && N.value === ae || ye) && (le(Q), ye && (oe.current = !0)) }, [N.value]), ce = x.useCallback(() => L?.focus(), [L]), se = x.useCallback((Q, ae, ve) => { const ye = !oe.current && !ve; (N.value !== void 0 && N.value === ae || ye) && ge(Q) }, [N.value]), xe = s === "popper" ? iu : Wm, me = xe === iu ? { side: f, sideOffset: h, align: m, alignOffset: v, arrowPadding: g, collisionBoundary: w, collisionPadding: C, sticky: b, hideWhenDetached: S, avoidCollisions: P } : {}; return T.jsx(Bm, { scope: o, content: L, viewport: I, onViewportChange: K, itemRefCallback: V, selectedItem: W, onItemLeave: ce, itemTextRefCallback: se, focusSelectedItem: G, selectedItemText: ie, position: s, isPositioned: Se, searchRef: X, children: T.jsx(Zk, { as: Or, allowPinchZoom: !0, children: T.jsx(Fh, { asChild: !0, trapped: N.open, onMountAutoFocus: Q => { Q.preventDefault() }, onUnmountAutoFocus: Ge(l, Q => { N.trigger?.focus({ preventScroll: !0 }), Q.preventDefault() }), children: T.jsx(jh, { asChild: !0, disableOutsidePointerEvents: !0, onEscapeKeyDown: d, onPointerDownOutside: u, onFocusOutside: Q => Q.preventDefault(), onDismiss: () => N.onOpenChange(!1), children: T.jsx(xe, { role: "listbox", id: N.contentId, "data-state": N.open ? "open" : "closed", dir: N.dir, onContextMenu: Q => Q.preventDefault(), ...R, ...me, onPlaced: () => ne(!0), ref: H, style: { display: "flex", flexDirection: "column", outline: "none", ...R.style }, onKeyDown: Ge(R.onKeyDown, Q => { const ae = Q.ctrlKey || Q.altKey || Q.metaKey; if (Q.key === "Tab" && Q.preventDefault(), !ae && Q.key.length === 1 && E(Q.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(Q.key)) { let ye = J().filter(be => !be.disabled).map(be => be.ref.current); if (["ArrowUp", "End"].includes(Q.key) && (ye = ye.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(Q.key)) { const be = Q.target, Re = ye.indexOf(be); ye = ye.slice(Re + 1) } setTimeout(() => ue(ye)), Q.preventDefault() } }) }) }) }) }) }) }); Um.displayName = iP; var sP = "SelectItemAlignedPosition", Wm = x.forwardRef((t, r) => { const { __scopeSelect: o, onPlaced: s, ...l } = t, d = Dn(lr, o), u = jn(lr, o), [f, h] = x.useState(null), [m, v] = x.useState(null), g = Je(r, H => v(H)), w = hs(o), C = x.useRef(!1), b = x.useRef(!0), { viewport: S, selectedItem: P, selectedItemText: R, focusSelectedItem: N } = u, L = x.useCallback(() => { if (d.trigger && d.valueNode && f && m && S && P && R) { const H = d.trigger.getBoundingClientRect(), W = m.getBoundingClientRect(), le = d.valueNode.getBoundingClientRect(), ie = R.getBoundingClientRect(); if (d.dir !== "rtl") { const be = ie.left - W.left, Re = le.left - be, Be = H.left - Re, Ot = H.width + Be, Hr = Math.max(Ot, W.width), Kr = window.innerWidth - fn, ur = Mh(Re, [fn, Kr - Hr]); f.style.minWidth = Ot + "px", f.style.left = ur + "px" } else { const be = W.right - ie.right, Re = window.innerWidth - le.right - be, Be = window.innerWidth - H.right - Re, Ot = H.width + Be, Hr = Math.max(Ot, W.width), Kr = window.innerWidth - fn, ur = Mh(Re, [fn, Kr - Hr]); f.style.minWidth = Ot + "px", f.style.right = ur + "px" } const ge = w(), J = window.innerHeight - fn * 2, Se = S.scrollHeight, ne = window.getComputedStyle(m), oe = parseInt(ne.borderTopWidth, 10), ue = parseInt(ne.paddingTop, 10), G = parseInt(ne.borderBottomWidth, 10), F = parseInt(ne.paddingBottom, 10), Y = oe + ue + Se + F + G, X = Math.min(P.offsetHeight * 5, Y), E = window.getComputedStyle(S), V = parseInt(E.paddingTop, 10), ce = parseInt(E.paddingBottom, 10), se = H.top + H.height / 2 - fn, xe = J - se, me = P.offsetHeight / 2, Q = P.offsetTop + me, ae = oe + ue + Q, ve = Y - ae; if (ae <= se) { const be = P === ge[ge.length - 1].ref.current; f.style.bottom = "0px"; const Re = m.clientHeight - S.offsetTop - S.offsetHeight, Be = Math.max(xe, me + (be ? ce : 0) + Re + G), Ot = ae + Be; f.style.height = Ot + "px" } else { const be = P === ge[0].ref.current; f.style.top = "0px"; const Be = Math.max(se, oe + S.offsetTop + (be ? V : 0) + me) + ve; f.style.height = Be + "px", S.scrollTop = ae - se + S.offsetTop } f.style.margin = `${fn}px 0`, f.style.minHeight = X + "px", f.style.maxHeight = J + "px", s?.(), requestAnimationFrame(() => C.current = !0) } }, [w, d.trigger, d.valueNode, f, m, S, P, R, d.dir, s]); Et(() => L(), [L]); const [j, I] = x.useState(); Et(() => { m && I(window.getComputedStyle(m).zIndex) }, [m]); const K = x.useCallback(H => { H && b.current === !0 && (L(), N?.(), b.current = !1) }, [L, N]); return T.jsx(lP, { scope: o, contentWrapper: f, shouldExpandOnScrollRef: C, onScrollButtonChange: K, children: T.jsx("div", { ref: h, style: { display: "flex", flexDirection: "column", position: "fixed", zIndex: j }, children: T.jsx(ze.div, { ...l, ref: g, style: { boxSizing: "border-box", maxHeight: "100%", ...l.style } }) }) }) }); Wm.displayName = sP; var aP = "SelectPopperPosition", iu = x.forwardRef((t, r) => { const { __scopeSelect: o, align: s = "start", collisionPadding: l = fn, ...d } = t, u = ou(o); return T.jsx(lk, { ...u, ...d, ref: r, align: s, collisionPadding: l, style: { boxSizing: "border-box", ...d.style, "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-select-content-available-width": "var(--radix-popper-available-width)", "--radix-select-content-available-height": "var(--radix-popper-available-height)", "--radix-select-trigger-width": "var(--radix-popper-anchor-width)", "--radix-select-trigger-height": "var(--radix-popper-anchor-height)" } }) }); iu.displayName = aP; var [lP, su] = $r(lr, {}), au = "SelectViewport", $m = x.forwardRef((t, r) => { const { __scopeSelect: o, nonce: s, ...l } = t, d = jn(au, o), u = su(au, o), f = Je(r, d.onViewportChange), h = x.useRef(0); return T.jsxs(T.Fragment, { children: [T.jsx("style", { dangerouslySetInnerHTML: { __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}" }, nonce: s }), T.jsx(ru.Slot, { scope: o, children: T.jsx(ze.div, { "data-radix-select-viewport": "", role: "presentation", ...l, ref: f, style: { position: "relative", flex: 1, overflow: "auto", ...l.style }, onScroll: Ge(l.onScroll, m => { const v = m.currentTarget, { contentWrapper: g, shouldExpandOnScrollRef: w } = u; if (w?.current && g) { const C = Math.abs(h.current - v.scrollTop); if (C > 0) { const b = window.innerHeight - fn * 2, S = parseFloat(g.style.minHeight), P = parseFloat(g.style.height), R = Math.max(S, P); if (R < b) { const N = R + C, L = Math.min(b, N), j = N - L; g.style.height = L + "px", g.style.bottom === "0px" && (v.scrollTop = j > 0 ? j : 0, g.style.justifyContent = "flex-end") } } } h.current = v.scrollTop }) }) })] }) }); $m.displayName = au; var Hm = "SelectGroup", [uP, cP] = $r(Hm), dP = x.forwardRef((t, r) => { const { __scopeSelect: o, ...s } = t, l = $h(); return T.jsx(uP, { scope: o, id: l, children: T.jsx(ze.div, { role: "group", "aria-labelledby": l, ...s, ref: r }) }) }); dP.displayName = Hm; var Km = "SelectLabel", Gm = x.forwardRef((t, r) => { const { __scopeSelect: o, ...s } = t, l = cP(Km, o); return T.jsx(ze.div, { id: l.id, ...s, ref: r }) }); Gm.displayName = Km; var ms = "SelectItem", [fP, Ym] = $r(ms), Xm = x.forwardRef((t, r) => { const { __scopeSelect: o, value: s, disabled: l = !1, textValue: d, ...u } = t, f = Dn(ms, o), h = jn(ms, o), m = f.value === s, [v, g] = x.useState(d ?? ""), [w, C] = x.useState(!1), b = Je(r, R => h.itemRefCallback?.(R, s, l)), S = $h(), P = () => { l || (f.onValueChange(s), f.onOpenChange(!1)) }; if (s === "") throw new Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."); return T.jsx(fP, { scope: o, value: s, disabled: l, textId: S, isSelected: m, onItemTextChange: x.useCallback(R => { g(N => N || (R?.textContent ?? "").trim()) }, []), children: T.jsx(ru.ItemSlot, { scope: o, value: s, disabled: l, textValue: v, children: T.jsx(ze.div, { role: "option", "aria-labelledby": S, "data-highlighted": w ? "" : void 0, "aria-selected": m && w, "data-state": m ? "checked" : "unchecked", "aria-disabled": l || void 0, "data-disabled": l ? "" : void 0, tabIndex: l ? void 0 : -1, ...u, ref: b, onFocus: Ge(u.onFocus, () => C(!0)), onBlur: Ge(u.onBlur, () => C(!1)), onPointerUp: Ge(u.onPointerUp, P), onPointerMove: Ge(u.onPointerMove, R => { l ? h.onItemLeave?.() : R.currentTarget.focus({ preventScroll: !0 }) }), onPointerLeave: Ge(u.onPointerLeave, R => { R.currentTarget === document.activeElement && h.onItemLeave?.() }), onKeyDown: Ge(u.onKeyDown, R => { h.searchRef?.current !== "" && R.key === " " || (eP.includes(R.key) && P(), R.key === " " && R.preventDefault()) }) }) }) }) }); Xm.displayName = ms; var Wo = "SelectItemText", Qm = x.forwardRef((t, r) => { const { __scopeSelect: o, className: s, style: l, ...d } = t, u = Dn(Wo, o), f = jn(Wo, o), h = Ym(Wo, o), m = nP(Wo, o), [v, g] = x.useState(null), w = Je(r, R => g(R), h.onItemTextChange, R => f.itemTextRefCallback?.(R, h.value, h.disabled)), C = v?.textContent, b = x.useMemo(() => T.jsx("option", { value: h.value, disabled: h.disabled, children: C }, h.value), [h.disabled, h.value, C]), { onNativeOptionAdd: S, onNativeOptionRemove: P } = m; return Et(() => (S(b), () => P(b)), [S, P, b]), T.jsxs(T.Fragment, { children: [T.jsx(ze.span, { id: h.textId, ...d, ref: w }), h.isSelected && u.valueNode && !u.valueNodeHasChildren ? xo.createPortal(d.children, u.valueNode) : null] }) }); Qm.displayName = Wo; var qm = "SelectItemIndicator", Zm = x.forwardRef((t, r) => { const { __scopeSelect: o, ...s } = t; return Ym(qm, o).isSelected ? T.jsx(ze.span, { "aria-hidden": !0, ...s, ref: r }) : null }); Zm.displayName = qm; var lu = "SelectScrollUpButton", Jm = x.forwardRef((t, r) => { const o = jn(lu, t.__scopeSelect), s = su(lu, t.__scopeSelect), [l, d] = x.useState(!1), u = Je(r, s.onScrollButtonChange); return Et(() => { if (o.viewport && o.isPositioned) { let f = function () { const m = h.scrollTop > 0; d(m) }; const h = o.viewport; return f(), h.addEventListener("scroll", f), () => h.removeEventListener("scroll", f) } }, [o.viewport, o.isPositioned]), l ? T.jsx(tg, { ...t, ref: u, onAutoScroll: () => { const { viewport: f, selectedItem: h } = o; f && h && (f.scrollTop = f.scrollTop - h.offsetHeight) } }) : null }); Jm.displayName = lu; var uu = "SelectScrollDownButton", eg = x.forwardRef((t, r) => { const o = jn(uu, t.__scopeSelect), s = su(uu, t.__scopeSelect), [l, d] = x.useState(!1), u = Je(r, s.onScrollButtonChange); return Et(() => { if (o.viewport && o.isPositioned) { let f = function () { const m = h.scrollHeight - h.clientHeight, v = Math.ceil(h.scrollTop) < m; d(v) }; const h = o.viewport; return f(), h.addEventListener("scroll", f), () => h.removeEventListener("scroll", f) } }, [o.viewport, o.isPositioned]), l ? T.jsx(tg, { ...t, ref: u, onAutoScroll: () => { const { viewport: f, selectedItem: h } = o; f && h && (f.scrollTop = f.scrollTop + h.offsetHeight) } }) : null }); eg.displayName = uu; var tg = x.forwardRef((t, r) => { const { __scopeSelect: o, onAutoScroll: s, ...l } = t, d = jn("SelectScrollButton", o), u = x.useRef(null), f = hs(o), h = x.useCallback(() => { u.current !== null && (window.clearInterval(u.current), u.current = null) }, []); return x.useEffect(() => () => h(), [h]), Et(() => { f().find(v => v.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" }) }, [f]), T.jsx(ze.div, { "aria-hidden": !0, ...l, ref: r, style: { flexShrink: 0, ...l.style }, onPointerDown: Ge(l.onPointerDown, () => { u.current === null && (u.current = window.setInterval(s, 50)) }), onPointerMove: Ge(l.onPointerMove, () => { d.onItemLeave?.(), u.current === null && (u.current = window.setInterval(s, 50)) }), onPointerLeave: Ge(l.onPointerLeave, () => { h() }) }) }), pP = "SelectSeparator", ng = x.forwardRef((t, r) => { const { __scopeSelect: o, ...s } = t; return T.jsx(ze.div, { "aria-hidden": !0, ...s, ref: r }) }); ng.displayName = pP; var cu = "SelectArrow", hP = x.forwardRef((t, r) => { const { __scopeSelect: o, ...s } = t, l = ou(o), d = Dn(cu, o), u = jn(cu, o); return d.open && u.position === "popper" ? T.jsx(uk, { ...l, ...s, ref: r }) : null }); hP.displayName = cu; function rg(t) { return t === "" || t === void 0 } var mP = x.forwardRef((t, r) => { const { value: o, ...s } = t, l = x.useRef(null), d = Je(r, l), u = ck(o); return x.useEffect(() => { const f = l.current, h = window.HTMLSelectElement.prototype, v = Object.getOwnPropertyDescriptor(h, "value").set; if (u !== o && v) { const g = new Event("change", { bubbles: !0 }); v.call(f, o), f.dispatchEvent(g) } }, [u, o]), T.jsx(xm, { asChild: !0, children: T.jsx("select", { ...s, ref: d, defaultValue: o }) }) }); mP.displayName = "BubbleSelect"; function og(t) { const r = sr(t), o = x.useRef(""), s = x.useRef(0), l = x.useCallback(u => { const f = o.current + u; r(f), function h(m) { o.current = m, window.clearTimeout(s.current), m !== "" && (s.current = window.setTimeout(() => h(""), 1e3)) }(f) }, [r]), d = x.useCallback(() => { o.current = "", window.clearTimeout(s.current) }, []); return x.useEffect(() => () => window.clearTimeout(s.current), []), [o, l, d] } function ig(t, r, o) { const l = r.length > 1 && Array.from(r).every(m => m === r[0]) ? r[0] : r, d = o ? t.indexOf(o) : -1; let u = gP(t, Math.max(d, 0)); l.length === 1 && (u = u.filter(m => m !== o)); const h = u.find(m => m.textValue.toLowerCase().startsWith(l.toLowerCase())); return h !== o ? h : void 0 } function gP(t, r) { return t.map((o, s) => t[(r + s) % t.length]) } var sg = Im, vP = Fm, ag = zm, yP = $m, lg = Gm, ug = Xm, wP = Qm, xP = Zm, cg = Jm, dg = eg, fg = ng; const SP = x.forwardRef(({ className: t, children: r, ...o }, s) => T.jsxs(sg, { ref: s, className: Oe("flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1", t), ...o, children: [r, T.jsx(vP, { asChild: !0, children: T.jsx(wd, { className: "h-4 w-4 opacity-50" }) })] })); SP.displayName = sg.displayName; const pg = x.forwardRef(({ className: t, ...r }, o) => T.jsx(cg, { ref: o, className: Oe("flex cursor-default items-center justify-center py-1", t), ...r, children: T.jsx(w0, { className: "h-4 w-4" }) })); pg.displayName = cg.displayName; const hg = x.forwardRef(({ className: t, ...r }, o) => T.jsx(dg, { ref: o, className: Oe("flex cursor-default items-center justify-center py-1", t), ...r, children: T.jsx(wd, { className: "h-4 w-4" }) })); hg.displayName = dg.displayName; const CP = x.forwardRef(({ className: t, children: r, position: o = "popper", ...s }, l) => T.jsxs(ag, { ref: l, className: Oe("relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", o === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", t), position: o, ...s, children: [T.jsx(pg, {}), T.jsx(yP, { className: Oe("p-1", o === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"), children: r }), T.jsx(hg, {})] })); CP.displayName = ag.displayName; const bP = x.forwardRef(({ className: t, ...r }, o) => T.jsx(lg, { ref: o, className: Oe("py-1.5 pl-8 pr-2 text-sm font-semibold", t), ...r })); bP.displayName = lg.displayName; const kP = x.forwardRef(({ className: t, children: r, ...o }, s) => T.jsxs(ug, { ref: s, className: Oe("relative  flex w-full cursor-pointer select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground ", t), ...o, children: [T.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: T.jsx(xP, { children: T.jsx(yd, { className: "h-4 w-4" }) }) }), T.jsx(wP, { children: r })] })); kP.displayName = ug.displayName; const PP = x.forwardRef(({ className: t, ...r }, o) => T.jsx(fg, { ref: o, className: Oe("-mx-1 my-1 h-px bg-muted", t), ...r })); PP.displayName = fg.displayName; const gs = x.forwardRef(({ className: t, ...r }, o) => T.jsx("div", { ref: o, className: Oe("rounded-lg border bg-card text-card-foreground shadow-sm", t), ...r })); gs.displayName = "Card"; const du = x.forwardRef(({ className: t, ...r }, o) => T.jsx("div", { ref: o, className: Oe("flex flex-col space-y-1.5 p-6", t), ...r })); du.displayName = "CardHeader"; const fu = x.forwardRef(({ className: t, ...r }, o) => T.jsx("h3", { ref: o, className: Oe("text-2xl font-semibold leading-none tracking-tight", t), ...r })); fu.displayName = "CardTitle"; const pu = x.forwardRef(({ className: t, ...r }, o) => T.jsx("p", { ref: o, className: Oe("text-sm text-muted-foreground", t), ...r })); pu.displayName = "CardDescription"; const vs = x.forwardRef(({ className: t, ...r }, o) => T.jsx("div", { ref: o, className: Oe("p-6 pt-0", t), ...r })); vs.displayName = "CardContent"; const hu = x.forwardRef(({ className: t, ...r }, o) => T.jsx("div", { ref: o, className: Oe("flex items-center p-6 pt-0", t), ...r })); hu.displayName = "CardFooter"; const mg = { AL: "Alabama", AK: "Alaska", AZ: "Arizona", AR: "Arkansas", CA: "California", CO: "Colorado", CT: "Connecticut", DE: "Delaware", DC: "District Of Columbia", FL: "Florida", GA: "Georgia", GU: "Guam", HI: "Hawaii", ID: "Idaho", IL: "Illinois", IN: "Indiana", IA: "Iowa", KS: "Kansas", KY: "Kentucky", LA: "Louisiana", ME: "Maine", MD: "Maryland", MA: "Massachusetts", MI: "Michigan", MN: "Minnesota", MS: "Mississippi", MO: "Missouri", MT: "Montana", NE: "Nebraska", NV: "Nevada", NH: "New Hampshire", NJ: "New Jersey", NM: "New Mexico", NY: "New York", NC: "North Carolina", ND: "North Dakota", OH: "Ohio", OK: "Oklahoma", OR: "Oregon", PW: "Palau", PA: "Pennsylvania", PR: "Puerto Rico", RI: "Rhode Island", SC: "South Carolina", SD: "South Dakota", TN: "Tennessee", TX: "Texas", UT: "Utah", VT: "Vermont", VI: "Virgin Islands", VA: "Virginia", WA: "Washington", WV: "West Virginia", WI: "Wisconsin", WY: "Wyoming" }, gg = x.forwardRef((t, r) => { const [o, s] = x.useState(t.flowData.flows.data.nodes[0]?.id), [l, d] = x.useState([]), [u, f] = x.useState(0), [h, m] = x.useState([]), [v, g] = x.useState(!1), [w, C] = x.useState(!1), [b, S] = x.useState(!1), [P, R] = x.useState(""), [N, L] = x.useState(""), [j, I] = x.useState(""), [K, H] = x.useState(""), [W, le] = x.useState(""), [ie, ge] = x.useState(""), [J, Se] = x.useState(""), [ne, oe] = x.useState({ length: 0, width: 0, radius: 0 }); x.useEffect(() => { l.length > 0 ? t.onShowGoBackButton() : t.onHideGoBackButton() }, [l]), x.useEffect(() => { d([]), m([]) }, []); const ue = async () => { if (P === "" || N === "" || j === "" || K === "" || W === "" || ie === "") { S(!0); return } const E = { customer: { firstLastName: P, email: N, phone: j, address: K, USAState: W, zip: ie, comments: J }, history: l }; t.onCallSubmit(E) }, G = t.flowData.flows.data.nodes.find(E => E.id === o), F = E => { if (!G) return; let V; if (G.type === "measurements" ? V = { typeofArea: v ? "circular" : "rectangular", length: ne.length, width: ne.width, radius: ne.radius } : V = G.data.metadata.childComponent.handles.find(se => se.id === E)?.content, !V) return; const ce = t.flowData.flows.data.edges.find(se => se.source === o && se.sourceHandle === E); if (ce) { const se = ce.target, xe = !t.flowData.flows.data.edges.some(be => be.source === se), me = l.length + 1, Q = be => { const Re = t.flowData.flows.data.edges.filter(Be => Be.source === be); return Re.length === 0 ? 0 : 1 + Math.max(...Re.map(Be => Q(Be.target))) }, ae = Q(se), ve = me + ae, ye = xe ? 100 : me / ve * 100; f(ye), d([...l, { nodeId: o, question: G.data.metadata.childComponent.question, selectedHandleId: E, answer: V }]), m([...h, ye]), s(se) } else console.log("End of steps or handle not connected."), f(100), m([...h, 100]) }, Y = () => { if (l.length > 0) { const E = l[l.length - 1], V = l.slice(0, l.length - 1), ce = h.slice(0, h.length - 1), se = ce[ce.length - 1] || 0; s(E?.nodeId || ""), d(V), f(se), m(ce) } }, X = E => { le(E) }; return x.useImperativeHandle(r, () => ({ callGoBack() { Y() } })), T.jsx("div", { className: "flex flex-1 w-full mt-2 no-scrollbar overflow-y-scroll flex-col items-center", children: t.flowData.flows.data.nodes.length === 0 || !o ? T.jsxs("div", { className: "flex flex-1 flex-col items-center justify-center space-y-4 text-center", children: [T.jsx("h2", { className: "text-3xl font-bold", children: "Loading..." }), T.jsx("p", { className: "text-muted-foreground", children: "Please wait while we load the questions." }), T.jsx("img", { className: "h-10 w-10 animate-spin text-white opacity-65", src: "/_static/loading.png" })] }) : T.jsxs(T.Fragment, { children: [T.jsx("div", { className: "absolute top-0 h-2 w-full bg-gray-100", children: T.jsx(ir.div, { className: "h-2 bg-black", initial: { width: 0 }, animate: { width: `${u}%` }, transition: { duration: .5 } }) }), G.type != "client_info" && T.jsxs("div", { className: "mb-6 flex min-h-44 w-full flex-col justify-center space-y-4 border-b bg-gray-50 px-3 py-8 text-center", children: [T.jsx("h2", { className: "text-xl font-bold sm:text-3xl", children: G?.data.metadata.childComponent.question }), T.jsx("p", { className: "text-muted-foreground", children: G?.data.metadata.description })] }), ["custom", "start"].includes(G.type) && T.jsx(T.Fragment, { children: G?.data.metadata.childComponent.handles.some(E => E.image) ? T.jsx("div", { className: "grid h-full grid-cols-2 gap-2 md:grid-cols-3 px-2", children: G?.data.metadata.childComponent.handles.map(E => T.jsxs(gs, { className: "cursor-pointer hover:shadow-md flex flex-col", onClick: () => F(E.id), children: [T.jsxs(vs, { className: "flex flex-col flex-1 items-center justify-start p-1.5", children: [T.jsx("img", { src: E.image ? `https://kxfxmsowfzmimavqqned.supabase.co/storage/v1/object/public/qt/assets/${E.image}` : "https://kxfxmsowfzmimavqqned.supabase.co/storage/v1/object/public/qt/assets/placeholder.svg", width: "200", height: "200", alt: E.content, className: "aspect-square overflow-hidden rounded-md object-cover" }), T.jsx("div", { className: "mt-4 text-center", children: T.jsx("h3", { className: "py-3 text-lg font-semibold", children: E.content }) })] }), T.jsx(hu, { className: "px-3 pb-3", children: T.jsx(Fo, { onClick: () => F(E.id), className: "w-full hover:shadow-md", children: "Add to Quote" }) })] }, E.id)) }) : T.jsx("div", { className: "mt-8 flex flex-1 px-3 flex-col items-center justify-center", children: G?.data.metadata.childComponent.handles.map(E => T.jsx(Fo, { onClick: () => F(E.id), className: "mb-4 w-full  min-w-72 p-6 text-xl hover:shadow-md", children: E.content }, E.id)) }) }), G.type == "measurements" && T.jsxs(gs, { className: "w-full max-w-md border-none shadow-none mx-auto p-6 sm:p-8", children: [T.jsxs(du, { children: [T.jsx(fu, { children: "Enter the Area of Your Project" }), T.jsx(pu, { children: "Enter the dimensions of your project area." })] }), w && T.jsxs(Rh, { variant: "destructive", className: "py-3 my-2", children: [T.jsx(x0, { className: "h-4 w-4" }), T.jsx(Ah, { className: "text-left", children: "Error" }), T.jsx(Nh, { className: "text-left", children: "please enter your project area dimensions" })] }), T.jsx(vs, { children: T.jsxs("div", { className: "grid gap-4", children: [v ? T.jsxs("div", { className: "space-y-2", children: [T.jsx(Dt, { htmlFor: "width", children: "Radius Feet" }), T.jsx(ln, { id: "width", type: "number", placeholder: "0", defaultValue: ne.radius, min: "0", onChange: E => { oe({ ...ne, radius: E.target.value }), C(!1) } })] }) : T.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [T.jsxs("div", { className: "space-y-2", children: [T.jsx(Dt, { htmlFor: "length", children: "Length (ft)" }), T.jsx(ln, { id: "length", type: "number", placeholder: "0", defaultValue: ne.length, min: "0", onChange: E => { oe({ ...ne, length: E.target.value }), C(!1) } })] }), T.jsxs("div", { className: "space-y-2", children: [T.jsx(Dt, { htmlFor: "width", children: "Width (ft)" }), T.jsx(ln, { id: "width", type: "number", defaultValue: ne.width, placeholder: "0", min: "0", onChange: E => { C(!1), oe({ ...ne, width: E.target.value }) } })] })] }), T.jsx("div", { className: "flex items-center gap-2", children: T.jsx("div", { className: "cursor-pointer", onClick: () => g(!v), children: T.jsx("p", { children: v ? "My Project Area is Rectangular?" : "My Project Area is Circular?" }) }) }), T.jsx(Fo, { type: "submit", onClick: () => { if (v && ne.radius === 0 || !v && (ne.length === 0 || ne.width === 0)) { C(!0); return } F(G.data.metadata.childComponent.handles[0].id) }, className: "w-full", children: "Submit Project Area" })] }) })] }), G.type == "client_info" && T.jsxs(gs, { className: "my-8 mb-2 w-full border-none shadow-none", children: [T.jsxs(du, { children: [T.jsx(fu, { children: G.data.metadata.childComponent.question }), T.jsx(pu, { children: G.data.metadata.description })] }), T.jsx(vs, { className: "space-y-6", children: T.jsxs("div", { className: "grid gap-4", children: [T.jsxs("div", { className: "grid gap-2 ", children: [T.jsx(Dt, { className: ot("text-left ", b && P.length <= 0 ? "text-red-400" : ""), htmlFor: "name", children: "First & Last Name" }), T.jsx(ln, { onChange: E => { R(E.target.value) }, id: "name", className: ot("grid gap-2 ", b && P.length <= 0 ? "bg-red-50 focus-visible:ring-red-500 border-red-500 focus-visible:border-transparent" : ""), placeholder: "Enter your first and last name" })] }), T.jsxs("div", { className: "grid gap-2", children: [T.jsx(Dt, { className: ot("text-left ", b && N.length <= 0 ? "text-red-400" : ""), htmlFor: "email", children: "Email" }), T.jsx(ln, { onChange: E => { L(E.target.value) }, className: ot("grid gap-2 ", b && N.length <= 0 ? "bg-red-50 focus-visible:ring-red-500 border-red-500 focus-visible:border-transparent" : ""), id: "email", placeholder: "Enter your email address" })] }), T.jsxs("div", { className: "grid gap-2", children: [T.jsx(Dt, { className: ot("text-left ", b && j.length <= 0 ? "text-red-400" : ""), htmlFor: "phone", children: "Phone Number" }), T.jsx(ln, { onChange: E => { I(E.target.value) }, className: ot("grid gap-2 ", b && j.length <= 0 ? "bg-red-50 focus-visible:ring-red-500 border-red-500 focus-visible:border-transparent" : ""), id: "phone", placeholder: "Enter your phone number" })] }), T.jsxs("div", { className: "grid gap-2", children: [T.jsx(Dt, { className: ot("text-left ", b && K.length <= 0 ? "text-red-400" : ""), htmlFor: "address", children: "Address" }), T.jsx(ln, { onChange: E => { H(E.target.value) }, className: ot("grid gap-2 ", b && K.length <= 0 ? "bg-red-50 focus-visible:ring-red-500 border-red-500 focus-visible:border-transparent" : ""), id: "address", placeholder: "Enter your address" })] }), T.jsx("div", { className: "grid gap-4", children: T.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [T.jsxs("div", { className: "grid gap-2", children: [T.jsx(Dt, { className: ot("text-left ", b && W.length <= 0 ? "text-red-400" : ""), htmlFor: "state", children: "State" }), T.jsxs("select", { name: "state", id: "state", onChange: E => X(E.target.value), className: ot("w-full rounded-md border bg-white px-3 pr-8 py-2 appearance-none", b && W.length <= 0 ? "bg-red-50 focus-visible:ring-red-500 border-red-500 focus-visible:border-transparent" : "border-gray-200"), style: { backgroundImage: `url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E")`, backgroundPosition: "right 0.5rem center", backgroundRepeat: "no-repeat", backgroundSize: "1.5em 1.5em" }, children: [T.jsx("option", { value: "", children: "Select State" }), Object.keys(mg).map(E => T.jsx("option", { value: E, children: mg[E] }, E))] })] }), T.jsxs("div", { className: "grid gap-2", children: [T.jsx(Dt, { className: ot("text-left ", b && ie.length <= 0 ? "text-red-400" : ""), htmlFor: "zip", children: "Zip/Postal" }), T.jsx(ln, { id: "zip", onChange: E => { ge(E.target.value) }, className: ot("grid gap-2 ", b && ie.length <= 0 ? "bg-red-50 focus-visible:ring-red-500 border-red-500 focus-visible:border-transparent" : ""), placeholder: "Enter your zip/postal code" })] })] }) }), T.jsx(Th, {}), T.jsxs("div", { className: "grid gap-2", children: [T.jsx(Dt, { className: "text-left", htmlFor: "description", children: "Comments" }), T.jsx(bh, { id: "comments", placeholder: "Provide any additional information or instructions" })] })] }) }), T.jsx(hu, { children: T.jsx(Fo, { className: "relative w-full", onClick: E => { E.preventDefault(), ue() }, children: "Send me a quote" }) })] })] }) }) }); gg.displayName = "StartQuoteFrom"; const EP = () => { const [t, r] = x.useState(!1), [o, s] = x.useState(!0), [l, d] = x.useState({}), [u, f] = x.useState(!1), [h, m] = x.useState({ height: "0px", width: "0px" }), v = async () => { if (!(Object.keys(l).length > 0)) try { const L = await fetch("https://app.quotegen.net/api/v1/flow/get"); if (!L.ok) throw new Error(`Error fetching data: ${L.statusText}`); const j = await L.json(); d(j) } catch (L) { console.error("Failed to fetch quote data:", L) } finally { s(!1) } }; x.useEffect(() => { t && v() }, [t]); const g = () => { r(!0); const L = window.innerWidth; L <= 768 ? m({ height: `${window.innerHeight - 80}px`, width: `${L - 18}px` }) : m({ height: `${window.innerHeight * .8}px`, width: "768px" }) }, [w, C] = x.useState(!1), b = () => { C(!0) }, S = () => { C(!1) }, P = async L => { try { const j = { business_id: l.id, data: L.history, customer: L.customer }; fetch("https://app.quotegen.net/api/v1/flow/set", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(j) }).then(I => I.json()).then(I => { console.log(I), f(!0), setTimeout(() => { r(!1) }, 3e3) }).catch(I => console.error("Error:", I)) } catch (j) { console.error("Failed to submit quote data:", j) } }, R = x.useRef(), N = () => { g() }; return x.useEffect(() => (window.handleExternalQuoteButtonClick = N, () => { delete window.handleExternalQuoteButtonClick }), []), T.jsxs(ir.div, { layout: !0, initial: { borderRadius: "2rem" }, animate: t ? { borderRadius: "0.5rem" } : { borderRadius: "2rem" }, className: ot("widget select-none fixed right-4 bottom-4 bg-white dark:bg-slate-900 z-50 w-fit overflow-hidden border py-2 shadow-sm dark:border-neutral-800 ", t ? "right-2 bottom-2 md:right-4 md:bottom-4" : ""), children: [T.jsx("span", { className: "flex items-center justify-center h-9 px-4 cursor-pointer", onClick: () => { g() }, children: T.jsx("div", { className: ot("text-black font-semibold dark:text-neutral-400", t ? "text-lg" : "text-base"), children: "Get an instant Quote" }) }), w && t && !u && T.jsx("button", { onClick: () => { R.current.callGoBack() }, className: "flex cursor-pointer absolute left-2 top-2.5 rounded-sm hover:bg-gray-50 h-8 min-h-8 w-8 min-w-8 items-center justify-center ", children: T.jsx(y0, { strokeWidth: 2.5, size: 22, className: "text-black dark:text-gray-600" }) }), t && T.jsx("button", { onClick: () => { r(!1) }, className: "flex cursor-pointer absolute right-2 top-2.5 rounded-sm hover:bg-gray-50 h-8 min-h-8 w-8 min-w-8 items-center justify-center ", children: T.jsx(S0, { strokeWidth: 2.5, size: 16, className: "text-black dark:text-gray-600" }) }), T.jsx(ir.div, { "aria-hidden": !t, initial: { height: 0, translateY: 15 }, transition: { ease: "easeInOut", duration: .3 }, className: ot("flex flex-col w-full", t ? "mt-[-10px]" : ""), animate: t ? h : {}, children: T.jsx(WS, { children: o ? T.jsxs("div", { className: "flex flex-col ", children: [T.jsx(jr, { className: "h-2 rounded-none w-full" }), T.jsxs("div", { className: " pt-12 px-4 flex flex-col  items-center", children: [T.jsx(jr, { className: "h-52 w-full rounded-xl" }), T.jsxs("div", { className: "flex flex-col gap-8 w-full pt-8 items-center", children: [T.jsx(jr, { className: "h-10 w-4/5" }), T.jsx(jr, { className: "h-10 w-4/5" }), T.jsx(jr, { className: "h-10 w-4/5" }), T.jsx(jr, { className: "h-10 w-4/5" })] })] })] }) : T.jsx(T.Fragment, { children: u && t ? T.jsxs(ir.div, { variants: TP, initial: "hidden", animate: "show", className: "flex h-full w-full flex-col items-center justify-center gap-2 text-sm font-normal", children: [T.jsx(ir.div, { variants: mu, className: "flex h-8 min-h-8 w-8 min-w-8 items-center justify-center rounded-full bg-blue-500 dark:bg-sky-500", children: T.jsx(yd, { strokeWidth: 2.5, size: 16, className: "stroke-white" }) }), T.jsx(ir.div, { variants: mu, children: "You will receive a quote to your email shortly." }), T.jsx(ir.div, { variants: mu, children: "Thank you for choosing us." })] }) : T.jsx(T.Fragment, { children: Object.keys(l).length > 0 && T.jsx(T.Fragment, { children: t && T.jsx("div", { className: "h-full flex flex-col pb-3", children: T.jsx(gg, { ref: R, onCallSubmit: P, flowData: l, onShowGoBackButton: b, onHideGoBackButton: S }) }) }) }) }) }) })] }) }, TP = { hidden: { opacity: 0, y: 20 }, show: { opacity: 1, y: 0, transition: { duration: .2, staggerChildren: .04 } } }, mu = { hidden: { y: 10 }, show: { y: 0 } }, RP = `*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}.widget{--background: 0 0% 100%;--foreground: 222.2 84% 4.9%;--card: 0 0% 100%;--card-foreground: 222.2 84% 4.9%;--popover: 0 0% 100%;--popover-foreground: 222.2 84% 4.9%;--primary: 222.2 47.4% 11.2%;--primary-foreground: 210 40% 98%;--secondary: 210 40% 96.1%;--secondary-foreground: 222.2 47.4% 11.2%;--muted: 210 40% 96.1%;--muted-foreground: 215.4 16.3% 46.9%;--accent: 210 40% 96.1%;--accent-foreground: 222.2 47.4% 11.2%;--destructive: 0 84.2% 60.2%;--destructive-foreground: 210 40% 98%;--border: 214.3 31.8% 91.4%;--input: 214.3 31.8% 91.4%;--ring: 222.2 84% 4.9%;--radius: .5rem}.dark .widget{--background: 222.2 84% 4.9%;--foreground: 210 40% 98%;--card: 222.2 84% 4.9%;--card-foreground: 210 40% 98%;--popover: 222.2 84% 4.9%;--popover-foreground: 210 40% 98%;--primary: 210 40% 98%;--primary-foreground: 222.2 47.4% 11.2%;--secondary: 217.2 32.6% 17.5%;--secondary-foreground: 210 40% 98%;--muted: 217.2 32.6% 17.5%;--muted-foreground: 215 20.2% 65.1%;--accent: 217.2 32.6% 17.5%;--accent-foreground: 210 40% 98%;--destructive: 0 62.8% 30.6%;--destructive-foreground: 210 40% 98%;--border: 217.2 32.6% 17.5%;--input: 217.2 32.6% 17.5%;--ring: 212.7 26.8% 83.9%}*{border-color:hsl(var(--border))}body{background-color:hsl(var(--background));color:hsl(var(--foreground))}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }.container{width:100%;margin-right:auto;margin-left:auto;padding-right:2rem;padding-left:2rem}@media (min-width: 1400px){.container{max-width:1400px}}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.bottom-2{bottom:.5rem}.bottom-4{bottom:1rem}.left-2{left:.5rem}.right-2{right:.5rem}.right-4{right:1rem}.top-0{top:0}.top-2{top:.5rem}.top-2\\.5{top:.625rem}.z-50{z-index:50}.-mx-1{margin-left:-.25rem;margin-right:-.25rem}.mx-auto{margin-left:auto;margin-right:auto}.my-1{margin-top:.25rem;margin-bottom:.25rem}.my-2{margin-top:.5rem;margin-bottom:.5rem}.my-8{margin-top:2rem;margin-bottom:2rem}.mb-1{margin-bottom:.25rem}.mb-2{margin-bottom:.5rem}.mb-4{margin-bottom:1rem}.mb-6{margin-bottom:1.5rem}.mr-2{margin-right:.5rem}.mt-2{margin-top:.5rem}.mt-3{margin-top:.75rem}.mt-4{margin-top:1rem}.mt-8{margin-top:2rem}.mt-\\[-10px\\]{margin-top:-10px}.inline{display:inline}.flex{display:flex}.inline-flex{display:inline-flex}.grid{display:grid}.hidden{display:none}.aspect-square{aspect-ratio:1 / 1}.h-10{height:2.5rem}.h-11{height:2.75rem}.h-16{height:4rem}.h-2{height:.5rem}.h-24{height:6rem}.h-3{height:.75rem}.h-3\\.5{height:.875rem}.h-4{height:1rem}.h-5{height:1.25rem}.h-52{height:13rem}.h-6{height:1.5rem}.h-8{height:2rem}.h-9{height:2.25rem}.h-\\[1px\\]{height:1px}.h-\\[var\\(--radix-select-trigger-height\\)\\]{height:var(--radix-select-trigger-height)}.h-fit{height:-moz-fit-content;height:fit-content}.h-full{height:100%}.h-px{height:1px}.max-h-96{max-height:24rem}.min-h-44{min-height:11rem}.min-h-8{min-height:2rem}.min-h-\\[80px\\]{min-height:80px}.w-10{width:2.5rem}.w-3{width:.75rem}.w-3\\.5{width:.875rem}.w-4{width:1rem}.w-4\\/5{width:80%}.w-5{width:1.25rem}.w-6{width:1.5rem}.w-72{width:18rem}.w-8{width:2rem}.w-\\[1px\\]{width:1px}.w-fit{width:-moz-fit-content;width:fit-content}.w-full{width:100%}.min-w-72{min-width:18rem}.min-w-8{min-width:2rem}.min-w-\\[8rem\\]{min-width:8rem}.min-w-\\[var\\(--radix-select-trigger-width\\)\\]{min-width:var(--radix-select-trigger-width)}.max-w-md{max-width:28rem}.flex-1{flex:1 1 0%}.shrink-0{flex-shrink:0}@keyframes pulse{50%{opacity:.5}}.animate-pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}@keyframes spin{to{transform:rotate(360deg)}}.animate-spin{animation:spin 1s linear infinite}.cursor-default{cursor:default}.cursor-pointer{cursor:pointer}.select-none{-webkit-user-select:none;-moz-user-select:none;user-select:none}.appearance-none{-webkit-appearance:none;-moz-appearance:none;appearance:none}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.flex-row{flex-direction:row}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-start{justify-content:flex-start}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-0{gap:0px}.gap-0\\.5{gap:.125rem}.gap-1{gap:.25rem}.gap-1\\.5{gap:.375rem}.gap-2{gap:.5rem}.gap-4{gap:1rem}.gap-8{gap:2rem}.space-y-1>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.25rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.25rem * var(--tw-space-y-reverse))}.space-y-1\\.5>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.375rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.375rem * var(--tw-space-y-reverse))}.space-y-2>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem * var(--tw-space-y-reverse))}.space-y-4>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(1rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1rem * var(--tw-space-y-reverse))}.space-y-6>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1.5rem * var(--tw-space-y-reverse))}.overflow-hidden{overflow:hidden}.overflow-y-scroll{overflow-y:scroll}.truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.whitespace-nowrap{white-space:nowrap}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:var(--radius)}.rounded-md{border-radius:calc(var(--radius) - 2px)}.rounded-none{border-radius:0}.rounded-sm{border-radius:calc(var(--radius) - 4px)}.rounded-xl{border-radius:.75rem}.border{border-width:1px}.border-2{border-width:2px}.border-b{border-bottom-width:1px}.border-solid{border-style:solid}.border-dashed{border-style:dashed}.border-none{border-style:none}.border-destructive\\/50{border-color:hsl(var(--destructive) / .5)}.border-gray-100{--tw-border-opacity: 1;border-color:rgb(243 244 246 / var(--tw-border-opacity))}.border-gray-200{--tw-border-opacity: 1;border-color:rgb(229 231 235 / var(--tw-border-opacity))}.border-input{border-color:hsl(var(--input))}.border-primary{border-color:hsl(var(--primary))}.border-red-500{--tw-border-opacity: 1;border-color:rgb(239 68 68 / var(--tw-border-opacity))}.bg-background{background-color:hsl(var(--background))}.bg-black{--tw-bg-opacity: 1;background-color:rgb(0 0 0 / var(--tw-bg-opacity))}.bg-blue-500{--tw-bg-opacity: 1;background-color:rgb(59 130 246 / var(--tw-bg-opacity))}.bg-border{background-color:hsl(var(--border))}.bg-card{background-color:hsl(var(--card))}.bg-destructive{background-color:hsl(var(--destructive))}.bg-gray-100{--tw-bg-opacity: 1;background-color:rgb(243 244 246 / var(--tw-bg-opacity))}.bg-gray-50{--tw-bg-opacity: 1;background-color:rgb(249 250 251 / var(--tw-bg-opacity))}.bg-muted{background-color:hsl(var(--muted))}.bg-popover{background-color:hsl(var(--popover))}.bg-primary{background-color:hsl(var(--primary))}.bg-red-50{--tw-bg-opacity: 1;background-color:rgb(254 242 242 / var(--tw-bg-opacity))}.bg-secondary{background-color:hsl(var(--secondary))}.bg-slate-100{--tw-bg-opacity: 1;background-color:rgb(241 245 249 / var(--tw-bg-opacity))}.bg-white{--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.stroke-white{stroke:#fff}.object-cover{-o-object-fit:cover;object-fit:cover}.p-1{padding:.25rem}.p-1\\.5{padding:.375rem}.p-2{padding:.5rem}.p-3{padding:.75rem}.p-4{padding:1rem}.p-6{padding:1.5rem}.px-2{padding-left:.5rem;padding-right:.5rem}.px-3{padding-left:.75rem;padding-right:.75rem}.px-4{padding-left:1rem;padding-right:1rem}.px-8{padding-left:2rem;padding-right:2rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-1\\.5{padding-top:.375rem;padding-bottom:.375rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.py-3{padding-top:.75rem;padding-bottom:.75rem}.py-8{padding-top:2rem;padding-bottom:2rem}.pb-3{padding-bottom:.75rem}.pl-8{padding-left:2rem}.pr-2{padding-right:.5rem}.pr-8{padding-right:2rem}.pt-0{padding-top:0}.pt-12{padding-top:3rem}.pt-8{padding-top:2rem}.text-left{text-align:left}.text-center{text-align:center}.text-2xl{font-size:1.5rem;line-height:2rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.text-\\[0\\.7rem\\]{font-size:.7rem}.text-\\[0\\.85rem\\]{font-size:.85rem}.text-base{font-size:1rem;line-height:1.5rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-xs{font-size:.75rem;line-height:1rem}.font-bold{font-weight:700}.font-medium{font-weight:500}.font-normal{font-weight:400}.font-semibold{font-weight:600}.leading-none{line-height:1}.leading-snug{line-height:1.375}.leading-tight{line-height:1.25}.tracking-tight{letter-spacing:-.025em}.text-black{--tw-text-opacity: 1;color:rgb(0 0 0 / var(--tw-text-opacity))}.text-card-foreground{color:hsl(var(--card-foreground))}.text-current{color:currentColor}.text-destructive{color:hsl(var(--destructive))}.text-destructive-foreground{color:hsl(var(--destructive-foreground))}.text-foreground{color:hsl(var(--foreground))}.text-gray-400{--tw-text-opacity: 1;color:rgb(156 163 175 / var(--tw-text-opacity))}.text-gray-500{--tw-text-opacity: 1;color:rgb(107 114 128 / var(--tw-text-opacity))}.text-muted-foreground{color:hsl(var(--muted-foreground))}.text-popover-foreground{color:hsl(var(--popover-foreground))}.text-primary{color:hsl(var(--primary))}.text-primary-foreground{color:hsl(var(--primary-foreground))}.text-red-400{--tw-text-opacity: 1;color:rgb(248 113 113 / var(--tw-text-opacity))}.text-red-600{--tw-text-opacity: 1;color:rgb(220 38 38 / var(--tw-text-opacity))}.text-secondary-foreground{color:hsl(var(--secondary-foreground))}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.underline-offset-4{text-underline-offset:4px}.opacity-50{opacity:.5}.opacity-65{opacity:.65}.shadow-md{--tw-shadow: 0 4px 6px -1px rgb(0 0 0 / .1), 0 2px 4px -2px rgb(0 0 0 / .1);--tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-none{--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-sm{--tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);--tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline-none{outline:2px solid transparent;outline-offset:2px}.outline{outline-style:solid}.ring-offset-background{--tw-ring-offset-color: hsl(var(--background))}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}@keyframes enter{0%{opacity:var(--tw-enter-opacity, 1);transform:translate3d(var(--tw-enter-translate-x, 0),var(--tw-enter-translate-y, 0),0) scale3d(var(--tw-enter-scale, 1),var(--tw-enter-scale, 1),var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0))}}@keyframes exit{to{opacity:var(--tw-exit-opacity, 1);transform:translate3d(var(--tw-exit-translate-x, 0),var(--tw-exit-translate-y, 0),0) scale3d(var(--tw-exit-scale, 1),var(--tw-exit-scale, 1),var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0))}}.no-scrollbar::-webkit-scrollbar{display:none}.no-scrollbar{-ms-overflow-style:none;scrollbar-width:none}.file\\:border-0::file-selector-button{border-width:0px}.file\\:bg-transparent::file-selector-button{background-color:transparent}.file\\:text-sm::file-selector-button{font-size:.875rem;line-height:1.25rem}.file\\:font-medium::file-selector-button{font-weight:500}.placeholder\\:text-muted-foreground::-moz-placeholder{color:hsl(var(--muted-foreground))}.placeholder\\:text-muted-foreground::placeholder{color:hsl(var(--muted-foreground))}.hover\\:bg-accent:hover{background-color:hsl(var(--accent))}.hover\\:bg-destructive\\/90:hover{background-color:hsl(var(--destructive) / .9)}.hover\\:bg-gray-50:hover{--tw-bg-opacity: 1;background-color:rgb(249 250 251 / var(--tw-bg-opacity))}.hover\\:bg-primary\\/90:hover{background-color:hsl(var(--primary) / .9)}.hover\\:bg-secondary\\/80:hover{background-color:hsl(var(--secondary) / .8)}.hover\\:text-accent-foreground:hover{color:hsl(var(--accent-foreground))}.hover\\:underline:hover{text-decoration-line:underline}.hover\\:shadow-md:hover{--tw-shadow: 0 4px 6px -1px rgb(0 0 0 / .1), 0 2px 4px -2px rgb(0 0 0 / .1);--tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.focus\\:bg-accent:focus{background-color:hsl(var(--accent))}.focus\\:text-accent-foreground:focus{color:hsl(var(--accent-foreground))}.focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\\:ring-2:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\\:ring-ring:focus{--tw-ring-color: hsl(var(--ring))}.focus\\:ring-offset-2:focus{--tw-ring-offset-width: 2px}.focus-visible\\:border-transparent:focus-visible{border-color:transparent}.focus-visible\\:outline-none:focus-visible{outline:2px solid transparent;outline-offset:2px}.focus-visible\\:ring-2:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus-visible\\:ring-red-500:focus-visible{--tw-ring-opacity: 1;--tw-ring-color: rgb(239 68 68 / var(--tw-ring-opacity))}.focus-visible\\:ring-ring:focus-visible{--tw-ring-color: hsl(var(--ring))}.focus-visible\\:ring-offset-2:focus-visible{--tw-ring-offset-width: 2px}.disabled\\:pointer-events-none:disabled{pointer-events:none}.disabled\\:cursor-not-allowed:disabled{cursor:not-allowed}.disabled\\:opacity-50:disabled{opacity:.5}.peer:disabled~.peer-disabled\\:cursor-not-allowed{cursor:not-allowed}.peer:disabled~.peer-disabled\\:opacity-70{opacity:.7}.data-\\[side\\=bottom\\]\\:translate-y-1[data-side=bottom]{--tw-translate-y: .25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[side\\=left\\]\\:-translate-x-1[data-side=left]{--tw-translate-x: -.25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[side\\=right\\]\\:translate-x-1[data-side=right]{--tw-translate-x: .25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[side\\=top\\]\\:-translate-y-1[data-side=top]{--tw-translate-y: -.25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[state\\=checked\\]\\:bg-primary[data-state=checked]{background-color:hsl(var(--primary))}.data-\\[state\\=checked\\]\\:text-primary-foreground[data-state=checked]{color:hsl(var(--primary-foreground))}.data-\\[state\\=open\\]\\:animate-in[data-state=open]{animation-name:enter;animation-duration:.15s;--tw-enter-opacity: initial;--tw-enter-scale: initial;--tw-enter-rotate: initial;--tw-enter-translate-x: initial;--tw-enter-translate-y: initial}.data-\\[state\\=closed\\]\\:animate-out[data-state=closed]{animation-name:exit;animation-duration:.15s;--tw-exit-opacity: initial;--tw-exit-scale: initial;--tw-exit-rotate: initial;--tw-exit-translate-x: initial;--tw-exit-translate-y: initial}.data-\\[state\\=closed\\]\\:fade-out-0[data-state=closed]{--tw-exit-opacity: 0}.data-\\[state\\=open\\]\\:fade-in-0[data-state=open]{--tw-enter-opacity: 0}.data-\\[state\\=closed\\]\\:zoom-out-95[data-state=closed]{--tw-exit-scale: .95}.data-\\[state\\=open\\]\\:zoom-in-95[data-state=open]{--tw-enter-scale: .95}.data-\\[side\\=bottom\\]\\:slide-in-from-top-2[data-side=bottom]{--tw-enter-translate-y: -.5rem}.data-\\[side\\=left\\]\\:slide-in-from-right-2[data-side=left]{--tw-enter-translate-x: .5rem}.data-\\[side\\=right\\]\\:slide-in-from-left-2[data-side=right]{--tw-enter-translate-x: -.5rem}.data-\\[side\\=top\\]\\:slide-in-from-bottom-2[data-side=top]{--tw-enter-translate-y: .5rem}.dark\\:border-destructive:is(.dark *){border-color:hsl(var(--destructive))}.dark\\:border-neutral-800:is(.dark *){--tw-border-opacity: 1;border-color:rgb(38 38 38 / var(--tw-border-opacity))}.dark\\:bg-sky-500:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(14 165 233 / var(--tw-bg-opacity))}.dark\\:bg-slate-900:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(15 23 42 / var(--tw-bg-opacity))}.dark\\:text-gray-600:is(.dark *){--tw-text-opacity: 1;color:rgb(75 85 99 / var(--tw-text-opacity))}.dark\\:text-neutral-400:is(.dark *){--tw-text-opacity: 1;color:rgb(163 163 163 / var(--tw-text-opacity))}@media (min-width: 640px){.sm\\:p-8{padding:2rem}.sm\\:text-3xl{font-size:1.875rem;line-height:2.25rem}}@media (min-width: 768px){.md\\:bottom-4{bottom:1rem}.md\\:right-4{right:1rem}.md\\:grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}}.\\[\\&\\>span\\]\\:line-clamp-1>span{overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}.\\[\\&\\>svg\\+div\\]\\:translate-y-\\[-3px\\]>svg+div{--tw-translate-y: -3px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.\\[\\&\\>svg\\]\\:absolute>svg{position:absolute}.\\[\\&\\>svg\\]\\:left-4>svg{left:1rem}.\\[\\&\\>svg\\]\\:top-4>svg{top:1rem}.\\[\\&\\>svg\\]\\:text-destructive>svg{color:hsl(var(--destructive))}.\\[\\&\\>svg\\]\\:text-foreground>svg{color:hsl(var(--foreground))}.\\[\\&\\>svg\\~\\*\\]\\:pl-7>svg~*{padding-left:1.75rem}.\\[\\&_p\\]\\:leading-relaxed p{line-height:1.625}
`, AP = ({ projectId: t }) => T.jsxs(T.Fragment, { children: [T.jsx("style", { children: RP }), T.jsx(EP, {})] }), NP = t => t.replace(/-([a-z])/g, (r, o) => o.toUpperCase()); class MP extends HTMLElement { constructor() { super(), this.attachShadow({ mode: "open" }) } connectedCallback() { const r = this.getPropsFromAttributes(); Ra.createRoot(this.shadowRoot).render(T.jsx(AP, { ...r })) } getPropsFromAttributes() { const r = {}; for (const { name: o, value: s } of this.attributes) r[NP(o)] = s; return r } } document.body.appendChild(document.createElement("my-widget")), document.querySelectorAll('button[data="start-quote-button"]').forEach(t => { t.addEventListener("click", () => { window.handleExternalQuoteButtonClick() }) }), customElements.define("my-widget", MP)
});
