(function (Ni) { typeof define == "function" && define.amd ? define(Ni) : Ni() })(function () {
  "use strict"; function Ni(t, r) { for (var o = 0; o < r.length; o++) { const s = r[o]; if (typeof s != "string" && !Array.isArray(s)) { for (const l in s) if (l !== "default" && !(l in t)) { const d = Object.getOwnPropertyDescriptor(s, l); d && Object.defineProperty(t, l, d.get ? d : { enumerable: !0, get: () => s[l] }) } } } return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" })) } function g0(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var ud = { exports: {} }, wo = {}, Ra = { exports: {} }, Ce = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var cd; function v0() { if (cd) return Ce; cd = 1; var t = Symbol.for("react.element"), r = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), l = Symbol.for("react.profiler"), d = Symbol.for("react.provider"), u = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), m = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), g = Symbol.iterator; function x(E) { return E === null || typeof E != "object" ? null : (E = g && E[g] || E["@@iterator"], typeof E == "function" ? E : null) } var C = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, b = Object.assign, S = {}; function P(E, V, ce) { this.props = E, this.context = V, this.refs = S, this.updater = ce || C } P.prototype.isReactComponent = {}, P.prototype.setState = function (E, V) { if (typeof E != "object" && typeof E != "function" && E != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, E, V, "setState") }, P.prototype.forceUpdate = function (E) { this.updater.enqueueForceUpdate(this, E, "forceUpdate") }; function R() { } R.prototype = P.prototype; function N(E, V, ce) { this.props = E, this.context = V, this.refs = S, this.updater = ce || C } var M = N.prototype = new R; M.constructor = N, b(M, P.prototype), M.isPureReactComponent = !0; var j = Array.isArray, I = Object.prototype.hasOwnProperty, H = { current: null }, $ = { key: !0, ref: !0, __self: !0, __source: !0 }; function W(E, V, ce) { var ae, Se = {}, ve = null, Q = null; if (V != null) for (ae in V.ref !== void 0 && (Q = V.ref), V.key !== void 0 && (ve = "" + V.key), V) I.call(V, ae) && !$.hasOwnProperty(ae) && (Se[ae] = V[ae]); var ue = arguments.length - 2; if (ue === 1) Se.children = ce; else if (1 < ue) { for (var ye = Array(ue), we = 0; we < ue; we++)ye[we] = arguments[we + 2]; Se.children = ye } if (E && E.defaultProps) for (ae in ue = E.defaultProps, ue) Se[ae] === void 0 && (Se[ae] = ue[ae]); return { $$typeof: t, type: E, key: ve, ref: Q, props: Se, _owner: H.current } } function le(E, V) { return { $$typeof: t, type: E.type, key: V, ref: E.ref, props: E.props, _owner: E._owner } } function oe(E) { return typeof E == "object" && E !== null && E.$$typeof === t } function me(E) { var V = { "=": "=0", ":": "=2" }; return "$" + E.replace(/[=:]/g, function (ce) { return V[ce] }) } var Z = /\/+/g; function ge(E, V) { return typeof E == "object" && E !== null && E.key != null ? me("" + E.key) : V.toString(36) } function ne(E, V, ce, ae, Se) { var ve = typeof E; (ve === "undefined" || ve === "boolean") && (E = null); var Q = !1; if (E === null) Q = !0; else switch (ve) { case "string": case "number": Q = !0; break; case "object": switch (E.$$typeof) { case t: case r: Q = !0 } }if (Q) return Q = E, Se = Se(Q), E = ae === "" ? "." + ge(Q, 0) : ae, j(Se) ? (ce = "", E != null && (ce = E.replace(Z, "$&/") + "/"), ne(Se, V, ce, "", function (we) { return we })) : Se != null && (oe(Se) && (Se = le(Se, ce + (!Se.key || Q && Q.key === Se.key ? "" : ("" + Se.key).replace(Z, "$&/") + "/") + E)), V.push(Se)), 1; if (Q = 0, ae = ae === "" ? "." : ae + ":", j(E)) for (var ue = 0; ue < E.length; ue++) { ve = E[ue]; var ye = ae + ge(ve, ue); Q += ne(ve, V, ce, ye, Se) } else if (ye = x(E), typeof ye == "function") for (E = ye.call(E), ue = 0; !(ve = E.next()).done;)ve = ve.value, ye = ae + ge(ve, ue++), Q += ne(ve, V, ce, ye, Se); else if (ve === "object") throw V = String(E), Error("Objects are not valid as a React child (found: " + (V === "[object Object]" ? "object with keys {" + Object.keys(E).join(", ") + "}" : V) + "). If you meant to render a collection of children, use an array instead."); return Q } function J(E, V, ce) { if (E == null) return E; var ae = [], Se = 0; return ne(E, ae, "", "", function (ve) { return V.call(ce, ve, Se++) }), ae } function se(E) { if (E._status === -1) { var V = E._result; V = V(), V.then(function (ce) { (E._status === 0 || E._status === -1) && (E._status = 1, E._result = ce) }, function (ce) { (E._status === 0 || E._status === -1) && (E._status = 2, E._result = ce) }), E._status === -1 && (E._status = 0, E._result = V) } if (E._status === 1) return E._result.default; throw E._result } var G = { current: null }, F = { transition: null }, Y = { ReactCurrentDispatcher: G, ReactCurrentBatchConfig: F, ReactCurrentOwner: H }; function X() { throw Error("act(...) is not supported in production builds of React.") } return Ce.Children = { map: J, forEach: function (E, V, ce) { J(E, function () { V.apply(this, arguments) }, ce) }, count: function (E) { var V = 0; return J(E, function () { V++ }), V }, toArray: function (E) { return J(E, function (V) { return V }) || [] }, only: function (E) { if (!oe(E)) throw Error("React.Children.only expected to receive a single React element child."); return E } }, Ce.Component = P, Ce.Fragment = o, Ce.Profiler = l, Ce.PureComponent = N, Ce.StrictMode = s, Ce.Suspense = h, Ce.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Y, Ce.act = X, Ce.cloneElement = function (E, V, ce) { if (E == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + E + "."); var ae = b({}, E.props), Se = E.key, ve = E.ref, Q = E._owner; if (V != null) { if (V.ref !== void 0 && (ve = V.ref, Q = H.current), V.key !== void 0 && (Se = "" + V.key), E.type && E.type.defaultProps) var ue = E.type.defaultProps; for (ye in V) I.call(V, ye) && !$.hasOwnProperty(ye) && (ae[ye] = V[ye] === void 0 && ue !== void 0 ? ue[ye] : V[ye]) } var ye = arguments.length - 2; if (ye === 1) ae.children = ce; else if (1 < ye) { ue = Array(ye); for (var we = 0; we < ye; we++)ue[we] = arguments[we + 2]; ae.children = ue } return { $$typeof: t, type: E.type, key: Se, ref: ve, props: ae, _owner: Q } }, Ce.createContext = function (E) { return E = { $$typeof: u, _currentValue: E, _currentValue2: E, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, E.Provider = { $$typeof: d, _context: E }, E.Consumer = E }, Ce.createElement = W, Ce.createFactory = function (E) { var V = W.bind(null, E); return V.type = E, V }, Ce.createRef = function () { return { current: null } }, Ce.forwardRef = function (E) { return { $$typeof: f, render: E } }, Ce.isValidElement = oe, Ce.lazy = function (E) { return { $$typeof: v, _payload: { _status: -1, _result: E }, _init: se } }, Ce.memo = function (E, V) { return { $$typeof: m, type: E, compare: V === void 0 ? null : V } }, Ce.startTransition = function (E) { var V = F.transition; F.transition = {}; try { E() } finally { F.transition = V } }, Ce.unstable_act = X, Ce.useCallback = function (E, V) { return G.current.useCallback(E, V) }, Ce.useContext = function (E) { return G.current.useContext(E) }, Ce.useDebugValue = function () { }, Ce.useDeferredValue = function (E) { return G.current.useDeferredValue(E) }, Ce.useEffect = function (E, V) { return G.current.useEffect(E, V) }, Ce.useId = function () { return G.current.useId() }, Ce.useImperativeHandle = function (E, V, ce) { return G.current.useImperativeHandle(E, V, ce) }, Ce.useInsertionEffect = function (E, V) { return G.current.useInsertionEffect(E, V) }, Ce.useLayoutEffect = function (E, V) { return G.current.useLayoutEffect(E, V) }, Ce.useMemo = function (E, V) { return G.current.useMemo(E, V) }, Ce.useReducer = function (E, V, ce) { return G.current.useReducer(E, V, ce) }, Ce.useRef = function (E) { return G.current.useRef(E) }, Ce.useState = function (E) { return G.current.useState(E) }, Ce.useSyncExternalStore = function (E, V, ce) { return G.current.useSyncExternalStore(E, V, ce) }, Ce.useTransition = function () { return G.current.useTransition() }, Ce.version = "18.3.1", Ce } var dd; function Aa() { return dd || (dd = 1, Ra.exports = v0()), Ra.exports }/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var fd; function y0() { if (fd) return wo; fd = 1; var t = Aa(), r = Symbol.for("react.element"), o = Symbol.for("react.fragment"), s = Object.prototype.hasOwnProperty, l = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, d = { key: !0, ref: !0, __self: !0, __source: !0 }; function u(f, h, m) { var v, g = {}, x = null, C = null; m !== void 0 && (x = "" + m), h.key !== void 0 && (x = "" + h.key), h.ref !== void 0 && (C = h.ref); for (v in h) s.call(h, v) && !d.hasOwnProperty(v) && (g[v] = h[v]); if (f && f.defaultProps) for (v in h = f.defaultProps, h) g[v] === void 0 && (g[v] = h[v]); return { $$typeof: r, type: f, key: x, ref: C, props: g, _owner: l.current } } return wo.Fragment = o, wo.jsx = u, wo.jsxs = u, wo } ud.exports = y0(); var T = ud.exports, Na = {}, pd = { exports: {} }, dt = {}, Ma = { exports: {} }, La = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hd; function w0() { return hd || (hd = 1, function (t) { function r(F, Y) { var X = F.length; F.push(Y); e: for (; 0 < X;) { var E = X - 1 >>> 1, V = F[E]; if (0 < l(V, Y)) F[E] = Y, F[X] = V, X = E; else break e } } function o(F) { return F.length === 0 ? null : F[0] } function s(F) { if (F.length === 0) return null; var Y = F[0], X = F.pop(); if (X !== Y) { F[0] = X; e: for (var E = 0, V = F.length, ce = V >>> 1; E < ce;) { var ae = 2 * (E + 1) - 1, Se = F[ae], ve = ae + 1, Q = F[ve]; if (0 > l(Se, X)) ve < V && 0 > l(Q, Se) ? (F[E] = Q, F[ve] = X, E = ve) : (F[E] = Se, F[ae] = X, E = ae); else if (ve < V && 0 > l(Q, X)) F[E] = Q, F[ve] = X, E = ve; else break e } } return Y } function l(F, Y) { var X = F.sortIndex - Y.sortIndex; return X !== 0 ? X : F.id - Y.id } if (typeof performance == "object" && typeof performance.now == "function") { var d = performance; t.unstable_now = function () { return d.now() } } else { var u = Date, f = u.now(); t.unstable_now = function () { return u.now() - f } } var h = [], m = [], v = 1, g = null, x = 3, C = !1, b = !1, S = !1, P = typeof setTimeout == "function" ? setTimeout : null, R = typeof clearTimeout == "function" ? clearTimeout : null, N = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function M(F) { for (var Y = o(m); Y !== null;) { if (Y.callback === null) s(m); else if (Y.startTime <= F) s(m), Y.sortIndex = Y.expirationTime, r(h, Y); else break; Y = o(m) } } function j(F) { if (S = !1, M(F), !b) if (o(h) !== null) b = !0, se(I); else { var Y = o(m); Y !== null && G(j, Y.startTime - F) } } function I(F, Y) { b = !1, S && (S = !1, R(W), W = -1), C = !0; var X = x; try { for (M(Y), g = o(h); g !== null && (!(g.expirationTime > Y) || F && !me());) { var E = g.callback; if (typeof E == "function") { g.callback = null, x = g.priorityLevel; var V = E(g.expirationTime <= Y); Y = t.unstable_now(), typeof V == "function" ? g.callback = V : g === o(h) && s(h), M(Y) } else s(h); g = o(h) } if (g !== null) var ce = !0; else { var ae = o(m); ae !== null && G(j, ae.startTime - Y), ce = !1 } return ce } finally { g = null, x = X, C = !1 } } var H = !1, $ = null, W = -1, le = 5, oe = -1; function me() { return !(t.unstable_now() - oe < le) } function Z() { if ($ !== null) { var F = t.unstable_now(); oe = F; var Y = !0; try { Y = $(!0, F) } finally { Y ? ge() : (H = !1, $ = null) } } else H = !1 } var ge; if (typeof N == "function") ge = function () { N(Z) }; else if (typeof MessageChannel < "u") { var ne = new MessageChannel, J = ne.port2; ne.port1.onmessage = Z, ge = function () { J.postMessage(null) } } else ge = function () { P(Z, 0) }; function se(F) { $ = F, H || (H = !0, ge()) } function G(F, Y) { W = P(function () { F(t.unstable_now()) }, Y) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (F) { F.callback = null }, t.unstable_continueExecution = function () { b || C || (b = !0, se(I)) }, t.unstable_forceFrameRate = function (F) { 0 > F || 125 < F ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : le = 0 < F ? Math.floor(1e3 / F) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return x }, t.unstable_getFirstCallbackNode = function () { return o(h) }, t.unstable_next = function (F) { switch (x) { case 1: case 2: case 3: var Y = 3; break; default: Y = x }var X = x; x = Y; try { return F() } finally { x = X } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (F, Y) { switch (F) { case 1: case 2: case 3: case 4: case 5: break; default: F = 3 }var X = x; x = F; try { return Y() } finally { x = X } }, t.unstable_scheduleCallback = function (F, Y, X) { var E = t.unstable_now(); switch (typeof X == "object" && X !== null ? (X = X.delay, X = typeof X == "number" && 0 < X ? E + X : E) : X = E, F) { case 1: var V = -1; break; case 2: V = 250; break; case 5: V = 1073741823; break; case 4: V = 1e4; break; default: V = 5e3 }return V = X + V, F = { id: v++, callback: Y, priorityLevel: F, startTime: X, expirationTime: V, sortIndex: -1 }, X > E ? (F.sortIndex = X, r(m, F), o(h) === null && F === o(m) && (S ? (R(W), W = -1) : S = !0, G(j, X - E))) : (F.sortIndex = V, r(h, F), b || C || (b = !0, se(I))), F }, t.unstable_shouldYield = me, t.unstable_wrapCallback = function (F) { var Y = x; return function () { var X = x; x = Y; try { return F.apply(this, arguments) } finally { x = X } } } }(La)), La } var md; function x0() { return md || (md = 1, Ma.exports = w0()), Ma.exports }/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var gd; function S0() {
    if (gd) return dt; gd = 1; var t = Aa(), r = x0(); function o(e) { for (var n = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, i = 1; i < arguments.length; i++)n += "&args[]=" + encodeURIComponent(arguments[i]); return "Minified React error #" + e + "; visit " + n + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var s = new Set, l = {}; function d(e, n) { u(e, n), u(e + "Capture", n) } function u(e, n) { for (l[e] = n, e = 0; e < n.length; e++)s.add(n[e]) } var f = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), h = Object.prototype.hasOwnProperty, m = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, v = {}, g = {}; function x(e) { return h.call(g, e) ? !0 : h.call(v, e) ? !1 : m.test(e) ? g[e] = !0 : (v[e] = !0, !1) } function C(e, n, i, a) { if (i !== null && i.type === 0) return !1; switch (typeof n) { case "function": case "symbol": return !0; case "boolean": return a ? !1 : i !== null ? !i.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function b(e, n, i, a) { if (n === null || typeof n > "u" || C(e, n, i, a)) return !0; if (a) return !1; if (i !== null) switch (i.type) { case 3: return !n; case 4: return n === !1; case 5: return isNaN(n); case 6: return isNaN(n) || 1 > n }return !1 } function S(e, n, i, a, c, p, y) { this.acceptsBooleans = n === 2 || n === 3 || n === 4, this.attributeName = a, this.attributeNamespace = c, this.mustUseProperty = i, this.propertyName = e, this.type = n, this.sanitizeURL = p, this.removeEmptyString = y } var P = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { P[e] = new S(e, 0, !1, e, null, !1, !1) }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var n = e[0]; P[n] = new S(n, 1, !1, e[1], null, !1, !1) }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { P[e] = new S(e, 2, !1, e.toLowerCase(), null, !1, !1) }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { P[e] = new S(e, 2, !1, e, null, !1, !1) }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { P[e] = new S(e, 3, !1, e.toLowerCase(), null, !1, !1) }), ["checked", "multiple", "muted", "selected"].forEach(function (e) { P[e] = new S(e, 3, !0, e, null, !1, !1) }), ["capture", "download"].forEach(function (e) { P[e] = new S(e, 4, !1, e, null, !1, !1) }), ["cols", "rows", "size", "span"].forEach(function (e) { P[e] = new S(e, 6, !1, e, null, !1, !1) }), ["rowSpan", "start"].forEach(function (e) { P[e] = new S(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var R = /[\-:]([a-z])/g; function N(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var n = e.replace(R, N); P[n] = new S(n, 1, !1, e, null, !1, !1) }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var n = e.replace(R, N); P[n] = new S(n, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) }), ["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var n = e.replace(R, N); P[n] = new S(n, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) }), ["tabIndex", "crossOrigin"].forEach(function (e) { P[e] = new S(e, 1, !1, e.toLowerCase(), null, !1, !1) }), P.xlinkHref = new S("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (e) { P[e] = new S(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function M(e, n, i, a) { var c = P.hasOwnProperty(n) ? P[n] : null; (c !== null ? c.type !== 0 : a || !(2 < n.length) || n[0] !== "o" && n[0] !== "O" || n[1] !== "n" && n[1] !== "N") && (b(n, i, c, a) && (i = null), a || c === null ? x(n) && (i === null ? e.removeAttribute(n) : e.setAttribute(n, "" + i)) : c.mustUseProperty ? e[c.propertyName] = i === null ? c.type === 3 ? !1 : "" : i : (n = c.attributeName, a = c.attributeNamespace, i === null ? e.removeAttribute(n) : (c = c.type, i = c === 3 || c === 4 && i === !0 ? "" : "" + i, a ? e.setAttributeNS(a, n, i) : e.setAttribute(n, i)))) } var j = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, I = Symbol.for("react.element"), H = Symbol.for("react.portal"), $ = Symbol.for("react.fragment"), W = Symbol.for("react.strict_mode"), le = Symbol.for("react.profiler"), oe = Symbol.for("react.provider"), me = Symbol.for("react.context"), Z = Symbol.for("react.forward_ref"), ge = Symbol.for("react.suspense"), ne = Symbol.for("react.suspense_list"), J = Symbol.for("react.memo"), se = Symbol.for("react.lazy"), G = Symbol.for("react.offscreen"), F = Symbol.iterator; function Y(e) { return e === null || typeof e != "object" ? null : (e = F && e[F] || e["@@iterator"], typeof e == "function" ? e : null) } var X = Object.assign, E; function V(e) {
      if (E === void 0) try { throw Error() } catch (i) { var n = i.stack.trim().match(/\n( *(at )?)/); E = n && n[1] || "" } return `
`+ E + e
    } var ce = !1; function ae(e, n) {
      if (!e || ce) return ""; ce = !0; var i = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (n) if (n = function () { throw Error() }, Object.defineProperty(n.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(n, []) } catch (_) { var a = _ } Reflect.construct(e, [], n) } else { try { n.call() } catch (_) { a = _ } e.call(n.prototype) } else { try { throw Error() } catch (_) { a = _ } e() } } catch (_) {
        if (_ && a && typeof _.stack == "string") {
          for (var c = _.stack.split(`
`), p = a.stack.split(`
`), y = c.length - 1, k = p.length - 1; 1 <= y && 0 <= k && c[y] !== p[k];)k--; for (; 1 <= y && 0 <= k; y--, k--)if (c[y] !== p[k]) {
            if (y !== 1 || k !== 1) do if (y--, k--, 0 > k || c[y] !== p[k]) {
              var A = `
`+ c[y].replace(" at new ", " at "); return e.displayName && A.includes("<anonymous>") && (A = A.replace("<anonymous>", e.displayName)), A
            } while (1 <= y && 0 <= k); break
          }
        }
      } finally { ce = !1, Error.prepareStackTrace = i } return (e = e ? e.displayName || e.name : "") ? V(e) : ""
    } function Se(e) { switch (e.tag) { case 5: return V(e.type); case 16: return V("Lazy"); case 13: return V("Suspense"); case 19: return V("SuspenseList"); case 0: case 2: case 15: return e = ae(e.type, !1), e; case 11: return e = ae(e.type.render, !1), e; case 1: return e = ae(e.type, !0), e; default: return "" } } function ve(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case $: return "Fragment"; case H: return "Portal"; case le: return "Profiler"; case W: return "StrictMode"; case ge: return "Suspense"; case ne: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case me: return (e.displayName || "Context") + ".Consumer"; case oe: return (e._context.displayName || "Context") + ".Provider"; case Z: var n = e.render; return e = e.displayName, e || (e = n.displayName || n.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case J: return n = e.displayName || null, n !== null ? n : ve(e.type) || "Memo"; case se: n = e._payload, e = e._init; try { return ve(e(n)) } catch { } }return null } function Q(e) { var n = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (n.displayName || "Context") + ".Consumer"; case 10: return (n._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = n.render, e = e.displayName || e.name || "", n.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return n; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return ve(n); case 8: return n === W ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof n == "function") return n.displayName || n.name || null; if (typeof n == "string") return n }return null } function ue(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function ye(e) { var n = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (n === "checkbox" || n === "radio") } function we(e) { var n = ye(e) ? "checked" : "value", i = Object.getOwnPropertyDescriptor(e.constructor.prototype, n), a = "" + e[n]; if (!e.hasOwnProperty(n) && typeof i < "u" && typeof i.get == "function" && typeof i.set == "function") { var c = i.get, p = i.set; return Object.defineProperty(e, n, { configurable: !0, get: function () { return c.call(this) }, set: function (y) { a = "" + y, p.call(this, y) } }), Object.defineProperty(e, n, { enumerable: i.enumerable }), { getValue: function () { return a }, setValue: function (y) { a = "" + y }, stopTracking: function () { e._valueTracker = null, delete e[n] } } } } function be(e) { e._valueTracker || (e._valueTracker = we(e)) } function Re(e) { if (!e) return !1; var n = e._valueTracker; if (!n) return !0; var i = n.getValue(), a = ""; return e && (a = ye(e) ? e.checked ? "true" : "false" : e.value), e = a, e !== i ? (n.setValue(e), !0) : !1 } function Be(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function Ot(e, n) { var i = n.checked; return X({}, n, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: i ?? e._wrapperState.initialChecked }) } function Hr(e, n) { var i = n.defaultValue == null ? "" : n.defaultValue, a = n.checked != null ? n.checked : n.defaultChecked; i = ue(n.value != null ? n.value : i), e._wrapperState = { initialChecked: a, initialValue: i, controlled: n.type === "checkbox" || n.type === "radio" ? n.checked != null : n.value != null } } function Kr(e, n) { n = n.checked, n != null && M(e, "checked", n, !1) } function ur(e, n) { Kr(e, n); var i = ue(n.value), a = n.type; if (i != null) a === "number" ? (i === 0 && e.value === "" || e.value != i) && (e.value = "" + i) : e.value !== "" + i && (e.value = "" + i); else if (a === "submit" || a === "reset") { e.removeAttribute("value"); return } n.hasOwnProperty("value") ? yu(e, n.type, i) : n.hasOwnProperty("defaultValue") && yu(e, n.type, ue(n.defaultValue)), n.checked == null && n.defaultChecked != null && (e.defaultChecked = !!n.defaultChecked) } function Pg(e, n, i) { if (n.hasOwnProperty("value") || n.hasOwnProperty("defaultValue")) { var a = n.type; if (!(a !== "submit" && a !== "reset" || n.value !== void 0 && n.value !== null)) return; n = "" + e._wrapperState.initialValue, i || n === e.value || (e.value = n), e.defaultValue = n } i = e.name, i !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, i !== "" && (e.name = i) } function yu(e, n, i) { (n !== "number" || Be(e.ownerDocument) !== e) && (i == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + i && (e.defaultValue = "" + i)) } var Ho = Array.isArray; function Gr(e, n, i, a) { if (e = e.options, n) { n = {}; for (var c = 0; c < i.length; c++)n["$" + i[c]] = !0; for (i = 0; i < e.length; i++)c = n.hasOwnProperty("$" + e[i].value), e[i].selected !== c && (e[i].selected = c), c && a && (e[i].defaultSelected = !0) } else { for (i = "" + ue(i), n = null, c = 0; c < e.length; c++) { if (e[c].value === i) { e[c].selected = !0, a && (e[c].defaultSelected = !0); return } n !== null || e[c].disabled || (n = e[c]) } n !== null && (n.selected = !0) } } function wu(e, n) { if (n.dangerouslySetInnerHTML != null) throw Error(o(91)); return X({}, n, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function Eg(e, n) { var i = n.value; if (i == null) { if (i = n.children, n = n.defaultValue, i != null) { if (n != null) throw Error(o(92)); if (Ho(i)) { if (1 < i.length) throw Error(o(93)); i = i[0] } n = i } n == null && (n = ""), i = n } e._wrapperState = { initialValue: ue(i) } } function Tg(e, n) { var i = ue(n.value), a = ue(n.defaultValue); i != null && (i = "" + i, i !== e.value && (e.value = i), n.defaultValue == null && e.defaultValue !== i && (e.defaultValue = i)), a != null && (e.defaultValue = "" + a) } function Rg(e) { var n = e.textContent; n === e._wrapperState.initialValue && n !== "" && n !== null && (e.value = n) } function Ag(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function xu(e, n) { return e == null || e === "http://www.w3.org/1999/xhtml" ? Ag(n) : e === "http://www.w3.org/2000/svg" && n === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var xs, Ng = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (n, i, a, c) { MSApp.execUnsafeLocalFunction(function () { return e(n, i, a, c) }) } : e }(function (e, n) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = n; else { for (xs = xs || document.createElement("div"), xs.innerHTML = "<svg>" + n.valueOf().toString() + "</svg>", n = xs.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; n.firstChild;)e.appendChild(n.firstChild) } }); function Ko(e, n) { if (n) { var i = e.firstChild; if (i && i === e.lastChild && i.nodeType === 3) { i.nodeValue = n; return } } e.textContent = n } var Go = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, KP = ["Webkit", "ms", "Moz", "O"]; Object.keys(Go).forEach(function (e) { KP.forEach(function (n) { n = n + e.charAt(0).toUpperCase() + e.substring(1), Go[n] = Go[e] }) }); function Mg(e, n, i) { return n == null || typeof n == "boolean" || n === "" ? "" : i || typeof n != "number" || n === 0 || Go.hasOwnProperty(e) && Go[e] ? ("" + n).trim() : n + "px" } function Lg(e, n) { e = e.style; for (var i in n) if (n.hasOwnProperty(i)) { var a = i.indexOf("--") === 0, c = Mg(i, n[i], a); i === "float" && (i = "cssFloat"), a ? e.setProperty(i, c) : e[i] = c } } var GP = X({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Su(e, n) { if (n) { if (GP[e] && (n.children != null || n.dangerouslySetInnerHTML != null)) throw Error(o(137, e)); if (n.dangerouslySetInnerHTML != null) { if (n.children != null) throw Error(o(60)); if (typeof n.dangerouslySetInnerHTML != "object" || !("__html" in n.dangerouslySetInnerHTML)) throw Error(o(61)) } if (n.style != null && typeof n.style != "object") throw Error(o(62)) } } function Cu(e, n) { if (e.indexOf("-") === -1) return typeof n.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var bu = null; function ku(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var Pu = null, Yr = null, Xr = null; function Dg(e) { if (e = mi(e)) { if (typeof Pu != "function") throw Error(o(280)); var n = e.stateNode; n && (n = Ws(n), Pu(e.stateNode, e.type, n)) } } function jg(e) { Yr ? Xr ? Xr.push(e) : Xr = [e] : Yr = e } function Og() { if (Yr) { var e = Yr, n = Xr; if (Xr = Yr = null, Dg(e), n) for (e = 0; e < n.length; e++)Dg(n[e]) } } function _g(e, n) { return e(n) } function Ig() { } var Eu = !1; function Vg(e, n, i) { if (Eu) return e(n, i); Eu = !0; try { return _g(e, n, i) } finally { Eu = !1, (Yr !== null || Xr !== null) && (Ig(), Og()) } } function Yo(e, n) { var i = e.stateNode; if (i === null) return null; var a = Ws(i); if (a === null) return null; i = a[n]; e: switch (n) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (a = !a.disabled) || (e = e.type, a = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !a; break e; default: e = !1 }if (e) return null; if (i && typeof i != "function") throw Error(o(231, n, typeof i)); return i } var Tu = !1; if (f) try { var Xo = {}; Object.defineProperty(Xo, "passive", { get: function () { Tu = !0 } }), window.addEventListener("test", Xo, Xo), window.removeEventListener("test", Xo, Xo) } catch { Tu = !1 } function YP(e, n, i, a, c, p, y, k, A) { var _ = Array.prototype.slice.call(arguments, 3); try { n.apply(i, _) } catch (B) { this.onError(B) } } var Qo = !1, Ss = null, Cs = !1, Ru = null, XP = { onError: function (e) { Qo = !0, Ss = e } }; function QP(e, n, i, a, c, p, y, k, A) { Qo = !1, Ss = null, YP.apply(XP, arguments) } function qP(e, n, i, a, c, p, y, k, A) { if (QP.apply(this, arguments), Qo) { if (Qo) { var _ = Ss; Qo = !1, Ss = null } else throw Error(o(198)); Cs || (Cs = !0, Ru = _) } } function cr(e) { var n = e, i = e; if (e.alternate) for (; n.return;)n = n.return; else { e = n; do n = e, n.flags & 4098 && (i = n.return), e = n.return; while (e) } return n.tag === 3 ? i : null } function Fg(e) { if (e.tag === 13) { var n = e.memoizedState; if (n === null && (e = e.alternate, e !== null && (n = e.memoizedState)), n !== null) return n.dehydrated } return null } function zg(e) { if (cr(e) !== e) throw Error(o(188)) } function ZP(e) { var n = e.alternate; if (!n) { if (n = cr(e), n === null) throw Error(o(188)); return n !== e ? null : e } for (var i = e, a = n; ;) { var c = i.return; if (c === null) break; var p = c.alternate; if (p === null) { if (a = c.return, a !== null) { i = a; continue } break } if (c.child === p.child) { for (p = c.child; p;) { if (p === i) return zg(c), e; if (p === a) return zg(c), n; p = p.sibling } throw Error(o(188)) } if (i.return !== a.return) i = c, a = p; else { for (var y = !1, k = c.child; k;) { if (k === i) { y = !0, i = c, a = p; break } if (k === a) { y = !0, a = c, i = p; break } k = k.sibling } if (!y) { for (k = p.child; k;) { if (k === i) { y = !0, i = p, a = c; break } if (k === a) { y = !0, a = p, i = c; break } k = k.sibling } if (!y) throw Error(o(189)) } } if (i.alternate !== a) throw Error(o(190)) } if (i.tag !== 3) throw Error(o(188)); return i.stateNode.current === i ? e : n } function Bg(e) { return e = ZP(e), e !== null ? Ug(e) : null } function Ug(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var n = Ug(e); if (n !== null) return n; e = e.sibling } return null } var Wg = r.unstable_scheduleCallback, $g = r.unstable_cancelCallback, JP = r.unstable_shouldYield, eE = r.unstable_requestPaint, Ue = r.unstable_now, tE = r.unstable_getCurrentPriorityLevel, Au = r.unstable_ImmediatePriority, Hg = r.unstable_UserBlockingPriority, bs = r.unstable_NormalPriority, nE = r.unstable_LowPriority, Kg = r.unstable_IdlePriority, ks = null, Xt = null; function rE(e) { if (Xt && typeof Xt.onCommitFiberRoot == "function") try { Xt.onCommitFiberRoot(ks, e, void 0, (e.current.flags & 128) === 128) } catch { } } var _t = Math.clz32 ? Math.clz32 : sE, oE = Math.log, iE = Math.LN2; function sE(e) { return e >>>= 0, e === 0 ? 32 : 31 - (oE(e) / iE | 0) | 0 } var Ps = 64, Es = 4194304; function qo(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function Ts(e, n) { var i = e.pendingLanes; if (i === 0) return 0; var a = 0, c = e.suspendedLanes, p = e.pingedLanes, y = i & 268435455; if (y !== 0) { var k = y & ~c; k !== 0 ? a = qo(k) : (p &= y, p !== 0 && (a = qo(p))) } else y = i & ~c, y !== 0 ? a = qo(y) : p !== 0 && (a = qo(p)); if (a === 0) return 0; if (n !== 0 && n !== a && !(n & c) && (c = a & -a, p = n & -n, c >= p || c === 16 && (p & 4194240) !== 0)) return n; if (a & 4 && (a |= i & 16), n = e.entangledLanes, n !== 0) for (e = e.entanglements, n &= a; 0 < n;)i = 31 - _t(n), c = 1 << i, a |= e[i], n &= ~c; return a } function aE(e, n) { switch (e) { case 1: case 2: case 4: return n + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return n + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function lE(e, n) { for (var i = e.suspendedLanes, a = e.pingedLanes, c = e.expirationTimes, p = e.pendingLanes; 0 < p;) { var y = 31 - _t(p), k = 1 << y, A = c[y]; A === -1 ? (!(k & i) || k & a) && (c[y] = aE(k, n)) : A <= n && (e.expiredLanes |= k), p &= ~k } } function Nu(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function Gg() { var e = Ps; return Ps <<= 1, !(Ps & 4194240) && (Ps = 64), e } function Mu(e) { for (var n = [], i = 0; 31 > i; i++)n.push(e); return n } function Zo(e, n, i) { e.pendingLanes |= n, n !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, n = 31 - _t(n), e[n] = i } function uE(e, n) { var i = e.pendingLanes & ~n; e.pendingLanes = n, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= n, e.mutableReadLanes &= n, e.entangledLanes &= n, n = e.entanglements; var a = e.eventTimes; for (e = e.expirationTimes; 0 < i;) { var c = 31 - _t(i), p = 1 << c; n[c] = 0, a[c] = -1, e[c] = -1, i &= ~p } } function Lu(e, n) { var i = e.entangledLanes |= n; for (e = e.entanglements; i;) { var a = 31 - _t(i), c = 1 << a; c & n | e[a] & n && (e[a] |= n), i &= ~c } } var Ee = 0; function Yg(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1 } var Xg, Du, Qg, qg, Zg, ju = !1, Rs = [], _n = null, In = null, Vn = null, Jo = new Map, ei = new Map, Fn = [], cE = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Jg(e, n) { switch (e) { case "focusin": case "focusout": _n = null; break; case "dragenter": case "dragleave": In = null; break; case "mouseover": case "mouseout": Vn = null; break; case "pointerover": case "pointerout": Jo.delete(n.pointerId); break; case "gotpointercapture": case "lostpointercapture": ei.delete(n.pointerId) } } function ti(e, n, i, a, c, p) { return e === null || e.nativeEvent !== p ? (e = { blockedOn: n, domEventName: i, eventSystemFlags: a, nativeEvent: p, targetContainers: [c] }, n !== null && (n = mi(n), n !== null && Du(n)), e) : (e.eventSystemFlags |= a, n = e.targetContainers, c !== null && n.indexOf(c) === -1 && n.push(c), e) } function dE(e, n, i, a, c) { switch (n) { case "focusin": return _n = ti(_n, e, n, i, a, c), !0; case "dragenter": return In = ti(In, e, n, i, a, c), !0; case "mouseover": return Vn = ti(Vn, e, n, i, a, c), !0; case "pointerover": var p = c.pointerId; return Jo.set(p, ti(Jo.get(p) || null, e, n, i, a, c)), !0; case "gotpointercapture": return p = c.pointerId, ei.set(p, ti(ei.get(p) || null, e, n, i, a, c)), !0 }return !1 } function ev(e) { var n = dr(e.target); if (n !== null) { var i = cr(n); if (i !== null) { if (n = i.tag, n === 13) { if (n = Fg(i), n !== null) { e.blockedOn = n, Zg(e.priority, function () { Qg(i) }); return } } else if (n === 3 && i.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = i.tag === 3 ? i.stateNode.containerInfo : null; return } } } e.blockedOn = null } function As(e) { if (e.blockedOn !== null) return !1; for (var n = e.targetContainers; 0 < n.length;) { var i = _u(e.domEventName, e.eventSystemFlags, n[0], e.nativeEvent); if (i === null) { i = e.nativeEvent; var a = new i.constructor(i.type, i); bu = a, i.target.dispatchEvent(a), bu = null } else return n = mi(i), n !== null && Du(n), e.blockedOn = i, !1; n.shift() } return !0 } function tv(e, n, i) { As(e) && i.delete(n) } function fE() { ju = !1, _n !== null && As(_n) && (_n = null), In !== null && As(In) && (In = null), Vn !== null && As(Vn) && (Vn = null), Jo.forEach(tv), ei.forEach(tv) } function ni(e, n) { e.blockedOn === n && (e.blockedOn = null, ju || (ju = !0, r.unstable_scheduleCallback(r.unstable_NormalPriority, fE))) } function ri(e) { function n(c) { return ni(c, e) } if (0 < Rs.length) { ni(Rs[0], e); for (var i = 1; i < Rs.length; i++) { var a = Rs[i]; a.blockedOn === e && (a.blockedOn = null) } } for (_n !== null && ni(_n, e), In !== null && ni(In, e), Vn !== null && ni(Vn, e), Jo.forEach(n), ei.forEach(n), i = 0; i < Fn.length; i++)a = Fn[i], a.blockedOn === e && (a.blockedOn = null); for (; 0 < Fn.length && (i = Fn[0], i.blockedOn === null);)ev(i), i.blockedOn === null && Fn.shift() } var Qr = j.ReactCurrentBatchConfig, Ns = !0; function pE(e, n, i, a) { var c = Ee, p = Qr.transition; Qr.transition = null; try { Ee = 1, Ou(e, n, i, a) } finally { Ee = c, Qr.transition = p } } function hE(e, n, i, a) { var c = Ee, p = Qr.transition; Qr.transition = null; try { Ee = 4, Ou(e, n, i, a) } finally { Ee = c, Qr.transition = p } } function Ou(e, n, i, a) { if (Ns) { var c = _u(e, n, i, a); if (c === null) Ju(e, n, a, Ms, i), Jg(e, a); else if (dE(c, e, n, i, a)) a.stopPropagation(); else if (Jg(e, a), n & 4 && -1 < cE.indexOf(e)) { for (; c !== null;) { var p = mi(c); if (p !== null && Xg(p), p = _u(e, n, i, a), p === null && Ju(e, n, a, Ms, i), p === c) break; c = p } c !== null && a.stopPropagation() } else Ju(e, n, a, null, i) } } var Ms = null; function _u(e, n, i, a) { if (Ms = null, e = ku(a), e = dr(e), e !== null) if (n = cr(e), n === null) e = null; else if (i = n.tag, i === 13) { if (e = Fg(n), e !== null) return e; e = null } else if (i === 3) { if (n.stateNode.current.memoizedState.isDehydrated) return n.tag === 3 ? n.stateNode.containerInfo : null; e = null } else n !== e && (e = null); return Ms = e, null } function nv(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (tE()) { case Au: return 1; case Hg: return 4; case bs: case nE: return 16; case Kg: return 536870912; default: return 16 }default: return 16 } } var zn = null, Iu = null, Ls = null; function rv() { if (Ls) return Ls; var e, n = Iu, i = n.length, a, c = "value" in zn ? zn.value : zn.textContent, p = c.length; for (e = 0; e < i && n[e] === c[e]; e++); var y = i - e; for (a = 1; a <= y && n[i - a] === c[p - a]; a++); return Ls = c.slice(e, 1 < a ? 1 - a : void 0) } function Ds(e) { var n = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && n === 13 && (e = 13)) : e = n, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function js() { return !0 } function ov() { return !1 } function xt(e) { function n(i, a, c, p, y) { this._reactName = i, this._targetInst = c, this.type = a, this.nativeEvent = p, this.target = y, this.currentTarget = null; for (var k in e) e.hasOwnProperty(k) && (i = e[k], this[k] = i ? i(p) : p[k]); return this.isDefaultPrevented = (p.defaultPrevented != null ? p.defaultPrevented : p.returnValue === !1) ? js : ov, this.isPropagationStopped = ov, this } return X(n.prototype, { preventDefault: function () { this.defaultPrevented = !0; var i = this.nativeEvent; i && (i.preventDefault ? i.preventDefault() : typeof i.returnValue != "unknown" && (i.returnValue = !1), this.isDefaultPrevented = js) }, stopPropagation: function () { var i = this.nativeEvent; i && (i.stopPropagation ? i.stopPropagation() : typeof i.cancelBubble != "unknown" && (i.cancelBubble = !0), this.isPropagationStopped = js) }, persist: function () { }, isPersistent: js }), n } var qr = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Vu = xt(qr), oi = X({}, qr, { view: 0, detail: 0 }), mE = xt(oi), Fu, zu, ii, Os = X({}, oi, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Uu, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== ii && (ii && e.type === "mousemove" ? (Fu = e.screenX - ii.screenX, zu = e.screenY - ii.screenY) : zu = Fu = 0, ii = e), Fu) }, movementY: function (e) { return "movementY" in e ? e.movementY : zu } }), iv = xt(Os), gE = X({}, Os, { dataTransfer: 0 }), vE = xt(gE), yE = X({}, oi, { relatedTarget: 0 }), Bu = xt(yE), wE = X({}, qr, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), xE = xt(wE), SE = X({}, qr, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), CE = xt(SE), bE = X({}, qr, { data: 0 }), sv = xt(bE), kE = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, PE = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, EE = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function TE(e) { var n = this.nativeEvent; return n.getModifierState ? n.getModifierState(e) : (e = EE[e]) ? !!n[e] : !1 } function Uu() { return TE } var RE = X({}, oi, { key: function (e) { if (e.key) { var n = kE[e.key] || e.key; if (n !== "Unidentified") return n } return e.type === "keypress" ? (e = Ds(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? PE[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Uu, charCode: function (e) { return e.type === "keypress" ? Ds(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? Ds(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), AE = xt(RE), NE = X({}, Os, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), av = xt(NE), ME = X({}, oi, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Uu }), LE = xt(ME), DE = X({}, qr, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), jE = xt(DE), OE = X({}, Os, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), _E = xt(OE), IE = [9, 13, 27, 32], Wu = f && "CompositionEvent" in window, si = null; f && "documentMode" in document && (si = document.documentMode); var VE = f && "TextEvent" in window && !si, lv = f && (!Wu || si && 8 < si && 11 >= si), uv = String.fromCharCode(32), cv = !1; function dv(e, n) { switch (e) { case "keyup": return IE.indexOf(n.keyCode) !== -1; case "keydown": return n.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function fv(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var Zr = !1; function FE(e, n) { switch (e) { case "compositionend": return fv(n); case "keypress": return n.which !== 32 ? null : (cv = !0, uv); case "textInput": return e = n.data, e === uv && cv ? null : e; default: return null } } function zE(e, n) { if (Zr) return e === "compositionend" || !Wu && dv(e, n) ? (e = rv(), Ls = Iu = zn = null, Zr = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(n.ctrlKey || n.altKey || n.metaKey) || n.ctrlKey && n.altKey) { if (n.char && 1 < n.char.length) return n.char; if (n.which) return String.fromCharCode(n.which) } return null; case "compositionend": return lv && n.locale !== "ko" ? null : n.data; default: return null } } var BE = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function pv(e) { var n = e && e.nodeName && e.nodeName.toLowerCase(); return n === "input" ? !!BE[e.type] : n === "textarea" } function hv(e, n, i, a) { jg(a), n = zs(n, "onChange"), 0 < n.length && (i = new Vu("onChange", "change", null, i, a), e.push({ event: i, listeners: n })) } var ai = null, li = null; function UE(e) { Lv(e, 0) } function _s(e) { var n = ro(e); if (Re(n)) return e } function WE(e, n) { if (e === "change") return n } var mv = !1; if (f) { var $u; if (f) { var Hu = "oninput" in document; if (!Hu) { var gv = document.createElement("div"); gv.setAttribute("oninput", "return;"), Hu = typeof gv.oninput == "function" } $u = Hu } else $u = !1; mv = $u && (!document.documentMode || 9 < document.documentMode) } function vv() { ai && (ai.detachEvent("onpropertychange", yv), li = ai = null) } function yv(e) { if (e.propertyName === "value" && _s(li)) { var n = []; hv(n, li, e, ku(e)), Vg(UE, n) } } function $E(e, n, i) { e === "focusin" ? (vv(), ai = n, li = i, ai.attachEvent("onpropertychange", yv)) : e === "focusout" && vv() } function HE(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return _s(li) } function KE(e, n) { if (e === "click") return _s(n) } function GE(e, n) { if (e === "input" || e === "change") return _s(n) } function YE(e, n) { return e === n && (e !== 0 || 1 / e === 1 / n) || e !== e && n !== n } var It = typeof Object.is == "function" ? Object.is : YE; function ui(e, n) { if (It(e, n)) return !0; if (typeof e != "object" || e === null || typeof n != "object" || n === null) return !1; var i = Object.keys(e), a = Object.keys(n); if (i.length !== a.length) return !1; for (a = 0; a < i.length; a++) { var c = i[a]; if (!h.call(n, c) || !It(e[c], n[c])) return !1 } return !0 } function wv(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function xv(e, n) { var i = wv(e); e = 0; for (var a; i;) { if (i.nodeType === 3) { if (a = e + i.textContent.length, e <= n && a >= n) return { node: i, offset: n - e }; e = a } e: { for (; i;) { if (i.nextSibling) { i = i.nextSibling; break e } i = i.parentNode } i = void 0 } i = wv(i) } } function Sv(e, n) { return e && n ? e === n ? !0 : e && e.nodeType === 3 ? !1 : n && n.nodeType === 3 ? Sv(e, n.parentNode) : "contains" in e ? e.contains(n) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(n) & 16) : !1 : !1 } function Cv() { for (var e = window, n = Be(); n instanceof e.HTMLIFrameElement;) { try { var i = typeof n.contentWindow.location.href == "string" } catch { i = !1 } if (i) e = n.contentWindow; else break; n = Be(e.document) } return n } function Ku(e) { var n = e && e.nodeName && e.nodeName.toLowerCase(); return n && (n === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || n === "textarea" || e.contentEditable === "true") } function XE(e) { var n = Cv(), i = e.focusedElem, a = e.selectionRange; if (n !== i && i && i.ownerDocument && Sv(i.ownerDocument.documentElement, i)) { if (a !== null && Ku(i)) { if (n = a.start, e = a.end, e === void 0 && (e = n), "selectionStart" in i) i.selectionStart = n, i.selectionEnd = Math.min(e, i.value.length); else if (e = (n = i.ownerDocument || document) && n.defaultView || window, e.getSelection) { e = e.getSelection(); var c = i.textContent.length, p = Math.min(a.start, c); a = a.end === void 0 ? p : Math.min(a.end, c), !e.extend && p > a && (c = a, a = p, p = c), c = xv(i, p); var y = xv(i, a); c && y && (e.rangeCount !== 1 || e.anchorNode !== c.node || e.anchorOffset !== c.offset || e.focusNode !== y.node || e.focusOffset !== y.offset) && (n = n.createRange(), n.setStart(c.node, c.offset), e.removeAllRanges(), p > a ? (e.addRange(n), e.extend(y.node, y.offset)) : (n.setEnd(y.node, y.offset), e.addRange(n))) } } for (n = [], e = i; e = e.parentNode;)e.nodeType === 1 && n.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof i.focus == "function" && i.focus(), i = 0; i < n.length; i++)e = n[i], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var QE = f && "documentMode" in document && 11 >= document.documentMode, Jr = null, Gu = null, ci = null, Yu = !1; function bv(e, n, i) { var a = i.window === i ? i.document : i.nodeType === 9 ? i : i.ownerDocument; Yu || Jr == null || Jr !== Be(a) || (a = Jr, "selectionStart" in a && Ku(a) ? a = { start: a.selectionStart, end: a.selectionEnd } : (a = (a.ownerDocument && a.ownerDocument.defaultView || window).getSelection(), a = { anchorNode: a.anchorNode, anchorOffset: a.anchorOffset, focusNode: a.focusNode, focusOffset: a.focusOffset }), ci && ui(ci, a) || (ci = a, a = zs(Gu, "onSelect"), 0 < a.length && (n = new Vu("onSelect", "select", null, n, i), e.push({ event: n, listeners: a }), n.target = Jr))) } function Is(e, n) { var i = {}; return i[e.toLowerCase()] = n.toLowerCase(), i["Webkit" + e] = "webkit" + n, i["Moz" + e] = "moz" + n, i } var eo = { animationend: Is("Animation", "AnimationEnd"), animationiteration: Is("Animation", "AnimationIteration"), animationstart: Is("Animation", "AnimationStart"), transitionend: Is("Transition", "TransitionEnd") }, Xu = {}, kv = {}; f && (kv = document.createElement("div").style, "AnimationEvent" in window || (delete eo.animationend.animation, delete eo.animationiteration.animation, delete eo.animationstart.animation), "TransitionEvent" in window || delete eo.transitionend.transition); function Vs(e) { if (Xu[e]) return Xu[e]; if (!eo[e]) return e; var n = eo[e], i; for (i in n) if (n.hasOwnProperty(i) && i in kv) return Xu[e] = n[i]; return e } var Pv = Vs("animationend"), Ev = Vs("animationiteration"), Tv = Vs("animationstart"), Rv = Vs("transitionend"), Av = new Map, Nv = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Bn(e, n) { Av.set(e, n), d(n, [e]) } for (var Qu = 0; Qu < Nv.length; Qu++) { var qu = Nv[Qu], qE = qu.toLowerCase(), ZE = qu[0].toUpperCase() + qu.slice(1); Bn(qE, "on" + ZE) } Bn(Pv, "onAnimationEnd"), Bn(Ev, "onAnimationIteration"), Bn(Tv, "onAnimationStart"), Bn("dblclick", "onDoubleClick"), Bn("focusin", "onFocus"), Bn("focusout", "onBlur"), Bn(Rv, "onTransitionEnd"), u("onMouseEnter", ["mouseout", "mouseover"]), u("onMouseLeave", ["mouseout", "mouseover"]), u("onPointerEnter", ["pointerout", "pointerover"]), u("onPointerLeave", ["pointerout", "pointerover"]), d("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), d("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), d("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), d("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), d("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), d("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var di = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), JE = new Set("cancel close invalid load scroll toggle".split(" ").concat(di)); function Mv(e, n, i) { var a = e.type || "unknown-event"; e.currentTarget = i, qP(a, n, void 0, e), e.currentTarget = null } function Lv(e, n) { n = (n & 4) !== 0; for (var i = 0; i < e.length; i++) { var a = e[i], c = a.event; a = a.listeners; e: { var p = void 0; if (n) for (var y = a.length - 1; 0 <= y; y--) { var k = a[y], A = k.instance, _ = k.currentTarget; if (k = k.listener, A !== p && c.isPropagationStopped()) break e; Mv(c, k, _), p = A } else for (y = 0; y < a.length; y++) { if (k = a[y], A = k.instance, _ = k.currentTarget, k = k.listener, A !== p && c.isPropagationStopped()) break e; Mv(c, k, _), p = A } } } if (Cs) throw e = Ru, Cs = !1, Ru = null, e } function Me(e, n) { var i = n[ic]; i === void 0 && (i = n[ic] = new Set); var a = e + "__bubble"; i.has(a) || (Dv(n, e, 2, !1), i.add(a)) } function Zu(e, n, i) { var a = 0; n && (a |= 4), Dv(i, e, a, n) } var Fs = "_reactListening" + Math.random().toString(36).slice(2); function fi(e) { if (!e[Fs]) { e[Fs] = !0, s.forEach(function (i) { i !== "selectionchange" && (JE.has(i) || Zu(i, !1, e), Zu(i, !0, e)) }); var n = e.nodeType === 9 ? e : e.ownerDocument; n === null || n[Fs] || (n[Fs] = !0, Zu("selectionchange", !1, n)) } } function Dv(e, n, i, a) { switch (nv(n)) { case 1: var c = pE; break; case 4: c = hE; break; default: c = Ou }i = c.bind(null, n, i, e), c = void 0, !Tu || n !== "touchstart" && n !== "touchmove" && n !== "wheel" || (c = !0), a ? c !== void 0 ? e.addEventListener(n, i, { capture: !0, passive: c }) : e.addEventListener(n, i, !0) : c !== void 0 ? e.addEventListener(n, i, { passive: c }) : e.addEventListener(n, i, !1) } function Ju(e, n, i, a, c) { var p = a; if (!(n & 1) && !(n & 2) && a !== null) e: for (; ;) { if (a === null) return; var y = a.tag; if (y === 3 || y === 4) { var k = a.stateNode.containerInfo; if (k === c || k.nodeType === 8 && k.parentNode === c) break; if (y === 4) for (y = a.return; y !== null;) { var A = y.tag; if ((A === 3 || A === 4) && (A = y.stateNode.containerInfo, A === c || A.nodeType === 8 && A.parentNode === c)) return; y = y.return } for (; k !== null;) { if (y = dr(k), y === null) return; if (A = y.tag, A === 5 || A === 6) { a = p = y; continue e } k = k.parentNode } } a = a.return } Vg(function () { var _ = p, B = ku(i), U = []; e: { var z = Av.get(e); if (z !== void 0) { var q = Vu, te = e; switch (e) { case "keypress": if (Ds(i) === 0) break e; case "keydown": case "keyup": q = AE; break; case "focusin": te = "focus", q = Bu; break; case "focusout": te = "blur", q = Bu; break; case "beforeblur": case "afterblur": q = Bu; break; case "click": if (i.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": q = iv; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": q = vE; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": q = LE; break; case Pv: case Ev: case Tv: q = xE; break; case Rv: q = jE; break; case "scroll": q = mE; break; case "wheel": q = _E; break; case "copy": case "cut": case "paste": q = CE; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": q = av }var re = (n & 4) !== 0, We = !re && e === "scroll", D = re ? z !== null ? z + "Capture" : null : z; re = []; for (var L = _, O; L !== null;) { O = L; var K = O.stateNode; if (O.tag === 5 && K !== null && (O = K, D !== null && (K = Yo(L, D), K != null && re.push(pi(L, K, O)))), We) break; L = L.return } 0 < re.length && (z = new q(z, te, null, i, B), U.push({ event: z, listeners: re })) } } if (!(n & 7)) { e: { if (z = e === "mouseover" || e === "pointerover", q = e === "mouseout" || e === "pointerout", z && i !== bu && (te = i.relatedTarget || i.fromElement) && (dr(te) || te[hn])) break e; if ((q || z) && (z = B.window === B ? B : (z = B.ownerDocument) ? z.defaultView || z.parentWindow : window, q ? (te = i.relatedTarget || i.toElement, q = _, te = te ? dr(te) : null, te !== null && (We = cr(te), te !== We || te.tag !== 5 && te.tag !== 6) && (te = null)) : (q = null, te = _), q !== te)) { if (re = iv, K = "onMouseLeave", D = "onMouseEnter", L = "mouse", (e === "pointerout" || e === "pointerover") && (re = av, K = "onPointerLeave", D = "onPointerEnter", L = "pointer"), We = q == null ? z : ro(q), O = te == null ? z : ro(te), z = new re(K, L + "leave", q, i, B), z.target = We, z.relatedTarget = O, K = null, dr(B) === _ && (re = new re(D, L + "enter", te, i, B), re.target = O, re.relatedTarget = We, K = re), We = K, q && te) t: { for (re = q, D = te, L = 0, O = re; O; O = to(O))L++; for (O = 0, K = D; K; K = to(K))O++; for (; 0 < L - O;)re = to(re), L--; for (; 0 < O - L;)D = to(D), O--; for (; L--;) { if (re === D || D !== null && re === D.alternate) break t; re = to(re), D = to(D) } re = null } else re = null; q !== null && jv(U, z, q, re, !1), te !== null && We !== null && jv(U, We, te, re, !0) } } e: { if (z = _ ? ro(_) : window, q = z.nodeName && z.nodeName.toLowerCase(), q === "select" || q === "input" && z.type === "file") var ie = WE; else if (pv(z)) if (mv) ie = GE; else { ie = HE; var de = $E } else (q = z.nodeName) && q.toLowerCase() === "input" && (z.type === "checkbox" || z.type === "radio") && (ie = KE); if (ie && (ie = ie(e, _))) { hv(U, ie, i, B); break e } de && de(e, z, _), e === "focusout" && (de = z._wrapperState) && de.controlled && z.type === "number" && yu(z, "number", z.value) } switch (de = _ ? ro(_) : window, e) { case "focusin": (pv(de) || de.contentEditable === "true") && (Jr = de, Gu = _, ci = null); break; case "focusout": ci = Gu = Jr = null; break; case "mousedown": Yu = !0; break; case "contextmenu": case "mouseup": case "dragend": Yu = !1, bv(U, i, B); break; case "selectionchange": if (QE) break; case "keydown": case "keyup": bv(U, i, B) }var fe; if (Wu) e: { switch (e) { case "compositionstart": var he = "onCompositionStart"; break e; case "compositionend": he = "onCompositionEnd"; break e; case "compositionupdate": he = "onCompositionUpdate"; break e }he = void 0 } else Zr ? dv(e, i) && (he = "onCompositionEnd") : e === "keydown" && i.keyCode === 229 && (he = "onCompositionStart"); he && (lv && i.locale !== "ko" && (Zr || he !== "onCompositionStart" ? he === "onCompositionEnd" && Zr && (fe = rv()) : (zn = B, Iu = "value" in zn ? zn.value : zn.textContent, Zr = !0)), de = zs(_, he), 0 < de.length && (he = new sv(he, e, null, i, B), U.push({ event: he, listeners: de }), fe ? he.data = fe : (fe = fv(i), fe !== null && (he.data = fe)))), (fe = VE ? FE(e, i) : zE(e, i)) && (_ = zs(_, "onBeforeInput"), 0 < _.length && (B = new sv("onBeforeInput", "beforeinput", null, i, B), U.push({ event: B, listeners: _ }), B.data = fe)) } Lv(U, n) }) } function pi(e, n, i) { return { instance: e, listener: n, currentTarget: i } } function zs(e, n) { for (var i = n + "Capture", a = []; e !== null;) { var c = e, p = c.stateNode; c.tag === 5 && p !== null && (c = p, p = Yo(e, i), p != null && a.unshift(pi(e, p, c)), p = Yo(e, n), p != null && a.push(pi(e, p, c))), e = e.return } return a } function to(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function jv(e, n, i, a, c) { for (var p = n._reactName, y = []; i !== null && i !== a;) { var k = i, A = k.alternate, _ = k.stateNode; if (A !== null && A === a) break; k.tag === 5 && _ !== null && (k = _, c ? (A = Yo(i, p), A != null && y.unshift(pi(i, A, k))) : c || (A = Yo(i, p), A != null && y.push(pi(i, A, k)))), i = i.return } y.length !== 0 && e.push({ event: n, listeners: y }) } var eT = /\r\n?/g, tT = /\u0000|\uFFFD/g; function Ov(e) {
      return (typeof e == "string" ? e : "" + e).replace(eT, `
`).replace(tT, "")
    } function Bs(e, n, i) { if (n = Ov(n), Ov(e) !== n && i) throw Error(o(425)) } function Us() { } var ec = null, tc = null; function nc(e, n) { return e === "textarea" || e === "noscript" || typeof n.children == "string" || typeof n.children == "number" || typeof n.dangerouslySetInnerHTML == "object" && n.dangerouslySetInnerHTML !== null && n.dangerouslySetInnerHTML.__html != null } var rc = typeof setTimeout == "function" ? setTimeout : void 0, nT = typeof clearTimeout == "function" ? clearTimeout : void 0, _v = typeof Promise == "function" ? Promise : void 0, rT = typeof queueMicrotask == "function" ? queueMicrotask : typeof _v < "u" ? function (e) { return _v.resolve(null).then(e).catch(oT) } : rc; function oT(e) { setTimeout(function () { throw e }) } function oc(e, n) { var i = n, a = 0; do { var c = i.nextSibling; if (e.removeChild(i), c && c.nodeType === 8) if (i = c.data, i === "/$") { if (a === 0) { e.removeChild(c), ri(n); return } a-- } else i !== "$" && i !== "$?" && i !== "$!" || a++; i = c } while (i); ri(n) } function Un(e) { for (; e != null; e = e.nextSibling) { var n = e.nodeType; if (n === 1 || n === 3) break; if (n === 8) { if (n = e.data, n === "$" || n === "$!" || n === "$?") break; if (n === "/$") return null } } return e } function Iv(e) { e = e.previousSibling; for (var n = 0; e;) { if (e.nodeType === 8) { var i = e.data; if (i === "$" || i === "$!" || i === "$?") { if (n === 0) return e; n-- } else i === "/$" && n++ } e = e.previousSibling } return null } var no = Math.random().toString(36).slice(2), Qt = "__reactFiber$" + no, hi = "__reactProps$" + no, hn = "__reactContainer$" + no, ic = "__reactEvents$" + no, iT = "__reactListeners$" + no, sT = "__reactHandles$" + no; function dr(e) { var n = e[Qt]; if (n) return n; for (var i = e.parentNode; i;) { if (n = i[hn] || i[Qt]) { if (i = n.alternate, n.child !== null || i !== null && i.child !== null) for (e = Iv(e); e !== null;) { if (i = e[Qt]) return i; e = Iv(e) } return n } e = i, i = e.parentNode } return null } function mi(e) { return e = e[Qt] || e[hn], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function ro(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(o(33)) } function Ws(e) { return e[hi] || null } var sc = [], oo = -1; function Wn(e) { return { current: e } } function Le(e) { 0 > oo || (e.current = sc[oo], sc[oo] = null, oo--) } function Ae(e, n) { oo++, sc[oo] = e.current, e.current = n } var $n = {}, it = Wn($n), ft = Wn(!1), fr = $n; function io(e, n) { var i = e.type.contextTypes; if (!i) return $n; var a = e.stateNode; if (a && a.__reactInternalMemoizedUnmaskedChildContext === n) return a.__reactInternalMemoizedMaskedChildContext; var c = {}, p; for (p in i) c[p] = n[p]; return a && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = n, e.__reactInternalMemoizedMaskedChildContext = c), c } function pt(e) { return e = e.childContextTypes, e != null } function $s() { Le(ft), Le(it) } function Vv(e, n, i) { if (it.current !== $n) throw Error(o(168)); Ae(it, n), Ae(ft, i) } function Fv(e, n, i) { var a = e.stateNode; if (n = n.childContextTypes, typeof a.getChildContext != "function") return i; a = a.getChildContext(); for (var c in a) if (!(c in n)) throw Error(o(108, Q(e) || "Unknown", c)); return X({}, i, a) } function Hs(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || $n, fr = it.current, Ae(it, e), Ae(ft, ft.current), !0 } function zv(e, n, i) { var a = e.stateNode; if (!a) throw Error(o(169)); i ? (e = Fv(e, n, fr), a.__reactInternalMemoizedMergedChildContext = e, Le(ft), Le(it), Ae(it, e)) : Le(ft), Ae(ft, i) } var mn = null, Ks = !1, ac = !1; function Bv(e) { mn === null ? mn = [e] : mn.push(e) } function aT(e) { Ks = !0, Bv(e) } function Hn() { if (!ac && mn !== null) { ac = !0; var e = 0, n = Ee; try { var i = mn; for (Ee = 1; e < i.length; e++) { var a = i[e]; do a = a(!0); while (a !== null) } mn = null, Ks = !1 } catch (c) { throw mn !== null && (mn = mn.slice(e + 1)), Wg(Au, Hn), c } finally { Ee = n, ac = !1 } } return null } var so = [], ao = 0, Gs = null, Ys = 0, Tt = [], Rt = 0, pr = null, gn = 1, vn = ""; function hr(e, n) { so[ao++] = Ys, so[ao++] = Gs, Gs = e, Ys = n } function Uv(e, n, i) { Tt[Rt++] = gn, Tt[Rt++] = vn, Tt[Rt++] = pr, pr = e; var a = gn; e = vn; var c = 32 - _t(a) - 1; a &= ~(1 << c), i += 1; var p = 32 - _t(n) + c; if (30 < p) { var y = c - c % 5; p = (a & (1 << y) - 1).toString(32), a >>= y, c -= y, gn = 1 << 32 - _t(n) + c | i << c | a, vn = p + e } else gn = 1 << p | i << c | a, vn = e } function lc(e) { e.return !== null && (hr(e, 1), Uv(e, 1, 0)) } function uc(e) { for (; e === Gs;)Gs = so[--ao], so[ao] = null, Ys = so[--ao], so[ao] = null; for (; e === pr;)pr = Tt[--Rt], Tt[Rt] = null, vn = Tt[--Rt], Tt[Rt] = null, gn = Tt[--Rt], Tt[Rt] = null } var St = null, Ct = null, De = !1, Vt = null; function Wv(e, n) { var i = Lt(5, null, null, 0); i.elementType = "DELETED", i.stateNode = n, i.return = e, n = e.deletions, n === null ? (e.deletions = [i], e.flags |= 16) : n.push(i) } function $v(e, n) { switch (e.tag) { case 5: var i = e.type; return n = n.nodeType !== 1 || i.toLowerCase() !== n.nodeName.toLowerCase() ? null : n, n !== null ? (e.stateNode = n, St = e, Ct = Un(n.firstChild), !0) : !1; case 6: return n = e.pendingProps === "" || n.nodeType !== 3 ? null : n, n !== null ? (e.stateNode = n, St = e, Ct = null, !0) : !1; case 13: return n = n.nodeType !== 8 ? null : n, n !== null ? (i = pr !== null ? { id: gn, overflow: vn } : null, e.memoizedState = { dehydrated: n, treeContext: i, retryLane: 1073741824 }, i = Lt(18, null, null, 0), i.stateNode = n, i.return = e, e.child = i, St = e, Ct = null, !0) : !1; default: return !1 } } function cc(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function dc(e) { if (De) { var n = Ct; if (n) { var i = n; if (!$v(e, n)) { if (cc(e)) throw Error(o(418)); n = Un(i.nextSibling); var a = St; n && $v(e, n) ? Wv(a, i) : (e.flags = e.flags & -4097 | 2, De = !1, St = e) } } else { if (cc(e)) throw Error(o(418)); e.flags = e.flags & -4097 | 2, De = !1, St = e } } } function Hv(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; St = e } function Xs(e) { if (e !== St) return !1; if (!De) return Hv(e), De = !0, !1; var n; if ((n = e.tag !== 3) && !(n = e.tag !== 5) && (n = e.type, n = n !== "head" && n !== "body" && !nc(e.type, e.memoizedProps)), n && (n = Ct)) { if (cc(e)) throw Kv(), Error(o(418)); for (; n;)Wv(e, n), n = Un(n.nextSibling) } if (Hv(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(o(317)); e: { for (e = e.nextSibling, n = 0; e;) { if (e.nodeType === 8) { var i = e.data; if (i === "/$") { if (n === 0) { Ct = Un(e.nextSibling); break e } n-- } else i !== "$" && i !== "$!" && i !== "$?" || n++ } e = e.nextSibling } Ct = null } } else Ct = St ? Un(e.stateNode.nextSibling) : null; return !0 } function Kv() { for (var e = Ct; e;)e = Un(e.nextSibling) } function lo() { Ct = St = null, De = !1 } function fc(e) { Vt === null ? Vt = [e] : Vt.push(e) } var lT = j.ReactCurrentBatchConfig; function gi(e, n, i) { if (e = i.ref, e !== null && typeof e != "function" && typeof e != "object") { if (i._owner) { if (i = i._owner, i) { if (i.tag !== 1) throw Error(o(309)); var a = i.stateNode } if (!a) throw Error(o(147, e)); var c = a, p = "" + e; return n !== null && n.ref !== null && typeof n.ref == "function" && n.ref._stringRef === p ? n.ref : (n = function (y) { var k = c.refs; y === null ? delete k[p] : k[p] = y }, n._stringRef = p, n) } if (typeof e != "string") throw Error(o(284)); if (!i._owner) throw Error(o(290, e)) } return e } function Qs(e, n) { throw e = Object.prototype.toString.call(n), Error(o(31, e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e)) } function Gv(e) { var n = e._init; return n(e._payload) } function Yv(e) { function n(D, L) { if (e) { var O = D.deletions; O === null ? (D.deletions = [L], D.flags |= 16) : O.push(L) } } function i(D, L) { if (!e) return null; for (; L !== null;)n(D, L), L = L.sibling; return null } function a(D, L) { for (D = new Map; L !== null;)L.key !== null ? D.set(L.key, L) : D.set(L.index, L), L = L.sibling; return D } function c(D, L) { return D = Jn(D, L), D.index = 0, D.sibling = null, D } function p(D, L, O) { return D.index = O, e ? (O = D.alternate, O !== null ? (O = O.index, O < L ? (D.flags |= 2, L) : O) : (D.flags |= 2, L)) : (D.flags |= 1048576, L) } function y(D) { return e && D.alternate === null && (D.flags |= 2), D } function k(D, L, O, K) { return L === null || L.tag !== 6 ? (L = rd(O, D.mode, K), L.return = D, L) : (L = c(L, O), L.return = D, L) } function A(D, L, O, K) { var ie = O.type; return ie === $ ? B(D, L, O.props.children, K, O.key) : L !== null && (L.elementType === ie || typeof ie == "object" && ie !== null && ie.$$typeof === se && Gv(ie) === L.type) ? (K = c(L, O.props), K.ref = gi(D, L, O), K.return = D, K) : (K = xa(O.type, O.key, O.props, null, D.mode, K), K.ref = gi(D, L, O), K.return = D, K) } function _(D, L, O, K) { return L === null || L.tag !== 4 || L.stateNode.containerInfo !== O.containerInfo || L.stateNode.implementation !== O.implementation ? (L = od(O, D.mode, K), L.return = D, L) : (L = c(L, O.children || []), L.return = D, L) } function B(D, L, O, K, ie) { return L === null || L.tag !== 7 ? (L = Cr(O, D.mode, K, ie), L.return = D, L) : (L = c(L, O), L.return = D, L) } function U(D, L, O) { if (typeof L == "string" && L !== "" || typeof L == "number") return L = rd("" + L, D.mode, O), L.return = D, L; if (typeof L == "object" && L !== null) { switch (L.$$typeof) { case I: return O = xa(L.type, L.key, L.props, null, D.mode, O), O.ref = gi(D, null, L), O.return = D, O; case H: return L = od(L, D.mode, O), L.return = D, L; case se: var K = L._init; return U(D, K(L._payload), O) }if (Ho(L) || Y(L)) return L = Cr(L, D.mode, O, null), L.return = D, L; Qs(D, L) } return null } function z(D, L, O, K) { var ie = L !== null ? L.key : null; if (typeof O == "string" && O !== "" || typeof O == "number") return ie !== null ? null : k(D, L, "" + O, K); if (typeof O == "object" && O !== null) { switch (O.$$typeof) { case I: return O.key === ie ? A(D, L, O, K) : null; case H: return O.key === ie ? _(D, L, O, K) : null; case se: return ie = O._init, z(D, L, ie(O._payload), K) }if (Ho(O) || Y(O)) return ie !== null ? null : B(D, L, O, K, null); Qs(D, O) } return null } function q(D, L, O, K, ie) { if (typeof K == "string" && K !== "" || typeof K == "number") return D = D.get(O) || null, k(L, D, "" + K, ie); if (typeof K == "object" && K !== null) { switch (K.$$typeof) { case I: return D = D.get(K.key === null ? O : K.key) || null, A(L, D, K, ie); case H: return D = D.get(K.key === null ? O : K.key) || null, _(L, D, K, ie); case se: var de = K._init; return q(D, L, O, de(K._payload), ie) }if (Ho(K) || Y(K)) return D = D.get(O) || null, B(L, D, K, ie, null); Qs(L, K) } return null } function te(D, L, O, K) { for (var ie = null, de = null, fe = L, he = L = 0, Qe = null; fe !== null && he < O.length; he++) { fe.index > he ? (Qe = fe, fe = null) : Qe = fe.sibling; var Pe = z(D, fe, O[he], K); if (Pe === null) { fe === null && (fe = Qe); break } e && fe && Pe.alternate === null && n(D, fe), L = p(Pe, L, he), de === null ? ie = Pe : de.sibling = Pe, de = Pe, fe = Qe } if (he === O.length) return i(D, fe), De && hr(D, he), ie; if (fe === null) { for (; he < O.length; he++)fe = U(D, O[he], K), fe !== null && (L = p(fe, L, he), de === null ? ie = fe : de.sibling = fe, de = fe); return De && hr(D, he), ie } for (fe = a(D, fe); he < O.length; he++)Qe = q(fe, D, he, O[he], K), Qe !== null && (e && Qe.alternate !== null && fe.delete(Qe.key === null ? he : Qe.key), L = p(Qe, L, he), de === null ? ie = Qe : de.sibling = Qe, de = Qe); return e && fe.forEach(function (er) { return n(D, er) }), De && hr(D, he), ie } function re(D, L, O, K) { var ie = Y(O); if (typeof ie != "function") throw Error(o(150)); if (O = ie.call(O), O == null) throw Error(o(151)); for (var de = ie = null, fe = L, he = L = 0, Qe = null, Pe = O.next(); fe !== null && !Pe.done; he++, Pe = O.next()) { fe.index > he ? (Qe = fe, fe = null) : Qe = fe.sibling; var er = z(D, fe, Pe.value, K); if (er === null) { fe === null && (fe = Qe); break } e && fe && er.alternate === null && n(D, fe), L = p(er, L, he), de === null ? ie = er : de.sibling = er, de = er, fe = Qe } if (Pe.done) return i(D, fe), De && hr(D, he), ie; if (fe === null) { for (; !Pe.done; he++, Pe = O.next())Pe = U(D, Pe.value, K), Pe !== null && (L = p(Pe, L, he), de === null ? ie = Pe : de.sibling = Pe, de = Pe); return De && hr(D, he), ie } for (fe = a(D, fe); !Pe.done; he++, Pe = O.next())Pe = q(fe, D, he, Pe.value, K), Pe !== null && (e && Pe.alternate !== null && fe.delete(Pe.key === null ? he : Pe.key), L = p(Pe, L, he), de === null ? ie = Pe : de.sibling = Pe, de = Pe); return e && fe.forEach(function (BT) { return n(D, BT) }), De && hr(D, he), ie } function We(D, L, O, K) { if (typeof O == "object" && O !== null && O.type === $ && O.key === null && (O = O.props.children), typeof O == "object" && O !== null) { switch (O.$$typeof) { case I: e: { for (var ie = O.key, de = L; de !== null;) { if (de.key === ie) { if (ie = O.type, ie === $) { if (de.tag === 7) { i(D, de.sibling), L = c(de, O.props.children), L.return = D, D = L; break e } } else if (de.elementType === ie || typeof ie == "object" && ie !== null && ie.$$typeof === se && Gv(ie) === de.type) { i(D, de.sibling), L = c(de, O.props), L.ref = gi(D, de, O), L.return = D, D = L; break e } i(D, de); break } else n(D, de); de = de.sibling } O.type === $ ? (L = Cr(O.props.children, D.mode, K, O.key), L.return = D, D = L) : (K = xa(O.type, O.key, O.props, null, D.mode, K), K.ref = gi(D, L, O), K.return = D, D = K) } return y(D); case H: e: { for (de = O.key; L !== null;) { if (L.key === de) if (L.tag === 4 && L.stateNode.containerInfo === O.containerInfo && L.stateNode.implementation === O.implementation) { i(D, L.sibling), L = c(L, O.children || []), L.return = D, D = L; break e } else { i(D, L); break } else n(D, L); L = L.sibling } L = od(O, D.mode, K), L.return = D, D = L } return y(D); case se: return de = O._init, We(D, L, de(O._payload), K) }if (Ho(O)) return te(D, L, O, K); if (Y(O)) return re(D, L, O, K); Qs(D, O) } return typeof O == "string" && O !== "" || typeof O == "number" ? (O = "" + O, L !== null && L.tag === 6 ? (i(D, L.sibling), L = c(L, O), L.return = D, D = L) : (i(D, L), L = rd(O, D.mode, K), L.return = D, D = L), y(D)) : i(D, L) } return We } var uo = Yv(!0), Xv = Yv(!1), qs = Wn(null), Zs = null, co = null, pc = null; function hc() { pc = co = Zs = null } function mc(e) { var n = qs.current; Le(qs), e._currentValue = n } function gc(e, n, i) { for (; e !== null;) { var a = e.alternate; if ((e.childLanes & n) !== n ? (e.childLanes |= n, a !== null && (a.childLanes |= n)) : a !== null && (a.childLanes & n) !== n && (a.childLanes |= n), e === i) break; e = e.return } } function fo(e, n) { Zs = e, pc = co = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & n && (ht = !0), e.firstContext = null) } function At(e) { var n = e._currentValue; if (pc !== e) if (e = { context: e, memoizedValue: n, next: null }, co === null) { if (Zs === null) throw Error(o(308)); co = e, Zs.dependencies = { lanes: 0, firstContext: e } } else co = co.next = e; return n } var mr = null; function vc(e) { mr === null ? mr = [e] : mr.push(e) } function Qv(e, n, i, a) { var c = n.interleaved; return c === null ? (i.next = i, vc(n)) : (i.next = c.next, c.next = i), n.interleaved = i, yn(e, a) } function yn(e, n) { e.lanes |= n; var i = e.alternate; for (i !== null && (i.lanes |= n), i = e, e = e.return; e !== null;)e.childLanes |= n, i = e.alternate, i !== null && (i.childLanes |= n), i = e, e = e.return; return i.tag === 3 ? i.stateNode : null } var Kn = !1; function yc(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function qv(e, n) { e = e.updateQueue, n.updateQueue === e && (n.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function wn(e, n) { return { eventTime: e, lane: n, tag: 0, payload: null, callback: null, next: null } } function Gn(e, n, i) { var a = e.updateQueue; if (a === null) return null; if (a = a.shared, ke & 2) { var c = a.pending; return c === null ? n.next = n : (n.next = c.next, c.next = n), a.pending = n, yn(e, i) } return c = a.interleaved, c === null ? (n.next = n, vc(a)) : (n.next = c.next, c.next = n), a.interleaved = n, yn(e, i) } function Js(e, n, i) { if (n = n.updateQueue, n !== null && (n = n.shared, (i & 4194240) !== 0)) { var a = n.lanes; a &= e.pendingLanes, i |= a, n.lanes = i, Lu(e, i) } } function Zv(e, n) { var i = e.updateQueue, a = e.alternate; if (a !== null && (a = a.updateQueue, i === a)) { var c = null, p = null; if (i = i.firstBaseUpdate, i !== null) { do { var y = { eventTime: i.eventTime, lane: i.lane, tag: i.tag, payload: i.payload, callback: i.callback, next: null }; p === null ? c = p = y : p = p.next = y, i = i.next } while (i !== null); p === null ? c = p = n : p = p.next = n } else c = p = n; i = { baseState: a.baseState, firstBaseUpdate: c, lastBaseUpdate: p, shared: a.shared, effects: a.effects }, e.updateQueue = i; return } e = i.lastBaseUpdate, e === null ? i.firstBaseUpdate = n : e.next = n, i.lastBaseUpdate = n } function ea(e, n, i, a) { var c = e.updateQueue; Kn = !1; var p = c.firstBaseUpdate, y = c.lastBaseUpdate, k = c.shared.pending; if (k !== null) { c.shared.pending = null; var A = k, _ = A.next; A.next = null, y === null ? p = _ : y.next = _, y = A; var B = e.alternate; B !== null && (B = B.updateQueue, k = B.lastBaseUpdate, k !== y && (k === null ? B.firstBaseUpdate = _ : k.next = _, B.lastBaseUpdate = A)) } if (p !== null) { var U = c.baseState; y = 0, B = _ = A = null, k = p; do { var z = k.lane, q = k.eventTime; if ((a & z) === z) { B !== null && (B = B.next = { eventTime: q, lane: 0, tag: k.tag, payload: k.payload, callback: k.callback, next: null }); e: { var te = e, re = k; switch (z = n, q = i, re.tag) { case 1: if (te = re.payload, typeof te == "function") { U = te.call(q, U, z); break e } U = te; break e; case 3: te.flags = te.flags & -65537 | 128; case 0: if (te = re.payload, z = typeof te == "function" ? te.call(q, U, z) : te, z == null) break e; U = X({}, U, z); break e; case 2: Kn = !0 } } k.callback !== null && k.lane !== 0 && (e.flags |= 64, z = c.effects, z === null ? c.effects = [k] : z.push(k)) } else q = { eventTime: q, lane: z, tag: k.tag, payload: k.payload, callback: k.callback, next: null }, B === null ? (_ = B = q, A = U) : B = B.next = q, y |= z; if (k = k.next, k === null) { if (k = c.shared.pending, k === null) break; z = k, k = z.next, z.next = null, c.lastBaseUpdate = z, c.shared.pending = null } } while (1); if (B === null && (A = U), c.baseState = A, c.firstBaseUpdate = _, c.lastBaseUpdate = B, n = c.shared.interleaved, n !== null) { c = n; do y |= c.lane, c = c.next; while (c !== n) } else p === null && (c.shared.lanes = 0); yr |= y, e.lanes = y, e.memoizedState = U } } function Jv(e, n, i) { if (e = n.effects, n.effects = null, e !== null) for (n = 0; n < e.length; n++) { var a = e[n], c = a.callback; if (c !== null) { if (a.callback = null, a = i, typeof c != "function") throw Error(o(191, c)); c.call(a) } } } var vi = {}, qt = Wn(vi), yi = Wn(vi), wi = Wn(vi); function gr(e) { if (e === vi) throw Error(o(174)); return e } function wc(e, n) { switch (Ae(wi, n), Ae(yi, e), Ae(qt, vi), e = n.nodeType, e) { case 9: case 11: n = (n = n.documentElement) ? n.namespaceURI : xu(null, ""); break; default: e = e === 8 ? n.parentNode : n, n = e.namespaceURI || null, e = e.tagName, n = xu(n, e) }Le(qt), Ae(qt, n) } function po() { Le(qt), Le(yi), Le(wi) } function ey(e) { gr(wi.current); var n = gr(qt.current), i = xu(n, e.type); n !== i && (Ae(yi, e), Ae(qt, i)) } function xc(e) { yi.current === e && (Le(qt), Le(yi)) } var _e = Wn(0); function ta(e) { for (var n = e; n !== null;) { if (n.tag === 13) { var i = n.memoizedState; if (i !== null && (i = i.dehydrated, i === null || i.data === "$?" || i.data === "$!")) return n } else if (n.tag === 19 && n.memoizedProps.revealOrder !== void 0) { if (n.flags & 128) return n } else if (n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return null; n = n.return } n.sibling.return = n.return, n = n.sibling } return null } var Sc = []; function Cc() { for (var e = 0; e < Sc.length; e++)Sc[e]._workInProgressVersionPrimary = null; Sc.length = 0 } var na = j.ReactCurrentDispatcher, bc = j.ReactCurrentBatchConfig, vr = 0, Ie = null, He = null, Ye = null, ra = !1, xi = !1, Si = 0, uT = 0; function st() { throw Error(o(321)) } function kc(e, n) { if (n === null) return !1; for (var i = 0; i < n.length && i < e.length; i++)if (!It(e[i], n[i])) return !1; return !0 } function Pc(e, n, i, a, c, p) { if (vr = p, Ie = n, n.memoizedState = null, n.updateQueue = null, n.lanes = 0, na.current = e === null || e.memoizedState === null ? pT : hT, e = i(a, c), xi) { p = 0; do { if (xi = !1, Si = 0, 25 <= p) throw Error(o(301)); p += 1, Ye = He = null, n.updateQueue = null, na.current = mT, e = i(a, c) } while (xi) } if (na.current = sa, n = He !== null && He.next !== null, vr = 0, Ye = He = Ie = null, ra = !1, n) throw Error(o(300)); return e } function Ec() { var e = Si !== 0; return Si = 0, e } function Zt() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Ye === null ? Ie.memoizedState = Ye = e : Ye = Ye.next = e, Ye } function Nt() { if (He === null) { var e = Ie.alternate; e = e !== null ? e.memoizedState : null } else e = He.next; var n = Ye === null ? Ie.memoizedState : Ye.next; if (n !== null) Ye = n, He = e; else { if (e === null) throw Error(o(310)); He = e, e = { memoizedState: He.memoizedState, baseState: He.baseState, baseQueue: He.baseQueue, queue: He.queue, next: null }, Ye === null ? Ie.memoizedState = Ye = e : Ye = Ye.next = e } return Ye } function Ci(e, n) { return typeof n == "function" ? n(e) : n } function Tc(e) { var n = Nt(), i = n.queue; if (i === null) throw Error(o(311)); i.lastRenderedReducer = e; var a = He, c = a.baseQueue, p = i.pending; if (p !== null) { if (c !== null) { var y = c.next; c.next = p.next, p.next = y } a.baseQueue = c = p, i.pending = null } if (c !== null) { p = c.next, a = a.baseState; var k = y = null, A = null, _ = p; do { var B = _.lane; if ((vr & B) === B) A !== null && (A = A.next = { lane: 0, action: _.action, hasEagerState: _.hasEagerState, eagerState: _.eagerState, next: null }), a = _.hasEagerState ? _.eagerState : e(a, _.action); else { var U = { lane: B, action: _.action, hasEagerState: _.hasEagerState, eagerState: _.eagerState, next: null }; A === null ? (k = A = U, y = a) : A = A.next = U, Ie.lanes |= B, yr |= B } _ = _.next } while (_ !== null && _ !== p); A === null ? y = a : A.next = k, It(a, n.memoizedState) || (ht = !0), n.memoizedState = a, n.baseState = y, n.baseQueue = A, i.lastRenderedState = a } if (e = i.interleaved, e !== null) { c = e; do p = c.lane, Ie.lanes |= p, yr |= p, c = c.next; while (c !== e) } else c === null && (i.lanes = 0); return [n.memoizedState, i.dispatch] } function Rc(e) { var n = Nt(), i = n.queue; if (i === null) throw Error(o(311)); i.lastRenderedReducer = e; var a = i.dispatch, c = i.pending, p = n.memoizedState; if (c !== null) { i.pending = null; var y = c = c.next; do p = e(p, y.action), y = y.next; while (y !== c); It(p, n.memoizedState) || (ht = !0), n.memoizedState = p, n.baseQueue === null && (n.baseState = p), i.lastRenderedState = p } return [p, a] } function ty() { } function ny(e, n) { var i = Ie, a = Nt(), c = n(), p = !It(a.memoizedState, c); if (p && (a.memoizedState = c, ht = !0), a = a.queue, Ac(iy.bind(null, i, a, e), [e]), a.getSnapshot !== n || p || Ye !== null && Ye.memoizedState.tag & 1) { if (i.flags |= 2048, bi(9, oy.bind(null, i, a, c, n), void 0, null), Xe === null) throw Error(o(349)); vr & 30 || ry(i, n, c) } return c } function ry(e, n, i) { e.flags |= 16384, e = { getSnapshot: n, value: i }, n = Ie.updateQueue, n === null ? (n = { lastEffect: null, stores: null }, Ie.updateQueue = n, n.stores = [e]) : (i = n.stores, i === null ? n.stores = [e] : i.push(e)) } function oy(e, n, i, a) { n.value = i, n.getSnapshot = a, sy(n) && ay(e) } function iy(e, n, i) { return i(function () { sy(n) && ay(e) }) } function sy(e) { var n = e.getSnapshot; e = e.value; try { var i = n(); return !It(e, i) } catch { return !0 } } function ay(e) { var n = yn(e, 1); n !== null && Ut(n, e, 1, -1) } function ly(e) { var n = Zt(); return typeof e == "function" && (e = e()), n.memoizedState = n.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ci, lastRenderedState: e }, n.queue = e, e = e.dispatch = fT.bind(null, Ie, e), [n.memoizedState, e] } function bi(e, n, i, a) { return e = { tag: e, create: n, destroy: i, deps: a, next: null }, n = Ie.updateQueue, n === null ? (n = { lastEffect: null, stores: null }, Ie.updateQueue = n, n.lastEffect = e.next = e) : (i = n.lastEffect, i === null ? n.lastEffect = e.next = e : (a = i.next, i.next = e, e.next = a, n.lastEffect = e)), e } function uy() { return Nt().memoizedState } function oa(e, n, i, a) { var c = Zt(); Ie.flags |= e, c.memoizedState = bi(1 | n, i, void 0, a === void 0 ? null : a) } function ia(e, n, i, a) { var c = Nt(); a = a === void 0 ? null : a; var p = void 0; if (He !== null) { var y = He.memoizedState; if (p = y.destroy, a !== null && kc(a, y.deps)) { c.memoizedState = bi(n, i, p, a); return } } Ie.flags |= e, c.memoizedState = bi(1 | n, i, p, a) } function cy(e, n) { return oa(8390656, 8, e, n) } function Ac(e, n) { return ia(2048, 8, e, n) } function dy(e, n) { return ia(4, 2, e, n) } function fy(e, n) { return ia(4, 4, e, n) } function py(e, n) { if (typeof n == "function") return e = e(), n(e), function () { n(null) }; if (n != null) return e = e(), n.current = e, function () { n.current = null } } function hy(e, n, i) { return i = i != null ? i.concat([e]) : null, ia(4, 4, py.bind(null, n, e), i) } function Nc() { } function my(e, n) { var i = Nt(); n = n === void 0 ? null : n; var a = i.memoizedState; return a !== null && n !== null && kc(n, a[1]) ? a[0] : (i.memoizedState = [e, n], e) } function gy(e, n) { var i = Nt(); n = n === void 0 ? null : n; var a = i.memoizedState; return a !== null && n !== null && kc(n, a[1]) ? a[0] : (e = e(), i.memoizedState = [e, n], e) } function vy(e, n, i) { return vr & 21 ? (It(i, n) || (i = Gg(), Ie.lanes |= i, yr |= i, e.baseState = !0), n) : (e.baseState && (e.baseState = !1, ht = !0), e.memoizedState = i) } function cT(e, n) { var i = Ee; Ee = i !== 0 && 4 > i ? i : 4, e(!0); var a = bc.transition; bc.transition = {}; try { e(!1), n() } finally { Ee = i, bc.transition = a } } function yy() { return Nt().memoizedState } function dT(e, n, i) { var a = qn(e); if (i = { lane: a, action: i, hasEagerState: !1, eagerState: null, next: null }, wy(e)) xy(n, i); else if (i = Qv(e, n, i, a), i !== null) { var c = ct(); Ut(i, e, a, c), Sy(i, n, a) } } function fT(e, n, i) { var a = qn(e), c = { lane: a, action: i, hasEagerState: !1, eagerState: null, next: null }; if (wy(e)) xy(n, c); else { var p = e.alternate; if (e.lanes === 0 && (p === null || p.lanes === 0) && (p = n.lastRenderedReducer, p !== null)) try { var y = n.lastRenderedState, k = p(y, i); if (c.hasEagerState = !0, c.eagerState = k, It(k, y)) { var A = n.interleaved; A === null ? (c.next = c, vc(n)) : (c.next = A.next, A.next = c), n.interleaved = c; return } } catch { } finally { } i = Qv(e, n, c, a), i !== null && (c = ct(), Ut(i, e, a, c), Sy(i, n, a)) } } function wy(e) { var n = e.alternate; return e === Ie || n !== null && n === Ie } function xy(e, n) { xi = ra = !0; var i = e.pending; i === null ? n.next = n : (n.next = i.next, i.next = n), e.pending = n } function Sy(e, n, i) { if (i & 4194240) { var a = n.lanes; a &= e.pendingLanes, i |= a, n.lanes = i, Lu(e, i) } } var sa = { readContext: At, useCallback: st, useContext: st, useEffect: st, useImperativeHandle: st, useInsertionEffect: st, useLayoutEffect: st, useMemo: st, useReducer: st, useRef: st, useState: st, useDebugValue: st, useDeferredValue: st, useTransition: st, useMutableSource: st, useSyncExternalStore: st, useId: st, unstable_isNewReconciler: !1 }, pT = { readContext: At, useCallback: function (e, n) { return Zt().memoizedState = [e, n === void 0 ? null : n], e }, useContext: At, useEffect: cy, useImperativeHandle: function (e, n, i) { return i = i != null ? i.concat([e]) : null, oa(4194308, 4, py.bind(null, n, e), i) }, useLayoutEffect: function (e, n) { return oa(4194308, 4, e, n) }, useInsertionEffect: function (e, n) { return oa(4, 2, e, n) }, useMemo: function (e, n) { var i = Zt(); return n = n === void 0 ? null : n, e = e(), i.memoizedState = [e, n], e }, useReducer: function (e, n, i) { var a = Zt(); return n = i !== void 0 ? i(n) : n, a.memoizedState = a.baseState = n, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: n }, a.queue = e, e = e.dispatch = dT.bind(null, Ie, e), [a.memoizedState, e] }, useRef: function (e) { var n = Zt(); return e = { current: e }, n.memoizedState = e }, useState: ly, useDebugValue: Nc, useDeferredValue: function (e) { return Zt().memoizedState = e }, useTransition: function () { var e = ly(!1), n = e[0]; return e = cT.bind(null, e[1]), Zt().memoizedState = e, [n, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, n, i) { var a = Ie, c = Zt(); if (De) { if (i === void 0) throw Error(o(407)); i = i() } else { if (i = n(), Xe === null) throw Error(o(349)); vr & 30 || ry(a, n, i) } c.memoizedState = i; var p = { value: i, getSnapshot: n }; return c.queue = p, cy(iy.bind(null, a, p, e), [e]), a.flags |= 2048, bi(9, oy.bind(null, a, p, i, n), void 0, null), i }, useId: function () { var e = Zt(), n = Xe.identifierPrefix; if (De) { var i = vn, a = gn; i = (a & ~(1 << 32 - _t(a) - 1)).toString(32) + i, n = ":" + n + "R" + i, i = Si++, 0 < i && (n += "H" + i.toString(32)), n += ":" } else i = uT++, n = ":" + n + "r" + i.toString(32) + ":"; return e.memoizedState = n }, unstable_isNewReconciler: !1 }, hT = { readContext: At, useCallback: my, useContext: At, useEffect: Ac, useImperativeHandle: hy, useInsertionEffect: dy, useLayoutEffect: fy, useMemo: gy, useReducer: Tc, useRef: uy, useState: function () { return Tc(Ci) }, useDebugValue: Nc, useDeferredValue: function (e) { var n = Nt(); return vy(n, He.memoizedState, e) }, useTransition: function () { var e = Tc(Ci)[0], n = Nt().memoizedState; return [e, n] }, useMutableSource: ty, useSyncExternalStore: ny, useId: yy, unstable_isNewReconciler: !1 }, mT = { readContext: At, useCallback: my, useContext: At, useEffect: Ac, useImperativeHandle: hy, useInsertionEffect: dy, useLayoutEffect: fy, useMemo: gy, useReducer: Rc, useRef: uy, useState: function () { return Rc(Ci) }, useDebugValue: Nc, useDeferredValue: function (e) { var n = Nt(); return He === null ? n.memoizedState = e : vy(n, He.memoizedState, e) }, useTransition: function () { var e = Rc(Ci)[0], n = Nt().memoizedState; return [e, n] }, useMutableSource: ty, useSyncExternalStore: ny, useId: yy, unstable_isNewReconciler: !1 }; function Ft(e, n) { if (e && e.defaultProps) { n = X({}, n), e = e.defaultProps; for (var i in e) n[i] === void 0 && (n[i] = e[i]); return n } return n } function Mc(e, n, i, a) { n = e.memoizedState, i = i(a, n), i = i == null ? n : X({}, n, i), e.memoizedState = i, e.lanes === 0 && (e.updateQueue.baseState = i) } var aa = { isMounted: function (e) { return (e = e._reactInternals) ? cr(e) === e : !1 }, enqueueSetState: function (e, n, i) { e = e._reactInternals; var a = ct(), c = qn(e), p = wn(a, c); p.payload = n, i != null && (p.callback = i), n = Gn(e, p, c), n !== null && (Ut(n, e, c, a), Js(n, e, c)) }, enqueueReplaceState: function (e, n, i) { e = e._reactInternals; var a = ct(), c = qn(e), p = wn(a, c); p.tag = 1, p.payload = n, i != null && (p.callback = i), n = Gn(e, p, c), n !== null && (Ut(n, e, c, a), Js(n, e, c)) }, enqueueForceUpdate: function (e, n) { e = e._reactInternals; var i = ct(), a = qn(e), c = wn(i, a); c.tag = 2, n != null && (c.callback = n), n = Gn(e, c, a), n !== null && (Ut(n, e, a, i), Js(n, e, a)) } }; function Cy(e, n, i, a, c, p, y) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(a, p, y) : n.prototype && n.prototype.isPureReactComponent ? !ui(i, a) || !ui(c, p) : !0 } function by(e, n, i) { var a = !1, c = $n, p = n.contextType; return typeof p == "object" && p !== null ? p = At(p) : (c = pt(n) ? fr : it.current, a = n.contextTypes, p = (a = a != null) ? io(e, c) : $n), n = new n(i, p), e.memoizedState = n.state !== null && n.state !== void 0 ? n.state : null, n.updater = aa, e.stateNode = n, n._reactInternals = e, a && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = c, e.__reactInternalMemoizedMaskedChildContext = p), n } function ky(e, n, i, a) { e = n.state, typeof n.componentWillReceiveProps == "function" && n.componentWillReceiveProps(i, a), typeof n.UNSAFE_componentWillReceiveProps == "function" && n.UNSAFE_componentWillReceiveProps(i, a), n.state !== e && aa.enqueueReplaceState(n, n.state, null) } function Lc(e, n, i, a) { var c = e.stateNode; c.props = i, c.state = e.memoizedState, c.refs = {}, yc(e); var p = n.contextType; typeof p == "object" && p !== null ? c.context = At(p) : (p = pt(n) ? fr : it.current, c.context = io(e, p)), c.state = e.memoizedState, p = n.getDerivedStateFromProps, typeof p == "function" && (Mc(e, n, p, i), c.state = e.memoizedState), typeof n.getDerivedStateFromProps == "function" || typeof c.getSnapshotBeforeUpdate == "function" || typeof c.UNSAFE_componentWillMount != "function" && typeof c.componentWillMount != "function" || (n = c.state, typeof c.componentWillMount == "function" && c.componentWillMount(), typeof c.UNSAFE_componentWillMount == "function" && c.UNSAFE_componentWillMount(), n !== c.state && aa.enqueueReplaceState(c, c.state, null), ea(e, i, c, a), c.state = e.memoizedState), typeof c.componentDidMount == "function" && (e.flags |= 4194308) } function ho(e, n) {
      try { var i = "", a = n; do i += Se(a), a = a.return; while (a); var c = i } catch (p) {
        c = `
Error generating stack: `+ p.message + `
`+ p.stack
      } return { value: e, source: n, stack: c, digest: null }
    } function Dc(e, n, i) { return { value: e, source: null, stack: i ?? null, digest: n ?? null } } function jc(e, n) { try { console.error(n.value) } catch (i) { setTimeout(function () { throw i }) } } var gT = typeof WeakMap == "function" ? WeakMap : Map; function Py(e, n, i) { i = wn(-1, i), i.tag = 3, i.payload = { element: null }; var a = n.value; return i.callback = function () { ha || (ha = !0, Xc = a), jc(e, n) }, i } function Ey(e, n, i) { i = wn(-1, i), i.tag = 3; var a = e.type.getDerivedStateFromError; if (typeof a == "function") { var c = n.value; i.payload = function () { return a(c) }, i.callback = function () { jc(e, n) } } var p = e.stateNode; return p !== null && typeof p.componentDidCatch == "function" && (i.callback = function () { jc(e, n), typeof a != "function" && (Xn === null ? Xn = new Set([this]) : Xn.add(this)); var y = n.stack; this.componentDidCatch(n.value, { componentStack: y !== null ? y : "" }) }), i } function Ty(e, n, i) { var a = e.pingCache; if (a === null) { a = e.pingCache = new gT; var c = new Set; a.set(n, c) } else c = a.get(n), c === void 0 && (c = new Set, a.set(n, c)); c.has(i) || (c.add(i), e = NT.bind(null, e, n, i), n.then(e, e)) } function Ry(e) { do { var n; if ((n = e.tag === 13) && (n = e.memoizedState, n = n !== null ? n.dehydrated !== null : !0), n) return e; e = e.return } while (e !== null); return null } function Ay(e, n, i, a, c) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = c, e) : (e === n ? e.flags |= 65536 : (e.flags |= 128, i.flags |= 131072, i.flags &= -52805, i.tag === 1 && (i.alternate === null ? i.tag = 17 : (n = wn(-1, 1), n.tag = 2, Gn(i, n, 1))), i.lanes |= 1), e) } var vT = j.ReactCurrentOwner, ht = !1; function ut(e, n, i, a) { n.child = e === null ? Xv(n, null, i, a) : uo(n, e.child, i, a) } function Ny(e, n, i, a, c) { i = i.render; var p = n.ref; return fo(n, c), a = Pc(e, n, i, a, p, c), i = Ec(), e !== null && !ht ? (n.updateQueue = e.updateQueue, n.flags &= -2053, e.lanes &= ~c, xn(e, n, c)) : (De && i && lc(n), n.flags |= 1, ut(e, n, a, c), n.child) } function My(e, n, i, a, c) { if (e === null) { var p = i.type; return typeof p == "function" && !nd(p) && p.defaultProps === void 0 && i.compare === null && i.defaultProps === void 0 ? (n.tag = 15, n.type = p, Ly(e, n, p, a, c)) : (e = xa(i.type, null, a, n, n.mode, c), e.ref = n.ref, e.return = n, n.child = e) } if (p = e.child, !(e.lanes & c)) { var y = p.memoizedProps; if (i = i.compare, i = i !== null ? i : ui, i(y, a) && e.ref === n.ref) return xn(e, n, c) } return n.flags |= 1, e = Jn(p, a), e.ref = n.ref, e.return = n, n.child = e } function Ly(e, n, i, a, c) { if (e !== null) { var p = e.memoizedProps; if (ui(p, a) && e.ref === n.ref) if (ht = !1, n.pendingProps = a = p, (e.lanes & c) !== 0) e.flags & 131072 && (ht = !0); else return n.lanes = e.lanes, xn(e, n, c) } return Oc(e, n, i, a, c) } function Dy(e, n, i) { var a = n.pendingProps, c = a.children, p = e !== null ? e.memoizedState : null; if (a.mode === "hidden") if (!(n.mode & 1)) n.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ae(go, bt), bt |= i; else { if (!(i & 1073741824)) return e = p !== null ? p.baseLanes | i : i, n.lanes = n.childLanes = 1073741824, n.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, n.updateQueue = null, Ae(go, bt), bt |= e, null; n.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, a = p !== null ? p.baseLanes : i, Ae(go, bt), bt |= a } else p !== null ? (a = p.baseLanes | i, n.memoizedState = null) : a = i, Ae(go, bt), bt |= a; return ut(e, n, c, i), n.child } function jy(e, n) { var i = n.ref; (e === null && i !== null || e !== null && e.ref !== i) && (n.flags |= 512, n.flags |= 2097152) } function Oc(e, n, i, a, c) { var p = pt(i) ? fr : it.current; return p = io(n, p), fo(n, c), i = Pc(e, n, i, a, p, c), a = Ec(), e !== null && !ht ? (n.updateQueue = e.updateQueue, n.flags &= -2053, e.lanes &= ~c, xn(e, n, c)) : (De && a && lc(n), n.flags |= 1, ut(e, n, i, c), n.child) } function Oy(e, n, i, a, c) { if (pt(i)) { var p = !0; Hs(n) } else p = !1; if (fo(n, c), n.stateNode === null) ua(e, n), by(n, i, a), Lc(n, i, a, c), a = !0; else if (e === null) { var y = n.stateNode, k = n.memoizedProps; y.props = k; var A = y.context, _ = i.contextType; typeof _ == "object" && _ !== null ? _ = At(_) : (_ = pt(i) ? fr : it.current, _ = io(n, _)); var B = i.getDerivedStateFromProps, U = typeof B == "function" || typeof y.getSnapshotBeforeUpdate == "function"; U || typeof y.UNSAFE_componentWillReceiveProps != "function" && typeof y.componentWillReceiveProps != "function" || (k !== a || A !== _) && ky(n, y, a, _), Kn = !1; var z = n.memoizedState; y.state = z, ea(n, a, y, c), A = n.memoizedState, k !== a || z !== A || ft.current || Kn ? (typeof B == "function" && (Mc(n, i, B, a), A = n.memoizedState), (k = Kn || Cy(n, i, k, a, z, A, _)) ? (U || typeof y.UNSAFE_componentWillMount != "function" && typeof y.componentWillMount != "function" || (typeof y.componentWillMount == "function" && y.componentWillMount(), typeof y.UNSAFE_componentWillMount == "function" && y.UNSAFE_componentWillMount()), typeof y.componentDidMount == "function" && (n.flags |= 4194308)) : (typeof y.componentDidMount == "function" && (n.flags |= 4194308), n.memoizedProps = a, n.memoizedState = A), y.props = a, y.state = A, y.context = _, a = k) : (typeof y.componentDidMount == "function" && (n.flags |= 4194308), a = !1) } else { y = n.stateNode, qv(e, n), k = n.memoizedProps, _ = n.type === n.elementType ? k : Ft(n.type, k), y.props = _, U = n.pendingProps, z = y.context, A = i.contextType, typeof A == "object" && A !== null ? A = At(A) : (A = pt(i) ? fr : it.current, A = io(n, A)); var q = i.getDerivedStateFromProps; (B = typeof q == "function" || typeof y.getSnapshotBeforeUpdate == "function") || typeof y.UNSAFE_componentWillReceiveProps != "function" && typeof y.componentWillReceiveProps != "function" || (k !== U || z !== A) && ky(n, y, a, A), Kn = !1, z = n.memoizedState, y.state = z, ea(n, a, y, c); var te = n.memoizedState; k !== U || z !== te || ft.current || Kn ? (typeof q == "function" && (Mc(n, i, q, a), te = n.memoizedState), (_ = Kn || Cy(n, i, _, a, z, te, A) || !1) ? (B || typeof y.UNSAFE_componentWillUpdate != "function" && typeof y.componentWillUpdate != "function" || (typeof y.componentWillUpdate == "function" && y.componentWillUpdate(a, te, A), typeof y.UNSAFE_componentWillUpdate == "function" && y.UNSAFE_componentWillUpdate(a, te, A)), typeof y.componentDidUpdate == "function" && (n.flags |= 4), typeof y.getSnapshotBeforeUpdate == "function" && (n.flags |= 1024)) : (typeof y.componentDidUpdate != "function" || k === e.memoizedProps && z === e.memoizedState || (n.flags |= 4), typeof y.getSnapshotBeforeUpdate != "function" || k === e.memoizedProps && z === e.memoizedState || (n.flags |= 1024), n.memoizedProps = a, n.memoizedState = te), y.props = a, y.state = te, y.context = A, a = _) : (typeof y.componentDidUpdate != "function" || k === e.memoizedProps && z === e.memoizedState || (n.flags |= 4), typeof y.getSnapshotBeforeUpdate != "function" || k === e.memoizedProps && z === e.memoizedState || (n.flags |= 1024), a = !1) } return _c(e, n, i, a, p, c) } function _c(e, n, i, a, c, p) { jy(e, n); var y = (n.flags & 128) !== 0; if (!a && !y) return c && zv(n, i, !1), xn(e, n, p); a = n.stateNode, vT.current = n; var k = y && typeof i.getDerivedStateFromError != "function" ? null : a.render(); return n.flags |= 1, e !== null && y ? (n.child = uo(n, e.child, null, p), n.child = uo(n, null, k, p)) : ut(e, n, k, p), n.memoizedState = a.state, c && zv(n, i, !0), n.child } function _y(e) { var n = e.stateNode; n.pendingContext ? Vv(e, n.pendingContext, n.pendingContext !== n.context) : n.context && Vv(e, n.context, !1), wc(e, n.containerInfo) } function Iy(e, n, i, a, c) { return lo(), fc(c), n.flags |= 256, ut(e, n, i, a), n.child } var Ic = { dehydrated: null, treeContext: null, retryLane: 0 }; function Vc(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Vy(e, n, i) { var a = n.pendingProps, c = _e.current, p = !1, y = (n.flags & 128) !== 0, k; if ((k = y) || (k = e !== null && e.memoizedState === null ? !1 : (c & 2) !== 0), k ? (p = !0, n.flags &= -129) : (e === null || e.memoizedState !== null) && (c |= 1), Ae(_e, c & 1), e === null) return dc(n), e = n.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (n.mode & 1 ? e.data === "$!" ? n.lanes = 8 : n.lanes = 1073741824 : n.lanes = 1, null) : (y = a.children, e = a.fallback, p ? (a = n.mode, p = n.child, y = { mode: "hidden", children: y }, !(a & 1) && p !== null ? (p.childLanes = 0, p.pendingProps = y) : p = Sa(y, a, 0, null), e = Cr(e, a, i, null), p.return = n, e.return = n, p.sibling = e, n.child = p, n.child.memoizedState = Vc(i), n.memoizedState = Ic, e) : Fc(n, y)); if (c = e.memoizedState, c !== null && (k = c.dehydrated, k !== null)) return yT(e, n, y, a, k, c, i); if (p) { p = a.fallback, y = n.mode, c = e.child, k = c.sibling; var A = { mode: "hidden", children: a.children }; return !(y & 1) && n.child !== c ? (a = n.child, a.childLanes = 0, a.pendingProps = A, n.deletions = null) : (a = Jn(c, A), a.subtreeFlags = c.subtreeFlags & 14680064), k !== null ? p = Jn(k, p) : (p = Cr(p, y, i, null), p.flags |= 2), p.return = n, a.return = n, a.sibling = p, n.child = a, a = p, p = n.child, y = e.child.memoizedState, y = y === null ? Vc(i) : { baseLanes: y.baseLanes | i, cachePool: null, transitions: y.transitions }, p.memoizedState = y, p.childLanes = e.childLanes & ~i, n.memoizedState = Ic, a } return p = e.child, e = p.sibling, a = Jn(p, { mode: "visible", children: a.children }), !(n.mode & 1) && (a.lanes = i), a.return = n, a.sibling = null, e !== null && (i = n.deletions, i === null ? (n.deletions = [e], n.flags |= 16) : i.push(e)), n.child = a, n.memoizedState = null, a } function Fc(e, n) { return n = Sa({ mode: "visible", children: n }, e.mode, 0, null), n.return = e, e.child = n } function la(e, n, i, a) { return a !== null && fc(a), uo(n, e.child, null, i), e = Fc(n, n.pendingProps.children), e.flags |= 2, n.memoizedState = null, e } function yT(e, n, i, a, c, p, y) { if (i) return n.flags & 256 ? (n.flags &= -257, a = Dc(Error(o(422))), la(e, n, y, a)) : n.memoizedState !== null ? (n.child = e.child, n.flags |= 128, null) : (p = a.fallback, c = n.mode, a = Sa({ mode: "visible", children: a.children }, c, 0, null), p = Cr(p, c, y, null), p.flags |= 2, a.return = n, p.return = n, a.sibling = p, n.child = a, n.mode & 1 && uo(n, e.child, null, y), n.child.memoizedState = Vc(y), n.memoizedState = Ic, p); if (!(n.mode & 1)) return la(e, n, y, null); if (c.data === "$!") { if (a = c.nextSibling && c.nextSibling.dataset, a) var k = a.dgst; return a = k, p = Error(o(419)), a = Dc(p, a, void 0), la(e, n, y, a) } if (k = (y & e.childLanes) !== 0, ht || k) { if (a = Xe, a !== null) { switch (y & -y) { case 4: c = 2; break; case 16: c = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: c = 32; break; case 536870912: c = 268435456; break; default: c = 0 }c = c & (a.suspendedLanes | y) ? 0 : c, c !== 0 && c !== p.retryLane && (p.retryLane = c, yn(e, c), Ut(a, e, c, -1)) } return td(), a = Dc(Error(o(421))), la(e, n, y, a) } return c.data === "$?" ? (n.flags |= 128, n.child = e.child, n = MT.bind(null, e), c._reactRetry = n, null) : (e = p.treeContext, Ct = Un(c.nextSibling), St = n, De = !0, Vt = null, e !== null && (Tt[Rt++] = gn, Tt[Rt++] = vn, Tt[Rt++] = pr, gn = e.id, vn = e.overflow, pr = n), n = Fc(n, a.children), n.flags |= 4096, n) } function Fy(e, n, i) { e.lanes |= n; var a = e.alternate; a !== null && (a.lanes |= n), gc(e.return, n, i) } function zc(e, n, i, a, c) { var p = e.memoizedState; p === null ? e.memoizedState = { isBackwards: n, rendering: null, renderingStartTime: 0, last: a, tail: i, tailMode: c } : (p.isBackwards = n, p.rendering = null, p.renderingStartTime = 0, p.last = a, p.tail = i, p.tailMode = c) } function zy(e, n, i) { var a = n.pendingProps, c = a.revealOrder, p = a.tail; if (ut(e, n, a.children, i), a = _e.current, a & 2) a = a & 1 | 2, n.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = n.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && Fy(e, i, n); else if (e.tag === 19) Fy(e, i, n); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === n) break e; for (; e.sibling === null;) { if (e.return === null || e.return === n) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } a &= 1 } if (Ae(_e, a), !(n.mode & 1)) n.memoizedState = null; else switch (c) { case "forwards": for (i = n.child, c = null; i !== null;)e = i.alternate, e !== null && ta(e) === null && (c = i), i = i.sibling; i = c, i === null ? (c = n.child, n.child = null) : (c = i.sibling, i.sibling = null), zc(n, !1, c, i, p); break; case "backwards": for (i = null, c = n.child, n.child = null; c !== null;) { if (e = c.alternate, e !== null && ta(e) === null) { n.child = c; break } e = c.sibling, c.sibling = i, i = c, c = e } zc(n, !0, i, null, p); break; case "together": zc(n, !1, null, null, void 0); break; default: n.memoizedState = null }return n.child } function ua(e, n) { !(n.mode & 1) && e !== null && (e.alternate = null, n.alternate = null, n.flags |= 2) } function xn(e, n, i) { if (e !== null && (n.dependencies = e.dependencies), yr |= n.lanes, !(i & n.childLanes)) return null; if (e !== null && n.child !== e.child) throw Error(o(153)); if (n.child !== null) { for (e = n.child, i = Jn(e, e.pendingProps), n.child = i, i.return = n; e.sibling !== null;)e = e.sibling, i = i.sibling = Jn(e, e.pendingProps), i.return = n; i.sibling = null } return n.child } function wT(e, n, i) { switch (n.tag) { case 3: _y(n), lo(); break; case 5: ey(n); break; case 1: pt(n.type) && Hs(n); break; case 4: wc(n, n.stateNode.containerInfo); break; case 10: var a = n.type._context, c = n.memoizedProps.value; Ae(qs, a._currentValue), a._currentValue = c; break; case 13: if (a = n.memoizedState, a !== null) return a.dehydrated !== null ? (Ae(_e, _e.current & 1), n.flags |= 128, null) : i & n.child.childLanes ? Vy(e, n, i) : (Ae(_e, _e.current & 1), e = xn(e, n, i), e !== null ? e.sibling : null); Ae(_e, _e.current & 1); break; case 19: if (a = (i & n.childLanes) !== 0, e.flags & 128) { if (a) return zy(e, n, i); n.flags |= 128 } if (c = n.memoizedState, c !== null && (c.rendering = null, c.tail = null, c.lastEffect = null), Ae(_e, _e.current), a) break; return null; case 22: case 23: return n.lanes = 0, Dy(e, n, i) }return xn(e, n, i) } var By, Bc, Uy, Wy; By = function (e, n) { for (var i = n.child; i !== null;) { if (i.tag === 5 || i.tag === 6) e.appendChild(i.stateNode); else if (i.tag !== 4 && i.child !== null) { i.child.return = i, i = i.child; continue } if (i === n) break; for (; i.sibling === null;) { if (i.return === null || i.return === n) return; i = i.return } i.sibling.return = i.return, i = i.sibling } }, Bc = function () { }, Uy = function (e, n, i, a) { var c = e.memoizedProps; if (c !== a) { e = n.stateNode, gr(qt.current); var p = null; switch (i) { case "input": c = Ot(e, c), a = Ot(e, a), p = []; break; case "select": c = X({}, c, { value: void 0 }), a = X({}, a, { value: void 0 }), p = []; break; case "textarea": c = wu(e, c), a = wu(e, a), p = []; break; default: typeof c.onClick != "function" && typeof a.onClick == "function" && (e.onclick = Us) }Su(i, a); var y; i = null; for (_ in c) if (!a.hasOwnProperty(_) && c.hasOwnProperty(_) && c[_] != null) if (_ === "style") { var k = c[_]; for (y in k) k.hasOwnProperty(y) && (i || (i = {}), i[y] = "") } else _ !== "dangerouslySetInnerHTML" && _ !== "children" && _ !== "suppressContentEditableWarning" && _ !== "suppressHydrationWarning" && _ !== "autoFocus" && (l.hasOwnProperty(_) ? p || (p = []) : (p = p || []).push(_, null)); for (_ in a) { var A = a[_]; if (k = c?.[_], a.hasOwnProperty(_) && A !== k && (A != null || k != null)) if (_ === "style") if (k) { for (y in k) !k.hasOwnProperty(y) || A && A.hasOwnProperty(y) || (i || (i = {}), i[y] = ""); for (y in A) A.hasOwnProperty(y) && k[y] !== A[y] && (i || (i = {}), i[y] = A[y]) } else i || (p || (p = []), p.push(_, i)), i = A; else _ === "dangerouslySetInnerHTML" ? (A = A ? A.__html : void 0, k = k ? k.__html : void 0, A != null && k !== A && (p = p || []).push(_, A)) : _ === "children" ? typeof A != "string" && typeof A != "number" || (p = p || []).push(_, "" + A) : _ !== "suppressContentEditableWarning" && _ !== "suppressHydrationWarning" && (l.hasOwnProperty(_) ? (A != null && _ === "onScroll" && Me("scroll", e), p || k === A || (p = [])) : (p = p || []).push(_, A)) } i && (p = p || []).push("style", i); var _ = p; (n.updateQueue = _) && (n.flags |= 4) } }, Wy = function (e, n, i, a) { i !== a && (n.flags |= 4) }; function ki(e, n) { if (!De) switch (e.tailMode) { case "hidden": n = e.tail; for (var i = null; n !== null;)n.alternate !== null && (i = n), n = n.sibling; i === null ? e.tail = null : i.sibling = null; break; case "collapsed": i = e.tail; for (var a = null; i !== null;)i.alternate !== null && (a = i), i = i.sibling; a === null ? n || e.tail === null ? e.tail = null : e.tail.sibling = null : a.sibling = null } } function at(e) { var n = e.alternate !== null && e.alternate.child === e.child, i = 0, a = 0; if (n) for (var c = e.child; c !== null;)i |= c.lanes | c.childLanes, a |= c.subtreeFlags & 14680064, a |= c.flags & 14680064, c.return = e, c = c.sibling; else for (c = e.child; c !== null;)i |= c.lanes | c.childLanes, a |= c.subtreeFlags, a |= c.flags, c.return = e, c = c.sibling; return e.subtreeFlags |= a, e.childLanes = i, n } function xT(e, n, i) { var a = n.pendingProps; switch (uc(n), n.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return at(n), null; case 1: return pt(n.type) && $s(), at(n), null; case 3: return a = n.stateNode, po(), Le(ft), Le(it), Cc(), a.pendingContext && (a.context = a.pendingContext, a.pendingContext = null), (e === null || e.child === null) && (Xs(n) ? n.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(n.flags & 256) || (n.flags |= 1024, Vt !== null && (Zc(Vt), Vt = null))), Bc(e, n), at(n), null; case 5: xc(n); var c = gr(wi.current); if (i = n.type, e !== null && n.stateNode != null) Uy(e, n, i, a, c), e.ref !== n.ref && (n.flags |= 512, n.flags |= 2097152); else { if (!a) { if (n.stateNode === null) throw Error(o(166)); return at(n), null } if (e = gr(qt.current), Xs(n)) { a = n.stateNode, i = n.type; var p = n.memoizedProps; switch (a[Qt] = n, a[hi] = p, e = (n.mode & 1) !== 0, i) { case "dialog": Me("cancel", a), Me("close", a); break; case "iframe": case "object": case "embed": Me("load", a); break; case "video": case "audio": for (c = 0; c < di.length; c++)Me(di[c], a); break; case "source": Me("error", a); break; case "img": case "image": case "link": Me("error", a), Me("load", a); break; case "details": Me("toggle", a); break; case "input": Hr(a, p), Me("invalid", a); break; case "select": a._wrapperState = { wasMultiple: !!p.multiple }, Me("invalid", a); break; case "textarea": Eg(a, p), Me("invalid", a) }Su(i, p), c = null; for (var y in p) if (p.hasOwnProperty(y)) { var k = p[y]; y === "children" ? typeof k == "string" ? a.textContent !== k && (p.suppressHydrationWarning !== !0 && Bs(a.textContent, k, e), c = ["children", k]) : typeof k == "number" && a.textContent !== "" + k && (p.suppressHydrationWarning !== !0 && Bs(a.textContent, k, e), c = ["children", "" + k]) : l.hasOwnProperty(y) && k != null && y === "onScroll" && Me("scroll", a) } switch (i) { case "input": be(a), Pg(a, p, !0); break; case "textarea": be(a), Rg(a); break; case "select": case "option": break; default: typeof p.onClick == "function" && (a.onclick = Us) }a = c, n.updateQueue = a, a !== null && (n.flags |= 4) } else { y = c.nodeType === 9 ? c : c.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = Ag(i)), e === "http://www.w3.org/1999/xhtml" ? i === "script" ? (e = y.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof a.is == "string" ? e = y.createElement(i, { is: a.is }) : (e = y.createElement(i), i === "select" && (y = e, a.multiple ? y.multiple = !0 : a.size && (y.size = a.size))) : e = y.createElementNS(e, i), e[Qt] = n, e[hi] = a, By(e, n, !1, !1), n.stateNode = e; e: { switch (y = Cu(i, a), i) { case "dialog": Me("cancel", e), Me("close", e), c = a; break; case "iframe": case "object": case "embed": Me("load", e), c = a; break; case "video": case "audio": for (c = 0; c < di.length; c++)Me(di[c], e); c = a; break; case "source": Me("error", e), c = a; break; case "img": case "image": case "link": Me("error", e), Me("load", e), c = a; break; case "details": Me("toggle", e), c = a; break; case "input": Hr(e, a), c = Ot(e, a), Me("invalid", e); break; case "option": c = a; break; case "select": e._wrapperState = { wasMultiple: !!a.multiple }, c = X({}, a, { value: void 0 }), Me("invalid", e); break; case "textarea": Eg(e, a), c = wu(e, a), Me("invalid", e); break; default: c = a }Su(i, c), k = c; for (p in k) if (k.hasOwnProperty(p)) { var A = k[p]; p === "style" ? Lg(e, A) : p === "dangerouslySetInnerHTML" ? (A = A ? A.__html : void 0, A != null && Ng(e, A)) : p === "children" ? typeof A == "string" ? (i !== "textarea" || A !== "") && Ko(e, A) : typeof A == "number" && Ko(e, "" + A) : p !== "suppressContentEditableWarning" && p !== "suppressHydrationWarning" && p !== "autoFocus" && (l.hasOwnProperty(p) ? A != null && p === "onScroll" && Me("scroll", e) : A != null && M(e, p, A, y)) } switch (i) { case "input": be(e), Pg(e, a, !1); break; case "textarea": be(e), Rg(e); break; case "option": a.value != null && e.setAttribute("value", "" + ue(a.value)); break; case "select": e.multiple = !!a.multiple, p = a.value, p != null ? Gr(e, !!a.multiple, p, !1) : a.defaultValue != null && Gr(e, !!a.multiple, a.defaultValue, !0); break; default: typeof c.onClick == "function" && (e.onclick = Us) }switch (i) { case "button": case "input": case "select": case "textarea": a = !!a.autoFocus; break e; case "img": a = !0; break e; default: a = !1 } } a && (n.flags |= 4) } n.ref !== null && (n.flags |= 512, n.flags |= 2097152) } return at(n), null; case 6: if (e && n.stateNode != null) Wy(e, n, e.memoizedProps, a); else { if (typeof a != "string" && n.stateNode === null) throw Error(o(166)); if (i = gr(wi.current), gr(qt.current), Xs(n)) { if (a = n.stateNode, i = n.memoizedProps, a[Qt] = n, (p = a.nodeValue !== i) && (e = St, e !== null)) switch (e.tag) { case 3: Bs(a.nodeValue, i, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && Bs(a.nodeValue, i, (e.mode & 1) !== 0) }p && (n.flags |= 4) } else a = (i.nodeType === 9 ? i : i.ownerDocument).createTextNode(a), a[Qt] = n, n.stateNode = a } return at(n), null; case 13: if (Le(_e), a = n.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (De && Ct !== null && n.mode & 1 && !(n.flags & 128)) Kv(), lo(), n.flags |= 98560, p = !1; else if (p = Xs(n), a !== null && a.dehydrated !== null) { if (e === null) { if (!p) throw Error(o(318)); if (p = n.memoizedState, p = p !== null ? p.dehydrated : null, !p) throw Error(o(317)); p[Qt] = n } else lo(), !(n.flags & 128) && (n.memoizedState = null), n.flags |= 4; at(n), p = !1 } else Vt !== null && (Zc(Vt), Vt = null), p = !0; if (!p) return n.flags & 65536 ? n : null } return n.flags & 128 ? (n.lanes = i, n) : (a = a !== null, a !== (e !== null && e.memoizedState !== null) && a && (n.child.flags |= 8192, n.mode & 1 && (e === null || _e.current & 1 ? Ke === 0 && (Ke = 3) : td())), n.updateQueue !== null && (n.flags |= 4), at(n), null); case 4: return po(), Bc(e, n), e === null && fi(n.stateNode.containerInfo), at(n), null; case 10: return mc(n.type._context), at(n), null; case 17: return pt(n.type) && $s(), at(n), null; case 19: if (Le(_e), p = n.memoizedState, p === null) return at(n), null; if (a = (n.flags & 128) !== 0, y = p.rendering, y === null) if (a) ki(p, !1); else { if (Ke !== 0 || e !== null && e.flags & 128) for (e = n.child; e !== null;) { if (y = ta(e), y !== null) { for (n.flags |= 128, ki(p, !1), a = y.updateQueue, a !== null && (n.updateQueue = a, n.flags |= 4), n.subtreeFlags = 0, a = i, i = n.child; i !== null;)p = i, e = a, p.flags &= 14680066, y = p.alternate, y === null ? (p.childLanes = 0, p.lanes = e, p.child = null, p.subtreeFlags = 0, p.memoizedProps = null, p.memoizedState = null, p.updateQueue = null, p.dependencies = null, p.stateNode = null) : (p.childLanes = y.childLanes, p.lanes = y.lanes, p.child = y.child, p.subtreeFlags = 0, p.deletions = null, p.memoizedProps = y.memoizedProps, p.memoizedState = y.memoizedState, p.updateQueue = y.updateQueue, p.type = y.type, e = y.dependencies, p.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), i = i.sibling; return Ae(_e, _e.current & 1 | 2), n.child } e = e.sibling } p.tail !== null && Ue() > vo && (n.flags |= 128, a = !0, ki(p, !1), n.lanes = 4194304) } else { if (!a) if (e = ta(y), e !== null) { if (n.flags |= 128, a = !0, i = e.updateQueue, i !== null && (n.updateQueue = i, n.flags |= 4), ki(p, !0), p.tail === null && p.tailMode === "hidden" && !y.alternate && !De) return at(n), null } else 2 * Ue() - p.renderingStartTime > vo && i !== 1073741824 && (n.flags |= 128, a = !0, ki(p, !1), n.lanes = 4194304); p.isBackwards ? (y.sibling = n.child, n.child = y) : (i = p.last, i !== null ? i.sibling = y : n.child = y, p.last = y) } return p.tail !== null ? (n = p.tail, p.rendering = n, p.tail = n.sibling, p.renderingStartTime = Ue(), n.sibling = null, i = _e.current, Ae(_e, a ? i & 1 | 2 : i & 1), n) : (at(n), null); case 22: case 23: return ed(), a = n.memoizedState !== null, e !== null && e.memoizedState !== null !== a && (n.flags |= 8192), a && n.mode & 1 ? bt & 1073741824 && (at(n), n.subtreeFlags & 6 && (n.flags |= 8192)) : at(n), null; case 24: return null; case 25: return null }throw Error(o(156, n.tag)) } function ST(e, n) { switch (uc(n), n.tag) { case 1: return pt(n.type) && $s(), e = n.flags, e & 65536 ? (n.flags = e & -65537 | 128, n) : null; case 3: return po(), Le(ft), Le(it), Cc(), e = n.flags, e & 65536 && !(e & 128) ? (n.flags = e & -65537 | 128, n) : null; case 5: return xc(n), null; case 13: if (Le(_e), e = n.memoizedState, e !== null && e.dehydrated !== null) { if (n.alternate === null) throw Error(o(340)); lo() } return e = n.flags, e & 65536 ? (n.flags = e & -65537 | 128, n) : null; case 19: return Le(_e), null; case 4: return po(), null; case 10: return mc(n.type._context), null; case 22: case 23: return ed(), null; case 24: return null; default: return null } } var ca = !1, lt = !1, CT = typeof WeakSet == "function" ? WeakSet : Set, ee = null; function mo(e, n) { var i = e.ref; if (i !== null) if (typeof i == "function") try { i(null) } catch (a) { Ve(e, n, a) } else i.current = null } function Uc(e, n, i) { try { i() } catch (a) { Ve(e, n, a) } } var $y = !1; function bT(e, n) { if (ec = Ns, e = Cv(), Ku(e)) { if ("selectionStart" in e) var i = { start: e.selectionStart, end: e.selectionEnd }; else e: { i = (i = e.ownerDocument) && i.defaultView || window; var a = i.getSelection && i.getSelection(); if (a && a.rangeCount !== 0) { i = a.anchorNode; var c = a.anchorOffset, p = a.focusNode; a = a.focusOffset; try { i.nodeType, p.nodeType } catch { i = null; break e } var y = 0, k = -1, A = -1, _ = 0, B = 0, U = e, z = null; t: for (; ;) { for (var q; U !== i || c !== 0 && U.nodeType !== 3 || (k = y + c), U !== p || a !== 0 && U.nodeType !== 3 || (A = y + a), U.nodeType === 3 && (y += U.nodeValue.length), (q = U.firstChild) !== null;)z = U, U = q; for (; ;) { if (U === e) break t; if (z === i && ++_ === c && (k = y), z === p && ++B === a && (A = y), (q = U.nextSibling) !== null) break; U = z, z = U.parentNode } U = q } i = k === -1 || A === -1 ? null : { start: k, end: A } } else i = null } i = i || { start: 0, end: 0 } } else i = null; for (tc = { focusedElem: e, selectionRange: i }, Ns = !1, ee = n; ee !== null;)if (n = ee, e = n.child, (n.subtreeFlags & 1028) !== 0 && e !== null) e.return = n, ee = e; else for (; ee !== null;) { n = ee; try { var te = n.alternate; if (n.flags & 1024) switch (n.tag) { case 0: case 11: case 15: break; case 1: if (te !== null) { var re = te.memoizedProps, We = te.memoizedState, D = n.stateNode, L = D.getSnapshotBeforeUpdate(n.elementType === n.type ? re : Ft(n.type, re), We); D.__reactInternalSnapshotBeforeUpdate = L } break; case 3: var O = n.stateNode.containerInfo; O.nodeType === 1 ? O.textContent = "" : O.nodeType === 9 && O.documentElement && O.removeChild(O.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(o(163)) } } catch (K) { Ve(n, n.return, K) } if (e = n.sibling, e !== null) { e.return = n.return, ee = e; break } ee = n.return } return te = $y, $y = !1, te } function Pi(e, n, i) { var a = n.updateQueue; if (a = a !== null ? a.lastEffect : null, a !== null) { var c = a = a.next; do { if ((c.tag & e) === e) { var p = c.destroy; c.destroy = void 0, p !== void 0 && Uc(n, i, p) } c = c.next } while (c !== a) } } function da(e, n) { if (n = n.updateQueue, n = n !== null ? n.lastEffect : null, n !== null) { var i = n = n.next; do { if ((i.tag & e) === e) { var a = i.create; i.destroy = a() } i = i.next } while (i !== n) } } function Wc(e) { var n = e.ref; if (n !== null) { var i = e.stateNode; switch (e.tag) { case 5: e = i; break; default: e = i }typeof n == "function" ? n(e) : n.current = e } } function Hy(e) { var n = e.alternate; n !== null && (e.alternate = null, Hy(n)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (n = e.stateNode, n !== null && (delete n[Qt], delete n[hi], delete n[ic], delete n[iT], delete n[sT])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function Ky(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function Gy(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || Ky(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function $c(e, n, i) { var a = e.tag; if (a === 5 || a === 6) e = e.stateNode, n ? i.nodeType === 8 ? i.parentNode.insertBefore(e, n) : i.insertBefore(e, n) : (i.nodeType === 8 ? (n = i.parentNode, n.insertBefore(e, i)) : (n = i, n.appendChild(e)), i = i._reactRootContainer, i != null || n.onclick !== null || (n.onclick = Us)); else if (a !== 4 && (e = e.child, e !== null)) for ($c(e, n, i), e = e.sibling; e !== null;)$c(e, n, i), e = e.sibling } function Hc(e, n, i) { var a = e.tag; if (a === 5 || a === 6) e = e.stateNode, n ? i.insertBefore(e, n) : i.appendChild(e); else if (a !== 4 && (e = e.child, e !== null)) for (Hc(e, n, i), e = e.sibling; e !== null;)Hc(e, n, i), e = e.sibling } var tt = null, zt = !1; function Yn(e, n, i) { for (i = i.child; i !== null;)Yy(e, n, i), i = i.sibling } function Yy(e, n, i) { if (Xt && typeof Xt.onCommitFiberUnmount == "function") try { Xt.onCommitFiberUnmount(ks, i) } catch { } switch (i.tag) { case 5: lt || mo(i, n); case 6: var a = tt, c = zt; tt = null, Yn(e, n, i), tt = a, zt = c, tt !== null && (zt ? (e = tt, i = i.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(i) : e.removeChild(i)) : tt.removeChild(i.stateNode)); break; case 18: tt !== null && (zt ? (e = tt, i = i.stateNode, e.nodeType === 8 ? oc(e.parentNode, i) : e.nodeType === 1 && oc(e, i), ri(e)) : oc(tt, i.stateNode)); break; case 4: a = tt, c = zt, tt = i.stateNode.containerInfo, zt = !0, Yn(e, n, i), tt = a, zt = c; break; case 0: case 11: case 14: case 15: if (!lt && (a = i.updateQueue, a !== null && (a = a.lastEffect, a !== null))) { c = a = a.next; do { var p = c, y = p.destroy; p = p.tag, y !== void 0 && (p & 2 || p & 4) && Uc(i, n, y), c = c.next } while (c !== a) } Yn(e, n, i); break; case 1: if (!lt && (mo(i, n), a = i.stateNode, typeof a.componentWillUnmount == "function")) try { a.props = i.memoizedProps, a.state = i.memoizedState, a.componentWillUnmount() } catch (k) { Ve(i, n, k) } Yn(e, n, i); break; case 21: Yn(e, n, i); break; case 22: i.mode & 1 ? (lt = (a = lt) || i.memoizedState !== null, Yn(e, n, i), lt = a) : Yn(e, n, i); break; default: Yn(e, n, i) } } function Xy(e) { var n = e.updateQueue; if (n !== null) { e.updateQueue = null; var i = e.stateNode; i === null && (i = e.stateNode = new CT), n.forEach(function (a) { var c = LT.bind(null, e, a); i.has(a) || (i.add(a), a.then(c, c)) }) } } function Bt(e, n) { var i = n.deletions; if (i !== null) for (var a = 0; a < i.length; a++) { var c = i[a]; try { var p = e, y = n, k = y; e: for (; k !== null;) { switch (k.tag) { case 5: tt = k.stateNode, zt = !1; break e; case 3: tt = k.stateNode.containerInfo, zt = !0; break e; case 4: tt = k.stateNode.containerInfo, zt = !0; break e }k = k.return } if (tt === null) throw Error(o(160)); Yy(p, y, c), tt = null, zt = !1; var A = c.alternate; A !== null && (A.return = null), c.return = null } catch (_) { Ve(c, n, _) } } if (n.subtreeFlags & 12854) for (n = n.child; n !== null;)Qy(n, e), n = n.sibling } function Qy(e, n) { var i = e.alternate, a = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (Bt(n, e), Jt(e), a & 4) { try { Pi(3, e, e.return), da(3, e) } catch (re) { Ve(e, e.return, re) } try { Pi(5, e, e.return) } catch (re) { Ve(e, e.return, re) } } break; case 1: Bt(n, e), Jt(e), a & 512 && i !== null && mo(i, i.return); break; case 5: if (Bt(n, e), Jt(e), a & 512 && i !== null && mo(i, i.return), e.flags & 32) { var c = e.stateNode; try { Ko(c, "") } catch (re) { Ve(e, e.return, re) } } if (a & 4 && (c = e.stateNode, c != null)) { var p = e.memoizedProps, y = i !== null ? i.memoizedProps : p, k = e.type, A = e.updateQueue; if (e.updateQueue = null, A !== null) try { k === "input" && p.type === "radio" && p.name != null && Kr(c, p), Cu(k, y); var _ = Cu(k, p); for (y = 0; y < A.length; y += 2) { var B = A[y], U = A[y + 1]; B === "style" ? Lg(c, U) : B === "dangerouslySetInnerHTML" ? Ng(c, U) : B === "children" ? Ko(c, U) : M(c, B, U, _) } switch (k) { case "input": ur(c, p); break; case "textarea": Tg(c, p); break; case "select": var z = c._wrapperState.wasMultiple; c._wrapperState.wasMultiple = !!p.multiple; var q = p.value; q != null ? Gr(c, !!p.multiple, q, !1) : z !== !!p.multiple && (p.defaultValue != null ? Gr(c, !!p.multiple, p.defaultValue, !0) : Gr(c, !!p.multiple, p.multiple ? [] : "", !1)) }c[hi] = p } catch (re) { Ve(e, e.return, re) } } break; case 6: if (Bt(n, e), Jt(e), a & 4) { if (e.stateNode === null) throw Error(o(162)); c = e.stateNode, p = e.memoizedProps; try { c.nodeValue = p } catch (re) { Ve(e, e.return, re) } } break; case 3: if (Bt(n, e), Jt(e), a & 4 && i !== null && i.memoizedState.isDehydrated) try { ri(n.containerInfo) } catch (re) { Ve(e, e.return, re) } break; case 4: Bt(n, e), Jt(e); break; case 13: Bt(n, e), Jt(e), c = e.child, c.flags & 8192 && (p = c.memoizedState !== null, c.stateNode.isHidden = p, !p || c.alternate !== null && c.alternate.memoizedState !== null || (Yc = Ue())), a & 4 && Xy(e); break; case 22: if (B = i !== null && i.memoizedState !== null, e.mode & 1 ? (lt = (_ = lt) || B, Bt(n, e), lt = _) : Bt(n, e), Jt(e), a & 8192) { if (_ = e.memoizedState !== null, (e.stateNode.isHidden = _) && !B && e.mode & 1) for (ee = e, B = e.child; B !== null;) { for (U = ee = B; ee !== null;) { switch (z = ee, q = z.child, z.tag) { case 0: case 11: case 14: case 15: Pi(4, z, z.return); break; case 1: mo(z, z.return); var te = z.stateNode; if (typeof te.componentWillUnmount == "function") { a = z, i = z.return; try { n = a, te.props = n.memoizedProps, te.state = n.memoizedState, te.componentWillUnmount() } catch (re) { Ve(a, i, re) } } break; case 5: mo(z, z.return); break; case 22: if (z.memoizedState !== null) { Jy(U); continue } }q !== null ? (q.return = z, ee = q) : Jy(U) } B = B.sibling } e: for (B = null, U = e; ;) { if (U.tag === 5) { if (B === null) { B = U; try { c = U.stateNode, _ ? (p = c.style, typeof p.setProperty == "function" ? p.setProperty("display", "none", "important") : p.display = "none") : (k = U.stateNode, A = U.memoizedProps.style, y = A != null && A.hasOwnProperty("display") ? A.display : null, k.style.display = Mg("display", y)) } catch (re) { Ve(e, e.return, re) } } } else if (U.tag === 6) { if (B === null) try { U.stateNode.nodeValue = _ ? "" : U.memoizedProps } catch (re) { Ve(e, e.return, re) } } else if ((U.tag !== 22 && U.tag !== 23 || U.memoizedState === null || U === e) && U.child !== null) { U.child.return = U, U = U.child; continue } if (U === e) break e; for (; U.sibling === null;) { if (U.return === null || U.return === e) break e; B === U && (B = null), U = U.return } B === U && (B = null), U.sibling.return = U.return, U = U.sibling } } break; case 19: Bt(n, e), Jt(e), a & 4 && Xy(e); break; case 21: break; default: Bt(n, e), Jt(e) } } function Jt(e) { var n = e.flags; if (n & 2) { try { e: { for (var i = e.return; i !== null;) { if (Ky(i)) { var a = i; break e } i = i.return } throw Error(o(160)) } switch (a.tag) { case 5: var c = a.stateNode; a.flags & 32 && (Ko(c, ""), a.flags &= -33); var p = Gy(e); Hc(e, p, c); break; case 3: case 4: var y = a.stateNode.containerInfo, k = Gy(e); $c(e, k, y); break; default: throw Error(o(161)) } } catch (A) { Ve(e, e.return, A) } e.flags &= -3 } n & 4096 && (e.flags &= -4097) } function kT(e, n, i) { ee = e, qy(e) } function qy(e, n, i) { for (var a = (e.mode & 1) !== 0; ee !== null;) { var c = ee, p = c.child; if (c.tag === 22 && a) { var y = c.memoizedState !== null || ca; if (!y) { var k = c.alternate, A = k !== null && k.memoizedState !== null || lt; k = ca; var _ = lt; if (ca = y, (lt = A) && !_) for (ee = c; ee !== null;)y = ee, A = y.child, y.tag === 22 && y.memoizedState !== null ? e0(c) : A !== null ? (A.return = y, ee = A) : e0(c); for (; p !== null;)ee = p, qy(p), p = p.sibling; ee = c, ca = k, lt = _ } Zy(e) } else c.subtreeFlags & 8772 && p !== null ? (p.return = c, ee = p) : Zy(e) } } function Zy(e) { for (; ee !== null;) { var n = ee; if (n.flags & 8772) { var i = n.alternate; try { if (n.flags & 8772) switch (n.tag) { case 0: case 11: case 15: lt || da(5, n); break; case 1: var a = n.stateNode; if (n.flags & 4 && !lt) if (i === null) a.componentDidMount(); else { var c = n.elementType === n.type ? i.memoizedProps : Ft(n.type, i.memoizedProps); a.componentDidUpdate(c, i.memoizedState, a.__reactInternalSnapshotBeforeUpdate) } var p = n.updateQueue; p !== null && Jv(n, p, a); break; case 3: var y = n.updateQueue; if (y !== null) { if (i = null, n.child !== null) switch (n.child.tag) { case 5: i = n.child.stateNode; break; case 1: i = n.child.stateNode }Jv(n, y, i) } break; case 5: var k = n.stateNode; if (i === null && n.flags & 4) { i = k; var A = n.memoizedProps; switch (n.type) { case "button": case "input": case "select": case "textarea": A.autoFocus && i.focus(); break; case "img": A.src && (i.src = A.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (n.memoizedState === null) { var _ = n.alternate; if (_ !== null) { var B = _.memoizedState; if (B !== null) { var U = B.dehydrated; U !== null && ri(U) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(o(163)) }lt || n.flags & 512 && Wc(n) } catch (z) { Ve(n, n.return, z) } } if (n === e) { ee = null; break } if (i = n.sibling, i !== null) { i.return = n.return, ee = i; break } ee = n.return } } function Jy(e) { for (; ee !== null;) { var n = ee; if (n === e) { ee = null; break } var i = n.sibling; if (i !== null) { i.return = n.return, ee = i; break } ee = n.return } } function e0(e) { for (; ee !== null;) { var n = ee; try { switch (n.tag) { case 0: case 11: case 15: var i = n.return; try { da(4, n) } catch (A) { Ve(n, i, A) } break; case 1: var a = n.stateNode; if (typeof a.componentDidMount == "function") { var c = n.return; try { a.componentDidMount() } catch (A) { Ve(n, c, A) } } var p = n.return; try { Wc(n) } catch (A) { Ve(n, p, A) } break; case 5: var y = n.return; try { Wc(n) } catch (A) { Ve(n, y, A) } } } catch (A) { Ve(n, n.return, A) } if (n === e) { ee = null; break } var k = n.sibling; if (k !== null) { k.return = n.return, ee = k; break } ee = n.return } } var PT = Math.ceil, fa = j.ReactCurrentDispatcher, Kc = j.ReactCurrentOwner, Mt = j.ReactCurrentBatchConfig, ke = 0, Xe = null, $e = null, nt = 0, bt = 0, go = Wn(0), Ke = 0, Ei = null, yr = 0, pa = 0, Gc = 0, Ti = null, mt = null, Yc = 0, vo = 1 / 0, Sn = null, ha = !1, Xc = null, Xn = null, ma = !1, Qn = null, ga = 0, Ri = 0, Qc = null, va = -1, ya = 0; function ct() { return ke & 6 ? Ue() : va !== -1 ? va : va = Ue() } function qn(e) { return e.mode & 1 ? ke & 2 && nt !== 0 ? nt & -nt : lT.transition !== null ? (ya === 0 && (ya = Gg()), ya) : (e = Ee, e !== 0 || (e = window.event, e = e === void 0 ? 16 : nv(e.type)), e) : 1 } function Ut(e, n, i, a) { if (50 < Ri) throw Ri = 0, Qc = null, Error(o(185)); Zo(e, i, a), (!(ke & 2) || e !== Xe) && (e === Xe && (!(ke & 2) && (pa |= i), Ke === 4 && Zn(e, nt)), gt(e, a), i === 1 && ke === 0 && !(n.mode & 1) && (vo = Ue() + 500, Ks && Hn())) } function gt(e, n) { var i = e.callbackNode; lE(e, n); var a = Ts(e, e === Xe ? nt : 0); if (a === 0) i !== null && $g(i), e.callbackNode = null, e.callbackPriority = 0; else if (n = a & -a, e.callbackPriority !== n) { if (i != null && $g(i), n === 1) e.tag === 0 ? aT(n0.bind(null, e)) : Bv(n0.bind(null, e)), rT(function () { !(ke & 6) && Hn() }), i = null; else { switch (Yg(a)) { case 1: i = Au; break; case 4: i = Hg; break; case 16: i = bs; break; case 536870912: i = Kg; break; default: i = bs }i = c0(i, t0.bind(null, e)) } e.callbackPriority = n, e.callbackNode = i } } function t0(e, n) { if (va = -1, ya = 0, ke & 6) throw Error(o(327)); var i = e.callbackNode; if (yo() && e.callbackNode !== i) return null; var a = Ts(e, e === Xe ? nt : 0); if (a === 0) return null; if (a & 30 || a & e.expiredLanes || n) n = wa(e, a); else { n = a; var c = ke; ke |= 2; var p = o0(); (Xe !== e || nt !== n) && (Sn = null, vo = Ue() + 500, xr(e, n)); do try { RT(); break } catch (k) { r0(e, k) } while (1); hc(), fa.current = p, ke = c, $e !== null ? n = 0 : (Xe = null, nt = 0, n = Ke) } if (n !== 0) { if (n === 2 && (c = Nu(e), c !== 0 && (a = c, n = qc(e, c))), n === 1) throw i = Ei, xr(e, 0), Zn(e, a), gt(e, Ue()), i; if (n === 6) Zn(e, a); else { if (c = e.current.alternate, !(a & 30) && !ET(c) && (n = wa(e, a), n === 2 && (p = Nu(e), p !== 0 && (a = p, n = qc(e, p))), n === 1)) throw i = Ei, xr(e, 0), Zn(e, a), gt(e, Ue()), i; switch (e.finishedWork = c, e.finishedLanes = a, n) { case 0: case 1: throw Error(o(345)); case 2: Sr(e, mt, Sn); break; case 3: if (Zn(e, a), (a & 130023424) === a && (n = Yc + 500 - Ue(), 10 < n)) { if (Ts(e, 0) !== 0) break; if (c = e.suspendedLanes, (c & a) !== a) { ct(), e.pingedLanes |= e.suspendedLanes & c; break } e.timeoutHandle = rc(Sr.bind(null, e, mt, Sn), n); break } Sr(e, mt, Sn); break; case 4: if (Zn(e, a), (a & 4194240) === a) break; for (n = e.eventTimes, c = -1; 0 < a;) { var y = 31 - _t(a); p = 1 << y, y = n[y], y > c && (c = y), a &= ~p } if (a = c, a = Ue() - a, a = (120 > a ? 120 : 480 > a ? 480 : 1080 > a ? 1080 : 1920 > a ? 1920 : 3e3 > a ? 3e3 : 4320 > a ? 4320 : 1960 * PT(a / 1960)) - a, 10 < a) { e.timeoutHandle = rc(Sr.bind(null, e, mt, Sn), a); break } Sr(e, mt, Sn); break; case 5: Sr(e, mt, Sn); break; default: throw Error(o(329)) } } } return gt(e, Ue()), e.callbackNode === i ? t0.bind(null, e) : null } function qc(e, n) { var i = Ti; return e.current.memoizedState.isDehydrated && (xr(e, n).flags |= 256), e = wa(e, n), e !== 2 && (n = mt, mt = i, n !== null && Zc(n)), e } function Zc(e) { mt === null ? mt = e : mt.push.apply(mt, e) } function ET(e) { for (var n = e; ;) { if (n.flags & 16384) { var i = n.updateQueue; if (i !== null && (i = i.stores, i !== null)) for (var a = 0; a < i.length; a++) { var c = i[a], p = c.getSnapshot; c = c.value; try { if (!It(p(), c)) return !1 } catch { return !1 } } } if (i = n.child, n.subtreeFlags & 16384 && i !== null) i.return = n, n = i; else { if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return !0; n = n.return } n.sibling.return = n.return, n = n.sibling } } return !0 } function Zn(e, n) { for (n &= ~Gc, n &= ~pa, e.suspendedLanes |= n, e.pingedLanes &= ~n, e = e.expirationTimes; 0 < n;) { var i = 31 - _t(n), a = 1 << i; e[i] = -1, n &= ~a } } function n0(e) { if (ke & 6) throw Error(o(327)); yo(); var n = Ts(e, 0); if (!(n & 1)) return gt(e, Ue()), null; var i = wa(e, n); if (e.tag !== 0 && i === 2) { var a = Nu(e); a !== 0 && (n = a, i = qc(e, a)) } if (i === 1) throw i = Ei, xr(e, 0), Zn(e, n), gt(e, Ue()), i; if (i === 6) throw Error(o(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = n, Sr(e, mt, Sn), gt(e, Ue()), null } function Jc(e, n) { var i = ke; ke |= 1; try { return e(n) } finally { ke = i, ke === 0 && (vo = Ue() + 500, Ks && Hn()) } } function wr(e) { Qn !== null && Qn.tag === 0 && !(ke & 6) && yo(); var n = ke; ke |= 1; var i = Mt.transition, a = Ee; try { if (Mt.transition = null, Ee = 1, e) return e() } finally { Ee = a, Mt.transition = i, ke = n, !(ke & 6) && Hn() } } function ed() { bt = go.current, Le(go) } function xr(e, n) { e.finishedWork = null, e.finishedLanes = 0; var i = e.timeoutHandle; if (i !== -1 && (e.timeoutHandle = -1, nT(i)), $e !== null) for (i = $e.return; i !== null;) { var a = i; switch (uc(a), a.tag) { case 1: a = a.type.childContextTypes, a != null && $s(); break; case 3: po(), Le(ft), Le(it), Cc(); break; case 5: xc(a); break; case 4: po(); break; case 13: Le(_e); break; case 19: Le(_e); break; case 10: mc(a.type._context); break; case 22: case 23: ed() }i = i.return } if (Xe = e, $e = e = Jn(e.current, null), nt = bt = n, Ke = 0, Ei = null, Gc = pa = yr = 0, mt = Ti = null, mr !== null) { for (n = 0; n < mr.length; n++)if (i = mr[n], a = i.interleaved, a !== null) { i.interleaved = null; var c = a.next, p = i.pending; if (p !== null) { var y = p.next; p.next = c, a.next = y } i.pending = a } mr = null } return e } function r0(e, n) { do { var i = $e; try { if (hc(), na.current = sa, ra) { for (var a = Ie.memoizedState; a !== null;) { var c = a.queue; c !== null && (c.pending = null), a = a.next } ra = !1 } if (vr = 0, Ye = He = Ie = null, xi = !1, Si = 0, Kc.current = null, i === null || i.return === null) { Ke = 1, Ei = n, $e = null; break } e: { var p = e, y = i.return, k = i, A = n; if (n = nt, k.flags |= 32768, A !== null && typeof A == "object" && typeof A.then == "function") { var _ = A, B = k, U = B.tag; if (!(B.mode & 1) && (U === 0 || U === 11 || U === 15)) { var z = B.alternate; z ? (B.updateQueue = z.updateQueue, B.memoizedState = z.memoizedState, B.lanes = z.lanes) : (B.updateQueue = null, B.memoizedState = null) } var q = Ry(y); if (q !== null) { q.flags &= -257, Ay(q, y, k, p, n), q.mode & 1 && Ty(p, _, n), n = q, A = _; var te = n.updateQueue; if (te === null) { var re = new Set; re.add(A), n.updateQueue = re } else te.add(A); break e } else { if (!(n & 1)) { Ty(p, _, n), td(); break e } A = Error(o(426)) } } else if (De && k.mode & 1) { var We = Ry(y); if (We !== null) { !(We.flags & 65536) && (We.flags |= 256), Ay(We, y, k, p, n), fc(ho(A, k)); break e } } p = A = ho(A, k), Ke !== 4 && (Ke = 2), Ti === null ? Ti = [p] : Ti.push(p), p = y; do { switch (p.tag) { case 3: p.flags |= 65536, n &= -n, p.lanes |= n; var D = Py(p, A, n); Zv(p, D); break e; case 1: k = A; var L = p.type, O = p.stateNode; if (!(p.flags & 128) && (typeof L.getDerivedStateFromError == "function" || O !== null && typeof O.componentDidCatch == "function" && (Xn === null || !Xn.has(O)))) { p.flags |= 65536, n &= -n, p.lanes |= n; var K = Ey(p, k, n); Zv(p, K); break e } }p = p.return } while (p !== null) } s0(i) } catch (ie) { n = ie, $e === i && i !== null && ($e = i = i.return); continue } break } while (1) } function o0() { var e = fa.current; return fa.current = sa, e === null ? sa : e } function td() { (Ke === 0 || Ke === 3 || Ke === 2) && (Ke = 4), Xe === null || !(yr & 268435455) && !(pa & 268435455) || Zn(Xe, nt) } function wa(e, n) { var i = ke; ke |= 2; var a = o0(); (Xe !== e || nt !== n) && (Sn = null, xr(e, n)); do try { TT(); break } catch (c) { r0(e, c) } while (1); if (hc(), ke = i, fa.current = a, $e !== null) throw Error(o(261)); return Xe = null, nt = 0, Ke } function TT() { for (; $e !== null;)i0($e) } function RT() { for (; $e !== null && !JP();)i0($e) } function i0(e) { var n = u0(e.alternate, e, bt); e.memoizedProps = e.pendingProps, n === null ? s0(e) : $e = n, Kc.current = null } function s0(e) { var n = e; do { var i = n.alternate; if (e = n.return, n.flags & 32768) { if (i = ST(i, n), i !== null) { i.flags &= 32767, $e = i; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { Ke = 6, $e = null; return } } else if (i = xT(i, n, bt), i !== null) { $e = i; return } if (n = n.sibling, n !== null) { $e = n; return } $e = n = e } while (n !== null); Ke === 0 && (Ke = 5) } function Sr(e, n, i) { var a = Ee, c = Mt.transition; try { Mt.transition = null, Ee = 1, AT(e, n, i, a) } finally { Mt.transition = c, Ee = a } return null } function AT(e, n, i, a) { do yo(); while (Qn !== null); if (ke & 6) throw Error(o(327)); i = e.finishedWork; var c = e.finishedLanes; if (i === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, i === e.current) throw Error(o(177)); e.callbackNode = null, e.callbackPriority = 0; var p = i.lanes | i.childLanes; if (uE(e, p), e === Xe && ($e = Xe = null, nt = 0), !(i.subtreeFlags & 2064) && !(i.flags & 2064) || ma || (ma = !0, c0(bs, function () { return yo(), null })), p = (i.flags & 15990) !== 0, i.subtreeFlags & 15990 || p) { p = Mt.transition, Mt.transition = null; var y = Ee; Ee = 1; var k = ke; ke |= 4, Kc.current = null, bT(e, i), Qy(i, e), XE(tc), Ns = !!ec, tc = ec = null, e.current = i, kT(i), eE(), ke = k, Ee = y, Mt.transition = p } else e.current = i; if (ma && (ma = !1, Qn = e, ga = c), p = e.pendingLanes, p === 0 && (Xn = null), rE(i.stateNode), gt(e, Ue()), n !== null) for (a = e.onRecoverableError, i = 0; i < n.length; i++)c = n[i], a(c.value, { componentStack: c.stack, digest: c.digest }); if (ha) throw ha = !1, e = Xc, Xc = null, e; return ga & 1 && e.tag !== 0 && yo(), p = e.pendingLanes, p & 1 ? e === Qc ? Ri++ : (Ri = 0, Qc = e) : Ri = 0, Hn(), null } function yo() { if (Qn !== null) { var e = Yg(ga), n = Mt.transition, i = Ee; try { if (Mt.transition = null, Ee = 16 > e ? 16 : e, Qn === null) var a = !1; else { if (e = Qn, Qn = null, ga = 0, ke & 6) throw Error(o(331)); var c = ke; for (ke |= 4, ee = e.current; ee !== null;) { var p = ee, y = p.child; if (ee.flags & 16) { var k = p.deletions; if (k !== null) { for (var A = 0; A < k.length; A++) { var _ = k[A]; for (ee = _; ee !== null;) { var B = ee; switch (B.tag) { case 0: case 11: case 15: Pi(8, B, p) }var U = B.child; if (U !== null) U.return = B, ee = U; else for (; ee !== null;) { B = ee; var z = B.sibling, q = B.return; if (Hy(B), B === _) { ee = null; break } if (z !== null) { z.return = q, ee = z; break } ee = q } } } var te = p.alternate; if (te !== null) { var re = te.child; if (re !== null) { te.child = null; do { var We = re.sibling; re.sibling = null, re = We } while (re !== null) } } ee = p } } if (p.subtreeFlags & 2064 && y !== null) y.return = p, ee = y; else e: for (; ee !== null;) { if (p = ee, p.flags & 2048) switch (p.tag) { case 0: case 11: case 15: Pi(9, p, p.return) }var D = p.sibling; if (D !== null) { D.return = p.return, ee = D; break e } ee = p.return } } var L = e.current; for (ee = L; ee !== null;) { y = ee; var O = y.child; if (y.subtreeFlags & 2064 && O !== null) O.return = y, ee = O; else e: for (y = L; ee !== null;) { if (k = ee, k.flags & 2048) try { switch (k.tag) { case 0: case 11: case 15: da(9, k) } } catch (ie) { Ve(k, k.return, ie) } if (k === y) { ee = null; break e } var K = k.sibling; if (K !== null) { K.return = k.return, ee = K; break e } ee = k.return } } if (ke = c, Hn(), Xt && typeof Xt.onPostCommitFiberRoot == "function") try { Xt.onPostCommitFiberRoot(ks, e) } catch { } a = !0 } return a } finally { Ee = i, Mt.transition = n } } return !1 } function a0(e, n, i) { n = ho(i, n), n = Py(e, n, 1), e = Gn(e, n, 1), n = ct(), e !== null && (Zo(e, 1, n), gt(e, n)) } function Ve(e, n, i) { if (e.tag === 3) a0(e, e, i); else for (; n !== null;) { if (n.tag === 3) { a0(n, e, i); break } else if (n.tag === 1) { var a = n.stateNode; if (typeof n.type.getDerivedStateFromError == "function" || typeof a.componentDidCatch == "function" && (Xn === null || !Xn.has(a))) { e = ho(i, e), e = Ey(n, e, 1), n = Gn(n, e, 1), e = ct(), n !== null && (Zo(n, 1, e), gt(n, e)); break } } n = n.return } } function NT(e, n, i) { var a = e.pingCache; a !== null && a.delete(n), n = ct(), e.pingedLanes |= e.suspendedLanes & i, Xe === e && (nt & i) === i && (Ke === 4 || Ke === 3 && (nt & 130023424) === nt && 500 > Ue() - Yc ? xr(e, 0) : Gc |= i), gt(e, n) } function l0(e, n) { n === 0 && (e.mode & 1 ? (n = Es, Es <<= 1, !(Es & 130023424) && (Es = 4194304)) : n = 1); var i = ct(); e = yn(e, n), e !== null && (Zo(e, n, i), gt(e, i)) } function MT(e) { var n = e.memoizedState, i = 0; n !== null && (i = n.retryLane), l0(e, i) } function LT(e, n) { var i = 0; switch (e.tag) { case 13: var a = e.stateNode, c = e.memoizedState; c !== null && (i = c.retryLane); break; case 19: a = e.stateNode; break; default: throw Error(o(314)) }a !== null && a.delete(n), l0(e, i) } var u0; u0 = function (e, n, i) { if (e !== null) if (e.memoizedProps !== n.pendingProps || ft.current) ht = !0; else { if (!(e.lanes & i) && !(n.flags & 128)) return ht = !1, wT(e, n, i); ht = !!(e.flags & 131072) } else ht = !1, De && n.flags & 1048576 && Uv(n, Ys, n.index); switch (n.lanes = 0, n.tag) { case 2: var a = n.type; ua(e, n), e = n.pendingProps; var c = io(n, it.current); fo(n, i), c = Pc(null, n, a, e, c, i); var p = Ec(); return n.flags |= 1, typeof c == "object" && c !== null && typeof c.render == "function" && c.$$typeof === void 0 ? (n.tag = 1, n.memoizedState = null, n.updateQueue = null, pt(a) ? (p = !0, Hs(n)) : p = !1, n.memoizedState = c.state !== null && c.state !== void 0 ? c.state : null, yc(n), c.updater = aa, n.stateNode = c, c._reactInternals = n, Lc(n, a, e, i), n = _c(null, n, a, !0, p, i)) : (n.tag = 0, De && p && lc(n), ut(null, n, c, i), n = n.child), n; case 16: a = n.elementType; e: { switch (ua(e, n), e = n.pendingProps, c = a._init, a = c(a._payload), n.type = a, c = n.tag = jT(a), e = Ft(a, e), c) { case 0: n = Oc(null, n, a, e, i); break e; case 1: n = Oy(null, n, a, e, i); break e; case 11: n = Ny(null, n, a, e, i); break e; case 14: n = My(null, n, a, Ft(a.type, e), i); break e }throw Error(o(306, a, "")) } return n; case 0: return a = n.type, c = n.pendingProps, c = n.elementType === a ? c : Ft(a, c), Oc(e, n, a, c, i); case 1: return a = n.type, c = n.pendingProps, c = n.elementType === a ? c : Ft(a, c), Oy(e, n, a, c, i); case 3: e: { if (_y(n), e === null) throw Error(o(387)); a = n.pendingProps, p = n.memoizedState, c = p.element, qv(e, n), ea(n, a, null, i); var y = n.memoizedState; if (a = y.element, p.isDehydrated) if (p = { element: a, isDehydrated: !1, cache: y.cache, pendingSuspenseBoundaries: y.pendingSuspenseBoundaries, transitions: y.transitions }, n.updateQueue.baseState = p, n.memoizedState = p, n.flags & 256) { c = ho(Error(o(423)), n), n = Iy(e, n, a, i, c); break e } else if (a !== c) { c = ho(Error(o(424)), n), n = Iy(e, n, a, i, c); break e } else for (Ct = Un(n.stateNode.containerInfo.firstChild), St = n, De = !0, Vt = null, i = Xv(n, null, a, i), n.child = i; i;)i.flags = i.flags & -3 | 4096, i = i.sibling; else { if (lo(), a === c) { n = xn(e, n, i); break e } ut(e, n, a, i) } n = n.child } return n; case 5: return ey(n), e === null && dc(n), a = n.type, c = n.pendingProps, p = e !== null ? e.memoizedProps : null, y = c.children, nc(a, c) ? y = null : p !== null && nc(a, p) && (n.flags |= 32), jy(e, n), ut(e, n, y, i), n.child; case 6: return e === null && dc(n), null; case 13: return Vy(e, n, i); case 4: return wc(n, n.stateNode.containerInfo), a = n.pendingProps, e === null ? n.child = uo(n, null, a, i) : ut(e, n, a, i), n.child; case 11: return a = n.type, c = n.pendingProps, c = n.elementType === a ? c : Ft(a, c), Ny(e, n, a, c, i); case 7: return ut(e, n, n.pendingProps, i), n.child; case 8: return ut(e, n, n.pendingProps.children, i), n.child; case 12: return ut(e, n, n.pendingProps.children, i), n.child; case 10: e: { if (a = n.type._context, c = n.pendingProps, p = n.memoizedProps, y = c.value, Ae(qs, a._currentValue), a._currentValue = y, p !== null) if (It(p.value, y)) { if (p.children === c.children && !ft.current) { n = xn(e, n, i); break e } } else for (p = n.child, p !== null && (p.return = n); p !== null;) { var k = p.dependencies; if (k !== null) { y = p.child; for (var A = k.firstContext; A !== null;) { if (A.context === a) { if (p.tag === 1) { A = wn(-1, i & -i), A.tag = 2; var _ = p.updateQueue; if (_ !== null) { _ = _.shared; var B = _.pending; B === null ? A.next = A : (A.next = B.next, B.next = A), _.pending = A } } p.lanes |= i, A = p.alternate, A !== null && (A.lanes |= i), gc(p.return, i, n), k.lanes |= i; break } A = A.next } } else if (p.tag === 10) y = p.type === n.type ? null : p.child; else if (p.tag === 18) { if (y = p.return, y === null) throw Error(o(341)); y.lanes |= i, k = y.alternate, k !== null && (k.lanes |= i), gc(y, i, n), y = p.sibling } else y = p.child; if (y !== null) y.return = p; else for (y = p; y !== null;) { if (y === n) { y = null; break } if (p = y.sibling, p !== null) { p.return = y.return, y = p; break } y = y.return } p = y } ut(e, n, c.children, i), n = n.child } return n; case 9: return c = n.type, a = n.pendingProps.children, fo(n, i), c = At(c), a = a(c), n.flags |= 1, ut(e, n, a, i), n.child; case 14: return a = n.type, c = Ft(a, n.pendingProps), c = Ft(a.type, c), My(e, n, a, c, i); case 15: return Ly(e, n, n.type, n.pendingProps, i); case 17: return a = n.type, c = n.pendingProps, c = n.elementType === a ? c : Ft(a, c), ua(e, n), n.tag = 1, pt(a) ? (e = !0, Hs(n)) : e = !1, fo(n, i), by(n, a, c), Lc(n, a, c, i), _c(null, n, a, !0, e, i); case 19: return zy(e, n, i); case 22: return Dy(e, n, i) }throw Error(o(156, n.tag)) }; function c0(e, n) { return Wg(e, n) } function DT(e, n, i, a) { this.tag = e, this.key = i, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = n, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = a, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Lt(e, n, i, a) { return new DT(e, n, i, a) } function nd(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function jT(e) { if (typeof e == "function") return nd(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === Z) return 11; if (e === J) return 14 } return 2 } function Jn(e, n) { var i = e.alternate; return i === null ? (i = Lt(e.tag, n, e.key, e.mode), i.elementType = e.elementType, i.type = e.type, i.stateNode = e.stateNode, i.alternate = e, e.alternate = i) : (i.pendingProps = n, i.type = e.type, i.flags = 0, i.subtreeFlags = 0, i.deletions = null), i.flags = e.flags & 14680064, i.childLanes = e.childLanes, i.lanes = e.lanes, i.child = e.child, i.memoizedProps = e.memoizedProps, i.memoizedState = e.memoizedState, i.updateQueue = e.updateQueue, n = e.dependencies, i.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }, i.sibling = e.sibling, i.index = e.index, i.ref = e.ref, i } function xa(e, n, i, a, c, p) { var y = 2; if (a = e, typeof e == "function") nd(e) && (y = 1); else if (typeof e == "string") y = 5; else e: switch (e) { case $: return Cr(i.children, c, p, n); case W: y = 8, c |= 8; break; case le: return e = Lt(12, i, n, c | 2), e.elementType = le, e.lanes = p, e; case ge: return e = Lt(13, i, n, c), e.elementType = ge, e.lanes = p, e; case ne: return e = Lt(19, i, n, c), e.elementType = ne, e.lanes = p, e; case G: return Sa(i, c, p, n); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case oe: y = 10; break e; case me: y = 9; break e; case Z: y = 11; break e; case J: y = 14; break e; case se: y = 16, a = null; break e }throw Error(o(130, e == null ? e : typeof e, "")) }return n = Lt(y, i, n, c), n.elementType = e, n.type = a, n.lanes = p, n } function Cr(e, n, i, a) { return e = Lt(7, e, a, n), e.lanes = i, e } function Sa(e, n, i, a) { return e = Lt(22, e, a, n), e.elementType = G, e.lanes = i, e.stateNode = { isHidden: !1 }, e } function rd(e, n, i) { return e = Lt(6, e, null, n), e.lanes = i, e } function od(e, n, i) { return n = Lt(4, e.children !== null ? e.children : [], e.key, n), n.lanes = i, n.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, n } function OT(e, n, i, a, c) { this.tag = n, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Mu(0), this.expirationTimes = Mu(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Mu(0), this.identifierPrefix = a, this.onRecoverableError = c, this.mutableSourceEagerHydrationData = null } function id(e, n, i, a, c, p, y, k, A) { return e = new OT(e, n, i, k, A), n === 1 ? (n = 1, p === !0 && (n |= 8)) : n = 0, p = Lt(3, null, null, n), e.current = p, p.stateNode = e, p.memoizedState = { element: a, isDehydrated: i, cache: null, transitions: null, pendingSuspenseBoundaries: null }, yc(p), e } function _T(e, n, i) { var a = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: H, key: a == null ? null : "" + a, children: e, containerInfo: n, implementation: i } } function d0(e) { if (!e) return $n; e = e._reactInternals; e: { if (cr(e) !== e || e.tag !== 1) throw Error(o(170)); var n = e; do { switch (n.tag) { case 3: n = n.stateNode.context; break e; case 1: if (pt(n.type)) { n = n.stateNode.__reactInternalMemoizedMergedChildContext; break e } }n = n.return } while (n !== null); throw Error(o(171)) } if (e.tag === 1) { var i = e.type; if (pt(i)) return Fv(e, i, n) } return n } function f0(e, n, i, a, c, p, y, k, A) { return e = id(i, a, !0, e, c, p, y, k, A), e.context = d0(null), i = e.current, a = ct(), c = qn(i), p = wn(a, c), p.callback = n ?? null, Gn(i, p, c), e.current.lanes = c, Zo(e, c, a), gt(e, a), e } function Ca(e, n, i, a) { var c = n.current, p = ct(), y = qn(c); return i = d0(i), n.context === null ? n.context = i : n.pendingContext = i, n = wn(p, y), n.payload = { element: e }, a = a === void 0 ? null : a, a !== null && (n.callback = a), e = Gn(c, n, y), e !== null && (Ut(e, c, y, p), Js(e, c, y)), y } function ba(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function p0(e, n) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var i = e.retryLane; e.retryLane = i !== 0 && i < n ? i : n } } function sd(e, n) { p0(e, n), (e = e.alternate) && p0(e, n) } function IT() { return null } var h0 = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function ad(e) { this._internalRoot = e } ka.prototype.render = ad.prototype.render = function (e) { var n = this._internalRoot; if (n === null) throw Error(o(409)); Ca(e, n, null, null) }, ka.prototype.unmount = ad.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var n = e.containerInfo; wr(function () { Ca(null, e, null, null) }), n[hn] = null } }; function ka(e) { this._internalRoot = e } ka.prototype.unstable_scheduleHydration = function (e) { if (e) { var n = qg(); e = { blockedOn: null, target: e, priority: n }; for (var i = 0; i < Fn.length && n !== 0 && n < Fn[i].priority; i++); Fn.splice(i, 0, e), i === 0 && ev(e) } }; function ld(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function Pa(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function m0() { } function VT(e, n, i, a, c) { if (c) { if (typeof a == "function") { var p = a; a = function () { var _ = ba(y); p.call(_) } } var y = f0(n, a, e, 0, null, !1, !1, "", m0); return e._reactRootContainer = y, e[hn] = y.current, fi(e.nodeType === 8 ? e.parentNode : e), wr(), y } for (; c = e.lastChild;)e.removeChild(c); if (typeof a == "function") { var k = a; a = function () { var _ = ba(A); k.call(_) } } var A = id(e, 0, !1, null, null, !1, !1, "", m0); return e._reactRootContainer = A, e[hn] = A.current, fi(e.nodeType === 8 ? e.parentNode : e), wr(function () { Ca(n, A, i, a) }), A } function Ea(e, n, i, a, c) { var p = i._reactRootContainer; if (p) { var y = p; if (typeof c == "function") { var k = c; c = function () { var A = ba(y); k.call(A) } } Ca(n, y, e, c) } else y = VT(i, n, e, c, a); return ba(y) } Xg = function (e) { switch (e.tag) { case 3: var n = e.stateNode; if (n.current.memoizedState.isDehydrated) { var i = qo(n.pendingLanes); i !== 0 && (Lu(n, i | 1), gt(n, Ue()), !(ke & 6) && (vo = Ue() + 500, Hn())) } break; case 13: wr(function () { var a = yn(e, 1); if (a !== null) { var c = ct(); Ut(a, e, 1, c) } }), sd(e, 1) } }, Du = function (e) { if (e.tag === 13) { var n = yn(e, 134217728); if (n !== null) { var i = ct(); Ut(n, e, 134217728, i) } sd(e, 134217728) } }, Qg = function (e) { if (e.tag === 13) { var n = qn(e), i = yn(e, n); if (i !== null) { var a = ct(); Ut(i, e, n, a) } sd(e, n) } }, qg = function () { return Ee }, Zg = function (e, n) { var i = Ee; try { return Ee = e, n() } finally { Ee = i } }, Pu = function (e, n, i) { switch (n) { case "input": if (ur(e, i), n = i.name, i.type === "radio" && n != null) { for (i = e; i.parentNode;)i = i.parentNode; for (i = i.querySelectorAll("input[name=" + JSON.stringify("" + n) + '][type="radio"]'), n = 0; n < i.length; n++) { var a = i[n]; if (a !== e && a.form === e.form) { var c = Ws(a); if (!c) throw Error(o(90)); Re(a), ur(a, c) } } } break; case "textarea": Tg(e, i); break; case "select": n = i.value, n != null && Gr(e, !!i.multiple, n, !1) } }, _g = Jc, Ig = wr; var FT = { usingClientEntryPoint: !1, Events: [mi, ro, Ws, jg, Og, Jc] }, Ai = { findFiberByHostInstance: dr, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, zT = { bundleType: Ai.bundleType, version: Ai.version, rendererPackageName: Ai.rendererPackageName, rendererConfig: Ai.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: j.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = Bg(e), e === null ? null : e.stateNode }, findFiberByHostInstance: Ai.findFiberByHostInstance || IT, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Ta = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Ta.isDisabled && Ta.supportsFiber) try { ks = Ta.inject(zT), Xt = Ta } catch { } } return dt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = FT, dt.createPortal = function (e, n) { var i = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!ld(n)) throw Error(o(200)); return _T(e, n, null, i) }, dt.createRoot = function (e, n) { if (!ld(e)) throw Error(o(299)); var i = !1, a = "", c = h0; return n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (a = n.identifierPrefix), n.onRecoverableError !== void 0 && (c = n.onRecoverableError)), n = id(e, 1, !1, null, null, i, !1, a, c), e[hn] = n.current, fi(e.nodeType === 8 ? e.parentNode : e), new ad(n) }, dt.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var n = e._reactInternals; if (n === void 0) throw typeof e.render == "function" ? Error(o(188)) : (e = Object.keys(e).join(","), Error(o(268, e))); return e = Bg(n), e = e === null ? null : e.stateNode, e }, dt.flushSync = function (e) { return wr(e) }, dt.hydrate = function (e, n, i) { if (!Pa(n)) throw Error(o(200)); return Ea(null, e, n, !0, i) }, dt.hydrateRoot = function (e, n, i) { if (!ld(e)) throw Error(o(405)); var a = i != null && i.hydratedSources || null, c = !1, p = "", y = h0; if (i != null && (i.unstable_strictMode === !0 && (c = !0), i.identifierPrefix !== void 0 && (p = i.identifierPrefix), i.onRecoverableError !== void 0 && (y = i.onRecoverableError)), n = f0(n, null, e, 1, i ?? null, c, !1, p, y), e[hn] = n.current, fi(e), a) for (e = 0; e < a.length; e++)i = a[e], c = i._getVersion, c = c(i._source), n.mutableSourceEagerHydrationData == null ? n.mutableSourceEagerHydrationData = [i, c] : n.mutableSourceEagerHydrationData.push(i, c); return new ka(n) }, dt.render = function (e, n, i) { if (!Pa(n)) throw Error(o(200)); return Ea(null, e, n, !1, i) }, dt.unmountComponentAtNode = function (e) { if (!Pa(e)) throw Error(o(40)); return e._reactRootContainer ? (wr(function () { Ea(null, null, e, !1, function () { e._reactRootContainer = null, e[hn] = null }) }), !0) : !1 }, dt.unstable_batchedUpdates = Jc, dt.unstable_renderSubtreeIntoContainer = function (e, n, i, a) { if (!Pa(i)) throw Error(o(200)); if (e == null || e._reactInternals === void 0) throw Error(o(38)); return Ea(e, n, i, !1, a) }, dt.version = "18.3.1-next-f1338f8080-20240426", dt
  } function vd() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(vd) } catch (t) { console.error(t) } } vd(), pd.exports = S0(); var xo = pd.exports, yd = xo; Na.createRoot = yd.createRoot, Na.hydrateRoot = yd.hydrateRoot; var w = Aa(); const Cn = g0(w), C0 = Ni({ __proto__: null, default: Cn }, [w]);/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const b0 = t => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), wd = (...t) => t.filter((r, o, s) => !!r && s.indexOf(r) === o).join(" ");/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var k0 = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const P0 = w.forwardRef(({ color: t = "currentColor", size: r = 24, strokeWidth: o = 2, absoluteStrokeWidth: s, className: l = "", children: d, iconNode: u, ...f }, h) => w.createElement("svg", { ref: h, ...k0, width: r, height: r, stroke: t, strokeWidth: s ? Number(o) * 24 / Number(r) : o, className: wd("lucide", l), ...f }, [...u.map(([m, v]) => w.createElement(m, v)), ...Array.isArray(d) ? d : [d]]));/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const br = (t, r) => { const o = w.forwardRef(({ className: s, ...l }, d) => w.createElement(P0, { ref: d, iconNode: r, className: wd(`lucide-${b0(t)}`, s), ...l })); return o.displayName = `${t}`, o };/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const xd = br("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Sd = br("ChevronDown", [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]]);/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const E0 = br("ChevronLeft", [["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]]);/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const T0 = br("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const R0 = br("CircleAlert", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }], ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]]);/**
 * @license lucide-react v0.403.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const A0 = br("X", [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]]), Da = w.createContext({ transformPagePoint: t => t, isStatic: !1, reducedMotion: "never" }), Mi = w.createContext({}), Li = w.createContext(null), ja = typeof window < "u", Cd = ja ? w.useLayoutEffect : w.useEffect, bd = w.createContext({ strict: !1 }), Di = t => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), kd = "data-" + Di("framerAppearId"), N0 = { skipAnimations: !1, useManualTiming: !1 }; function M0(t) { let r = new Set, o = new Set, s = !1, l = !1; const d = new WeakSet; let u = { delta: 0, timestamp: 0, isProcessing: !1 }; function f(m) { d.has(m) && (h.schedule(m), t()), m(u) } const h = { schedule: (m, v = !1, g = !1) => { const C = g && s ? r : o; return v && d.add(m), C.has(m) || C.add(m), m }, cancel: m => { o.delete(m), d.delete(m) }, process: m => { if (u = m, s) { l = !0; return } s = !0, [r, o] = [o, r], o.clear(), r.forEach(f), s = !1, l && (l = !1, h.process(m)) } }; return h } const ji = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"], L0 = 40; function Pd(t, r) { let o = !1, s = !0; const l = { delta: 0, timestamp: 0, isProcessing: !1 }, d = () => o = !0, u = ji.reduce((R, N) => (R[N] = M0(d), R), {}), { read: f, resolveKeyframes: h, update: m, preRender: v, render: g, postRender: x } = u, C = () => { const R = performance.now(); o = !1, l.delta = s ? 1e3 / 60 : Math.max(Math.min(R - l.timestamp, L0), 1), l.timestamp = R, l.isProcessing = !0, f.process(l), h.process(l), m.process(l), v.process(l), g.process(l), x.process(l), l.isProcessing = !1, o && r && (s = !1, t(C)) }, b = () => { o = !0, s = !0, l.isProcessing || t(C) }; return { schedule: ji.reduce((R, N) => { const M = u[N]; return R[N] = (j, I = !1, H = !1) => (o || b(), M.schedule(j, I, H)), R }, {}), cancel: R => { for (let N = 0; N < ji.length; N++)u[ji[N]].cancel(R) }, state: l, steps: u } } const { schedule: Oa, cancel: WT } = Pd(queueMicrotask, !1); function kr(t) { return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current") } const Ed = w.createContext({}); let Td = !1; function D0(t, r, o, s, l) { var d; const { visualElement: u } = w.useContext(Mi), f = w.useContext(bd), h = w.useContext(Li), m = w.useContext(Da).reducedMotion, v = w.useRef(); s = s || f.renderer, !v.current && s && (v.current = s(t, { visualState: r, parent: u, props: o, presenceContext: h, blockInitialAnimation: h ? h.initial === !1 : !1, reducedMotionConfig: m })); const g = v.current, x = w.useContext(Ed); g && !g.projection && l && (g.type === "html" || g.type === "svg") && O0(v.current, o, l, x), w.useInsertionEffect(() => { g && g.update(o, h) }); const C = o[kd], b = w.useRef(!!C && !window.MotionHandoffIsComplete && ((d = window.MotionHasOptimisedAnimation) === null || d === void 0 ? void 0 : d.call(window, C))); return Cd(() => { g && (g.updateFeatures(), Oa.render(g.render), b.current && g.animationState && g.animationState.animateChanges()) }), w.useEffect(() => { g && (!b.current && g.animationState && g.animationState.animateChanges(), b.current = !1, Td || (Td = !0, queueMicrotask(j0))) }), g } function j0() { window.MotionHandoffIsComplete = !0 } function O0(t, r, o, s) { const { layoutId: l, layout: d, drag: u, dragConstraints: f, layoutScroll: h, layoutRoot: m } = r; t.projection = new o(t.latestValues, r["data-framer-portal-id"] ? void 0 : Rd(t.parent)), t.projection.setOptions({ layoutId: l, layout: d, alwaysMeasureLayout: !!u || f && kr(f), visualElement: t, animationType: typeof d == "string" ? d : "both", initialPromotionConfig: s, layoutScroll: h, layoutRoot: m }) } function Rd(t) { if (t) return t.options.allowProjection !== !1 ? t.projection : Rd(t.parent) } function _0(t, r, o) { return w.useCallback(s => { s && t.mount && t.mount(s), r && (s ? r.mount(s) : r.unmount()), o && (typeof o == "function" ? o(s) : kr(o) && (o.current = s)) }, [r]) } function So(t) { return typeof t == "string" || Array.isArray(t) } function Co(t) { return t !== null && typeof t == "object" && typeof t.start == "function" } const _a = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], Ia = ["initial", ..._a]; function Oi(t) { return Co(t.animate) || Ia.some(r => So(t[r])) } function Ad(t) { return !!(Oi(t) || t.variants) } function I0(t, r) { if (Oi(t)) { const { initial: o, animate: s } = t; return { initial: o === !1 || So(o) ? o : void 0, animate: So(s) ? s : void 0 } } return t.inherit !== !1 ? r : {} } function V0(t) { const { initial: r, animate: o } = I0(t, w.useContext(Mi)); return w.useMemo(() => ({ initial: r, animate: o }), [Nd(r), Nd(o)]) } function Nd(t) { return Array.isArray(t) ? t.join(" ") : t } const Md = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, Pr = {}; for (const t in Md) Pr[t] = { isEnabled: r => Md[t].some(o => !!r[o]) }; function F0(t) { for (const r in t) Pr[r] = { ...Pr[r], ...t[r] } } const Va = w.createContext({}), z0 = Symbol.for("motionComponentSymbol"), qe = t => t; let B0 = qe, Ld = qe; function U0({ preloadedFeatures: t, createVisualElement: r, useRender: o, useVisualState: s, Component: l }) { t && F0(t); function d(f, h) { let m; const v = { ...w.useContext(Da), ...f, layoutId: W0(f) }, { isStatic: g } = v, x = V0(f), C = s(f, g); if (!g && ja) { $0(); const b = H0(v); m = b.MeasureLayout, x.visualElement = D0(l, C, v, r, b.ProjectionNode) } return T.jsxs(Mi.Provider, { value: x, children: [m && x.visualElement ? T.jsx(m, { visualElement: x.visualElement, ...v }) : null, o(l, f, _0(C, x.visualElement, h), C, g, x.visualElement)] }) } const u = w.forwardRef(d); return u[z0] = l, u } function W0({ layoutId: t }) { const r = w.useContext(Va).id; return r && t !== void 0 ? r + "-" + t : t } function $0(t, r) { w.useContext(bd).strict } function H0(t) { const { drag: r, layout: o } = Pr; if (!r && !o) return {}; const s = { ...r, ...o }; return { MeasureLayout: r?.isEnabled(t) || o?.isEnabled(t) ? s.MeasureLayout : void 0, ProjectionNode: s.ProjectionNode } } function K0(t) { function r(s, l = {}) { return U0(t(s, l)) } if (typeof Proxy > "u") return r; const o = new Map; return new Proxy(r, { get: (s, l) => (o.has(l) || o.set(l, r(l)), o.get(l)) }) } const G0 = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function Fa(t) { return typeof t != "string" || t.includes("-") ? !1 : !!(G0.indexOf(t) > -1 || /[A-Z]/u.test(t)) } const _i = {}; function Y0(t) { Object.assign(_i, t) } const bo = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], bn = new Set(bo); function Dd(t, { layout: r, layoutId: o }) { return bn.has(t) || t.startsWith("origin") || (r || o !== void 0) && (!!_i[t] || t === "opacity") } const rt = t => !!(t && t.getVelocity), jd = (t, r) => r && typeof t == "number" ? r.transform(t) : t, kn = (t, r, o) => o > r ? r : o < t ? t : o, Er = { test: t => typeof t == "number", parse: parseFloat, transform: t => t }, ko = { ...Er, transform: t => kn(0, 1, t) }, Ii = { ...Er, default: 1 }, Po = t => Math.round(t * 1e5) / 1e5, za = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu, X0 = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu, Q0 = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu; function Eo(t) { return typeof t == "string" } function q0(t) { return t == null } const To = t => ({ test: r => Eo(r) && r.endsWith(t) && r.split(" ").length === 1, parse: parseFloat, transform: r => `${r}${t}` }), Pn = To("deg"), Wt = To("%"), pe = To("px"), Z0 = To("vh"), J0 = To("vw"), Od = { ...Wt, parse: t => Wt.parse(t) / 100, transform: t => Wt.transform(t * 100) }, _d = { ...Er, transform: Math.round }, Ba = { borderWidth: pe, borderTopWidth: pe, borderRightWidth: pe, borderBottomWidth: pe, borderLeftWidth: pe, borderRadius: pe, radius: pe, borderTopLeftRadius: pe, borderTopRightRadius: pe, borderBottomRightRadius: pe, borderBottomLeftRadius: pe, width: pe, maxWidth: pe, height: pe, maxHeight: pe, size: pe, top: pe, right: pe, bottom: pe, left: pe, padding: pe, paddingTop: pe, paddingRight: pe, paddingBottom: pe, paddingLeft: pe, margin: pe, marginTop: pe, marginRight: pe, marginBottom: pe, marginLeft: pe, rotate: Pn, rotateX: Pn, rotateY: Pn, rotateZ: Pn, scale: Ii, scaleX: Ii, scaleY: Ii, scaleZ: Ii, skew: Pn, skewX: Pn, skewY: Pn, distance: pe, translateX: pe, translateY: pe, translateZ: pe, x: pe, y: pe, z: pe, perspective: pe, transformPerspective: pe, opacity: ko, originX: Od, originY: Od, originZ: pe, zIndex: _d, backgroundPositionX: pe, backgroundPositionY: pe, fillOpacity: ko, strokeOpacity: ko, numOctaves: _d }, ew = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, tw = bo.length; function nw(t, r, o) { let s = "", l = !0; for (let d = 0; d < tw; d++) { const u = bo[d], f = t[u]; if (f === void 0) continue; let h = !0; if (typeof f == "number" ? h = f === (u.startsWith("scale") ? 1 : 0) : h = parseFloat(f) === 0, !h || o) { const m = jd(f, Ba[u]); if (!h) { l = !1; const v = ew[u] || u; s += `${v}(${m}) ` } o && (r[u] = m) } } return s = s.trim(), o ? s = o(r, l ? "" : s) : l && (s = "none"), s } const Id = t => r => typeof r == "string" && r.startsWith(t), Vd = Id("--"), rw = Id("var(--"), Ua = t => rw(t) ? ow.test(t.split("/*")[0].trim()) : !1, ow = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu; function Wa(t, r, o) { const { style: s, vars: l, transformOrigin: d } = t; let u = !1, f = !1; for (const h in r) { const m = r[h]; if (bn.has(h)) { u = !0; continue } else if (Vd(h)) { l[h] = m; continue } else { const v = jd(m, Ba[h]); h.startsWith("origin") ? (f = !0, d[h] = v) : s[h] = v } } if (r.transform || (u || o ? s.transform = nw(r, t.transform, o) : s.transform && (s.transform = "none")), f) { const { originX: h = "50%", originY: m = "50%", originZ: v = 0 } = d; s.transformOrigin = `${h} ${m} ${v}` } } const $a = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function Fd(t, r, o) { for (const s in r) !rt(r[s]) && !Dd(s, o) && (t[s] = r[s]) } function iw({ transformTemplate: t }, r) { return w.useMemo(() => { const o = $a(); return Wa(o, r, t), Object.assign({}, o.vars, o.style) }, [r]) } function sw(t, r) { const o = t.style || {}, s = {}; return Fd(s, o, t), Object.assign(s, iw(t, r)), s } function aw(t, r) { const o = {}, s = sw(t, r); return t.drag && t.dragListener !== !1 && (o.draggable = !1, s.userSelect = s.WebkitUserSelect = s.WebkitTouchCallout = "none", s.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (o.tabIndex = 0), o.style = s, o } const lw = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function Vi(t) { return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || lw.has(t) } let zd = t => !Vi(t); function uw(t) { t && (zd = r => r.startsWith("on") ? !Vi(r) : t(r)) } try { uw(require("@emotion/is-prop-valid").default) } catch { } function cw(t, r, o) { const s = {}; for (const l in t) l === "values" && typeof t.values == "object" || (zd(l) || o === !0 && Vi(l) || !r && !Vi(l) || t.draggable && l.startsWith("onDrag")) && (s[l] = t[l]); return s } function Bd(t, r, o) { return typeof t == "string" ? t : pe.transform(r + o * t) } function dw(t, r, o) { const s = Bd(r, t.x, t.width), l = Bd(o, t.y, t.height); return `${s} ${l}` } const fw = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, pw = { offset: "strokeDashoffset", array: "strokeDasharray" }; function hw(t, r, o = 1, s = 0, l = !0) { t.pathLength = 1; const d = l ? fw : pw; t[d.offset] = pe.transform(-s); const u = pe.transform(r), f = pe.transform(o); t[d.array] = `${u} ${f}` } function Ha(t, { attrX: r, attrY: o, attrScale: s, originX: l, originY: d, pathLength: u, pathSpacing: f = 1, pathOffset: h = 0, ...m }, v, g) { if (Wa(t, m, g), v) { t.style.viewBox && (t.attrs.viewBox = t.style.viewBox); return } t.attrs = t.style, t.style = {}; const { attrs: x, style: C, dimensions: b } = t; x.transform && (b && (C.transform = x.transform), delete x.transform), b && (l !== void 0 || d !== void 0 || C.transform) && (C.transformOrigin = dw(b, l !== void 0 ? l : .5, d !== void 0 ? d : .5)), r !== void 0 && (x.x = r), o !== void 0 && (x.y = o), s !== void 0 && (x.scale = s), u !== void 0 && hw(x, u, f, h, !1) } const Ud = () => ({ ...$a(), attrs: {} }), Ka = t => typeof t == "string" && t.toLowerCase() === "svg"; function mw(t, r, o, s) { const l = w.useMemo(() => { const d = Ud(); return Ha(d, r, Ka(s), t.transformTemplate), { ...d.attrs, style: { ...d.style } } }, [r]); if (t.style) { const d = {}; Fd(d, t.style, t), l.style = { ...d, ...l.style } } return l } function gw(t = !1) { return (o, s, l, { latestValues: d }, u) => { const h = (Fa(o) ? mw : aw)(s, d, u, o), m = cw(s, typeof o == "string", t), v = o !== w.Fragment ? { ...m, ...h, ref: l } : {}, { children: g } = s, x = w.useMemo(() => rt(g) ? g.get() : g, [g]); return w.createElement(o, { ...v, children: x }) } } function Wd(t, { style: r, vars: o }, s, l) { Object.assign(t.style, r, l && l.getProjectionStyles(s)); for (const d in o) t.style.setProperty(d, o[d]) } const $d = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function Hd(t, r, o, s) { Wd(t, r, void 0, s); for (const l in r.attrs) t.setAttribute($d.has(l) ? l : Di(l), r.attrs[l]) } function Ga(t, r, o) { var s; const { style: l } = t, d = {}; for (const u in l) (rt(l[u]) || r.style && rt(r.style[u]) || Dd(u, t) || ((s = o?.getValue(u)) === null || s === void 0 ? void 0 : s.liveStyle) !== void 0) && (d[u] = l[u]); return o && l && typeof l.willChange == "string" && (o.applyWillChange = !1), d } function Kd(t, r, o) { const s = Ga(t, r, o); for (const l in t) if (rt(t[l]) || rt(r[l])) { const d = bo.indexOf(l) !== -1 ? "attr" + l.charAt(0).toUpperCase() + l.substring(1) : l; s[d] = t[l] } return s } function Gd(t) { const r = [{}, {}]; return t?.values.forEach((o, s) => { r[0][s] = o.get(), r[1][s] = o.getVelocity() }), r } function Ya(t, r, o, s) { if (typeof r == "function") { const [l, d] = Gd(s); r = r(o !== void 0 ? o : t.custom, l, d) } if (typeof r == "string" && (r = t.variants && t.variants[r]), typeof r == "function") { const [l, d] = Gd(s); r = r(o !== void 0 ? o : t.custom, l, d) } return r } function Xa(t) { const r = w.useRef(null); return r.current === null && (r.current = t()), r.current } const Qa = t => Array.isArray(t), vw = t => !!(t && typeof t == "object" && t.mix && t.toValue), yw = t => Qa(t) ? t[t.length - 1] || 0 : t; function Fi(t) { const r = rt(t) ? t.get() : t; return vw(r) ? r.toValue() : r } const Yd = new Set(["opacity", "clipPath", "filter", "transform"]); function Xd(t) { if (bn.has(t)) return "transform"; if (Yd.has(t)) return Di(t) } function zi(t, r) { t.indexOf(r) === -1 && t.push(r) } function Bi(t, r) { const o = t.indexOf(r); o > -1 && t.splice(o, 1) } function ww({ applyWillChange: t = !1, scrapeMotionValuesFromProps: r, createRenderState: o, onMount: s }, l, d, u, f) { const h = { latestValues: Sw(l, d, u, f ? !1 : t, r), renderState: o() }; return s && (h.mount = m => s(l, m, h)), h } const Qd = t => (r, o) => { const s = w.useContext(Mi), l = w.useContext(Li), d = () => ww(t, r, s, l, o); return o ? d() : Xa(d) }; function xw(t, r) { const o = Xd(r); o && zi(t, o) } function qd(t, r, o) { const s = Array.isArray(r) ? r : [r]; for (let l = 0; l < s.length; l++) { const d = Ya(t, s[l]); if (d) { const { transitionEnd: u, transition: f, ...h } = d; o(h, u) } } } function Sw(t, r, o, s, l) { var d; const u = {}, f = [], h = s && ((d = t.style) === null || d === void 0 ? void 0 : d.willChange) === void 0, m = l(t, {}); for (const P in m) u[P] = Fi(m[P]); let { initial: v, animate: g } = t; const x = Oi(t), C = Ad(t); r && C && !x && t.inherit !== !1 && (v === void 0 && (v = r.initial), g === void 0 && (g = r.animate)); let b = o ? o.initial === !1 : !1; b = b || v === !1; const S = b ? g : v; return S && typeof S != "boolean" && !Co(S) && qd(t, S, (P, R) => { for (const N in P) { let M = P[N]; if (Array.isArray(M)) { const j = b ? M.length - 1 : 0; M = M[j] } M !== null && (u[N] = M) } for (const N in R) u[N] = R[N] }), h && (g && v !== !1 && !Co(g) && qd(t, g, P => { for (const R in P) xw(f, R) }), f.length && (u.willChange = f.join(","))), u } const { schedule: Te, cancel: en, state: Ze, steps: qa } = Pd(typeof requestAnimationFrame < "u" ? requestAnimationFrame : qe, !0), Cw = { useVisualState: Qd({ scrapeMotionValuesFromProps: Kd, createRenderState: Ud, onMount: (t, r, { renderState: o, latestValues: s }) => { Te.read(() => { try { o.dimensions = typeof r.getBBox == "function" ? r.getBBox() : r.getBoundingClientRect() } catch { o.dimensions = { x: 0, y: 0, width: 0, height: 0 } } }), Te.render(() => { Ha(o, s, Ka(r.tagName), t.transformTemplate), Hd(r, o) }) } }) }, bw = { useVisualState: Qd({ applyWillChange: !0, scrapeMotionValuesFromProps: Ga, createRenderState: $a }) }; function kw(t, { forwardMotionProps: r = !1 }, o, s) { return { ...Fa(t) ? Cw : bw, preloadedFeatures: o, useRender: gw(r), createVisualElement: s, Component: t } } function tn(t, r, o, s = { passive: !0 }) { return t.addEventListener(r, o, s), () => t.removeEventListener(r, o) } const Zd = t => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1; function Ui(t, r = "page") { return { point: { x: t[`${r}X`], y: t[`${r}Y`] } } } const Pw = t => r => Zd(r) && t(r, Ui(r)); function nn(t, r, o, s) { return tn(t, r, Pw(o), s) } const Ew = (t, r) => o => r(t(o)), rn = (...t) => t.reduce(Ew); function Jd(t) { let r = null; return () => { const o = () => { r = null }; return r === null ? (r = t, o) : !1 } } const ef = Jd("dragHorizontal"), tf = Jd("dragVertical"); function nf(t) { let r = !1; if (t === "y") r = tf(); else if (t === "x") r = ef(); else { const o = ef(), s = tf(); o && s ? r = () => { o(), s() } : (o && o(), s && s()) } return r } function rf() { const t = nf(!0); return t ? (t(), !1) : !0 } class En { constructor(r) { this.isMounted = !1, this.node = r } update() { } } function of(t, r) { const o = r ? "pointerenter" : "pointerleave", s = r ? "onHoverStart" : "onHoverEnd", l = (d, u) => { if (d.pointerType === "touch" || rf()) return; const f = t.getProps(); t.animationState && f.whileHover && t.animationState.setActive("whileHover", r); const h = f[s]; h && Te.postRender(() => h(d, u)) }; return nn(t.current, o, l, { passive: !t.getProps()[s] }) } class Tw extends En { mount() { this.unmount = rn(of(this.node, !0), of(this.node, !1)) } unmount() { } } class Rw extends En { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let r = !1; try { r = this.node.current.matches(":focus-visible") } catch { r = !0 } !r || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = rn(tn(this.node.current, "focus", () => this.onFocus()), tn(this.node.current, "blur", () => this.onBlur())) } unmount() { } } const sf = (t, r) => r ? t === r ? !0 : sf(t, r.parentElement) : !1; function Za(t, r) { if (!r) return; const o = new PointerEvent("pointer" + t); r(o, Ui(o)) } class Aw extends En { constructor() { super(...arguments), this.removeStartListeners = qe, this.removeEndListeners = qe, this.removeAccessibleListeners = qe, this.startPointerPress = (r, o) => { if (this.isPressing) return; this.removeEndListeners(); const s = this.node.getProps(), d = nn(window, "pointerup", (f, h) => { if (!this.checkPressEnd()) return; const { onTap: m, onTapCancel: v, globalTapTarget: g } = this.node.getProps(), x = !g && !sf(this.node.current, f.target) ? v : m; x && Te.update(() => x(f, h)) }, { passive: !(s.onTap || s.onPointerUp) }), u = nn(window, "pointercancel", (f, h) => this.cancelPress(f, h), { passive: !(s.onTapCancel || s.onPointerCancel) }); this.removeEndListeners = rn(d, u), this.startPress(r, o) }, this.startAccessiblePress = () => { const r = d => { if (d.key !== "Enter" || this.isPressing) return; const u = f => { f.key !== "Enter" || !this.checkPressEnd() || Za("up", (h, m) => { const { onTap: v } = this.node.getProps(); v && Te.postRender(() => v(h, m)) }) }; this.removeEndListeners(), this.removeEndListeners = tn(this.node.current, "keyup", u), Za("down", (f, h) => { this.startPress(f, h) }) }, o = tn(this.node.current, "keydown", r), s = () => { this.isPressing && Za("cancel", (d, u) => this.cancelPress(d, u)) }, l = tn(this.node.current, "blur", s); this.removeAccessibleListeners = rn(o, l) } } startPress(r, o) { this.isPressing = !0; const { onTapStart: s, whileTap: l } = this.node.getProps(); l && this.node.animationState && this.node.animationState.setActive("whileTap", !0), s && Te.postRender(() => s(r, o)) } checkPressEnd() { return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !rf() } cancelPress(r, o) { if (!this.checkPressEnd()) return; const { onTapCancel: s } = this.node.getProps(); s && Te.postRender(() => s(r, o)) } mount() { const r = this.node.getProps(), o = nn(r.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(r.onTapStart || r.onPointerStart) }), s = tn(this.node.current, "focus", this.startAccessiblePress); this.removeStartListeners = rn(o, s) } unmount() { this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners() } } const Ja = new WeakMap, el = new WeakMap, Nw = t => { const r = Ja.get(t.target); r && r(t) }, Mw = t => { t.forEach(Nw) }; function Lw({ root: t, ...r }) { const o = t || document; el.has(o) || el.set(o, {}); const s = el.get(o), l = JSON.stringify(r); return s[l] || (s[l] = new IntersectionObserver(Mw, { root: t, ...r })), s[l] } function Dw(t, r, o) { const s = Lw(r); return Ja.set(t, o), s.observe(t), () => { Ja.delete(t), s.unobserve(t) } } const jw = { some: 0, all: 1 }; class Ow extends En { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: r = {} } = this.node.getProps(), { root: o, margin: s, amount: l = "some", once: d } = r, u = { root: o ? o.current : void 0, rootMargin: s, threshold: typeof l == "number" ? l : jw[l] }, f = h => { const { isIntersecting: m } = h; if (this.isInView === m || (this.isInView = m, d && !m && this.hasEnteredView)) return; m && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", m); const { onViewportEnter: v, onViewportLeave: g } = this.node.getProps(), x = m ? v : g; x && x(h) }; return Dw(this.node.current, u, f) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: r, prevProps: o } = this.node;["amount", "margin", "root"].some(_w(r, o)) && this.startObserver() } unmount() { } } function _w({ viewport: t = {} }, { viewport: r = {} } = {}) { return o => t[o] !== r[o] } const Iw = { inView: { Feature: Ow }, tap: { Feature: Aw }, focus: { Feature: Rw }, hover: { Feature: Tw } }; function af(t, r) { if (!Array.isArray(r)) return !1; const o = r.length; if (o !== t.length) return !1; for (let s = 0; s < o; s++)if (r[s] !== t[s]) return !1; return !0 } function Wi(t, r, o) { const s = t.getProps(); return Ya(s, r, o !== void 0 ? o : s.custom, t) } const $t = t => t * 1e3, on = t => t / 1e3, Vw = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, Fw = t => ({ type: "spring", stiffness: 550, damping: t === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), zw = { type: "keyframes", duration: .8 }, Bw = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, Uw = (t, { keyframes: r }) => r.length > 2 ? zw : bn.has(t) ? t.startsWith("scale") ? Fw(r[1]) : Vw : Bw; function Ww({ when: t, delay: r, delayChildren: o, staggerChildren: s, staggerDirection: l, repeat: d, repeatType: u, repeatDelay: f, from: h, elapsed: m, ...v }) { return !!Object.keys(v).length } function tl(t, r) { return t[r] || t.default || t } const $w = t => t !== null; function $i(t, { repeat: r, repeatType: o = "loop" }, s) { const l = t.filter($w), d = r && o !== "loop" && r % 2 === 1 ? 0 : l.length - 1; return !d || s === void 0 ? l[d] : s } const lf = t => /^0[^.\s]+$/u.test(t); function Hw(t) { return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || lf(t) : !0 } const uf = t => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t), Kw = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function Gw(t) { const r = Kw.exec(t); if (!r) return [,]; const [, o, s, l] = r; return [`--${o ?? s}`, l] } function cf(t, r, o = 1) { const [s, l] = Gw(t); if (!s) return; const d = window.getComputedStyle(r).getPropertyValue(s); if (d) { const u = d.trim(); return uf(u) ? parseFloat(u) : u } return Ua(l) ? cf(l, r, o + 1) : l } const Yw = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]), df = t => t === Er || t === pe, ff = (t, r) => parseFloat(t.split(", ")[r]), pf = (t, r) => (o, { transform: s }) => { if (s === "none" || !s) return 0; const l = s.match(/^matrix3d\((.+)\)$/u); if (l) return ff(l[1], r); { const d = s.match(/^matrix\((.+)\)$/u); return d ? ff(d[1], t) : 0 } }, Xw = new Set(["x", "y", "z"]), Qw = bo.filter(t => !Xw.has(t)); function qw(t) { const r = []; return Qw.forEach(o => { const s = t.getValue(o); s !== void 0 && (r.push([o, s.get()]), s.set(o.startsWith("scale") ? 1 : 0)) }), r } const Tr = { width: ({ x: t }, { paddingLeft: r = "0", paddingRight: o = "0" }) => t.max - t.min - parseFloat(r) - parseFloat(o), height: ({ y: t }, { paddingTop: r = "0", paddingBottom: o = "0" }) => t.max - t.min - parseFloat(r) - parseFloat(o), top: (t, { top: r }) => parseFloat(r), left: (t, { left: r }) => parseFloat(r), bottom: ({ y: t }, { top: r }) => parseFloat(r) + (t.max - t.min), right: ({ x: t }, { left: r }) => parseFloat(r) + (t.max - t.min), x: pf(4, 13), y: pf(5, 14) }; Tr.translateX = Tr.x, Tr.translateY = Tr.y; const hf = t => r => r.test(t), mf = [Er, pe, Wt, Pn, J0, Z0, { test: t => t === "auto", parse: t => t }], gf = t => mf.find(hf(t)), tr = new Set; let nl = !1, rl = !1; function vf() { if (rl) { const t = Array.from(tr).filter(s => s.needsMeasurement), r = new Set(t.map(s => s.element)), o = new Map; r.forEach(s => { const l = qw(s); l.length && (o.set(s, l), s.render()) }), t.forEach(s => s.measureInitialState()), r.forEach(s => { s.render(); const l = o.get(s); l && l.forEach(([d, u]) => { var f; (f = s.getValue(d)) === null || f === void 0 || f.set(u) }) }), t.forEach(s => s.measureEndState()), t.forEach(s => { s.suspendedScrollY !== void 0 && window.scrollTo(0, s.suspendedScrollY) }) } rl = !1, nl = !1, tr.forEach(t => t.complete()), tr.clear() } function yf() { tr.forEach(t => { t.readKeyframes(), t.needsMeasurement && (rl = !0) }) } function Zw() { yf(), vf() } class ol { constructor(r, o, s, l, d, u = !1) { this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...r], this.onComplete = o, this.name = s, this.motionValue = l, this.element = d, this.isAsync = u } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (tr.add(this), nl || (nl = !0, Te.read(yf), Te.resolveKeyframes(vf))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: r, name: o, element: s, motionValue: l } = this; for (let d = 0; d < r.length; d++)if (r[d] === null) if (d === 0) { const u = l?.get(), f = r[r.length - 1]; if (u !== void 0) r[0] = u; else if (s && o) { const h = s.readValue(o, f); h != null && (r[0] = h) } r[0] === void 0 && (r[0] = f), l && u === void 0 && l.set(r[0]) } else r[d] = r[d - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), tr.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, tr.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } } const il = (t, r) => o => !!(Eo(o) && Q0.test(o) && o.startsWith(t) || r && !q0(o) && Object.prototype.hasOwnProperty.call(o, r)), wf = (t, r, o) => s => { if (!Eo(s)) return s; const [l, d, u, f] = s.match(za); return { [t]: parseFloat(l), [r]: parseFloat(d), [o]: parseFloat(u), alpha: f !== void 0 ? parseFloat(f) : 1 } }, Jw = t => kn(0, 255, t), sl = { ...Er, transform: t => Math.round(Jw(t)) }, nr = { test: il("rgb", "red"), parse: wf("red", "green", "blue"), transform: ({ red: t, green: r, blue: o, alpha: s = 1 }) => "rgba(" + sl.transform(t) + ", " + sl.transform(r) + ", " + sl.transform(o) + ", " + Po(ko.transform(s)) + ")" }; function ex(t) { let r = "", o = "", s = "", l = ""; return t.length > 5 ? (r = t.substring(1, 3), o = t.substring(3, 5), s = t.substring(5, 7), l = t.substring(7, 9)) : (r = t.substring(1, 2), o = t.substring(2, 3), s = t.substring(3, 4), l = t.substring(4, 5), r += r, o += o, s += s, l += l), { red: parseInt(r, 16), green: parseInt(o, 16), blue: parseInt(s, 16), alpha: l ? parseInt(l, 16) / 255 : 1 } } const al = { test: il("#"), parse: ex, transform: nr.transform }, Rr = { test: il("hsl", "hue"), parse: wf("hue", "saturation", "lightness"), transform: ({ hue: t, saturation: r, lightness: o, alpha: s = 1 }) => "hsla(" + Math.round(t) + ", " + Wt.transform(Po(r)) + ", " + Wt.transform(Po(o)) + ", " + Po(ko.transform(s)) + ")" }, ot = { test: t => nr.test(t) || al.test(t) || Rr.test(t), parse: t => nr.test(t) ? nr.parse(t) : Rr.test(t) ? Rr.parse(t) : al.parse(t), transform: t => Eo(t) ? t : t.hasOwnProperty("red") ? nr.transform(t) : Rr.transform(t) }; function tx(t) { var r, o; return isNaN(t) && Eo(t) && (((r = t.match(za)) === null || r === void 0 ? void 0 : r.length) || 0) + (((o = t.match(X0)) === null || o === void 0 ? void 0 : o.length) || 0) > 0 } const xf = "number", Sf = "color", nx = "var", rx = "var(", Cf = "${}", ox = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function Ro(t) { const r = t.toString(), o = [], s = { color: [], number: [], var: [] }, l = []; let d = 0; const f = r.replace(ox, h => (ot.test(h) ? (s.color.push(d), l.push(Sf), o.push(ot.parse(h))) : h.startsWith(rx) ? (s.var.push(d), l.push(nx), o.push(h)) : (s.number.push(d), l.push(xf), o.push(parseFloat(h))), ++d, Cf)).split(Cf); return { values: o, split: f, indexes: s, types: l } } function bf(t) { return Ro(t).values } function kf(t) { const { split: r, types: o } = Ro(t), s = r.length; return l => { let d = ""; for (let u = 0; u < s; u++)if (d += r[u], l[u] !== void 0) { const f = o[u]; f === xf ? d += Po(l[u]) : f === Sf ? d += ot.transform(l[u]) : d += l[u] } return d } } const ix = t => typeof t == "number" ? 0 : t; function sx(t) { const r = bf(t); return kf(t)(r.map(ix)) } const Tn = { test: tx, parse: bf, createTransformer: kf, getAnimatableNone: sx }, ax = new Set(["brightness", "contrast", "saturate", "opacity"]); function lx(t) { const [r, o] = t.slice(0, -1).split("("); if (r === "drop-shadow") return t; const [s] = o.match(za) || []; if (!s) return t; const l = o.replace(s, ""); let d = ax.has(r) ? 1 : 0; return s !== o && (d *= 100), r + "(" + d + l + ")" } const ux = /\b([a-z-]*)\(.*?\)/gu, ll = { ...Tn, getAnimatableNone: t => { const r = t.match(ux); return r ? r.map(lx).join(" ") : t } }, cx = { ...Ba, color: ot, backgroundColor: ot, outlineColor: ot, fill: ot, stroke: ot, borderColor: ot, borderTopColor: ot, borderRightColor: ot, borderBottomColor: ot, borderLeftColor: ot, filter: ll, WebkitFilter: ll }, ul = t => cx[t]; function Pf(t, r) { let o = ul(t); return o !== ll && (o = Tn), o.getAnimatableNone ? o.getAnimatableNone(r) : void 0 } const dx = new Set(["auto", "none", "0"]); function fx(t, r, o) { let s = 0, l; for (; s < t.length && !l;) { const d = t[s]; typeof d == "string" && !dx.has(d) && Ro(d).values.length && (l = t[s]), s++ } if (l && o) for (const d of r) t[d] = Pf(o, l) } class Ef extends ol { constructor(r, o, s, l, d) { super(r, o, s, l, d, !0) } readKeyframes() { const { unresolvedKeyframes: r, element: o, name: s } = this; if (!o || !o.current) return; super.readKeyframes(); for (let h = 0; h < r.length; h++) { let m = r[h]; if (typeof m == "string" && (m = m.trim(), Ua(m))) { const v = cf(m, o.current); v !== void 0 && (r[h] = v), h === r.length - 1 && (this.finalKeyframe = m) } } if (this.resolveNoneKeyframes(), !Yw.has(s) || r.length !== 2) return; const [l, d] = r, u = gf(l), f = gf(d); if (u !== f) if (df(u) && df(f)) for (let h = 0; h < r.length; h++) { const m = r[h]; typeof m == "string" && (r[h] = parseFloat(m)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { const { unresolvedKeyframes: r, name: o } = this, s = []; for (let l = 0; l < r.length; l++)Hw(r[l]) && s.push(l); s.length && fx(r, s, o) } measureInitialState() { const { element: r, unresolvedKeyframes: o, name: s } = this; if (!r || !r.current) return; s === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Tr[s](r.measureViewportBox(), window.getComputedStyle(r.current)), o[0] = this.measuredOrigin; const l = o[o.length - 1]; l !== void 0 && r.getValue(s, l).jump(l, !1) } measureEndState() { var r; const { element: o, name: s, unresolvedKeyframes: l } = this; if (!o || !o.current) return; const d = o.getValue(s); d && d.jump(this.measuredOrigin, !1); const u = l.length - 1, f = l[u]; l[u] = Tr[s](o.measureViewportBox(), window.getComputedStyle(o.current)), f !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = f), !((r = this.removedTransforms) === null || r === void 0) && r.length && this.removedTransforms.forEach(([h, m]) => { o.getValue(h).set(m) }), this.resolveNoneKeyframes() } } function Tf(t) { let r; return () => (r === void 0 && (r = t()), r) } let Hi; function px() { Hi = void 0 } const sn = { now: () => (Hi === void 0 && sn.set(Ze.isProcessing || N0.useManualTiming ? Ze.timestamp : performance.now()), Hi), set: t => { Hi = t, queueMicrotask(px) } }, Rf = (t, r) => r === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && (Tn.test(t) || t === "0") && !t.startsWith("url(")); function hx(t) { const r = t[0]; if (t.length === 1) return !0; for (let o = 0; o < t.length; o++)if (t[o] !== r) return !0 } function mx(t, r, o, s) { const l = t[0]; if (l === null) return !1; if (r === "display" || r === "visibility") return !0; const d = t[t.length - 1], u = Rf(l, r), f = Rf(d, r); return !u || !f ? !1 : hx(t) || o === "spring" && s } const gx = 40; class Af { constructor({ autoplay: r = !0, delay: o = 0, type: s = "keyframes", repeat: l = 0, repeatDelay: d = 0, repeatType: u = "loop", ...f }) { this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = sn.now(), this.options = { autoplay: r, delay: o, type: s, repeat: l, repeatDelay: d, repeatType: u, ...f }, this.updateFinishedPromise() } calcStartTime() { return this.resolvedAt ? this.resolvedAt - this.createdAt > gx ? this.resolvedAt : this.createdAt : this.createdAt } get resolved() { return !this._resolved && !this.hasAttemptedResolve && Zw(), this._resolved } onKeyframesResolved(r, o) { this.resolvedAt = sn.now(), this.hasAttemptedResolve = !0; const { name: s, type: l, velocity: d, delay: u, onComplete: f, onUpdate: h, isGenerator: m } = this.options; if (!m && !mx(r, s, l, d)) if (u) this.options.duration = 0; else { h?.($i(r, this.options, o)), f?.(), this.resolveFinishedPromise(); return } const v = this.initPlayback(r, o); v !== !1 && (this._resolved = { keyframes: r, finalKeyframe: o, ...v }, this.onPostResolved()) } onPostResolved() { } then(r, o) { return this.currentFinishedPromise.then(r, o) } updateFinishedPromise() { this.currentFinishedPromise = new Promise(r => { this.resolveFinishedPromise = r }) } } function Nf(t, r) { return r ? t * (1e3 / r) : 0 } const vx = 5; function Mf(t, r, o) { const s = Math.max(r - vx, 0); return Nf(o - t(s), r - s) } const cl = .001, yx = .01, Lf = 10, wx = .05, xx = 1; function Sx({ duration: t = 800, bounce: r = .25, velocity: o = 0, mass: s = 1 }) { let l, d; B0(t <= $t(Lf)); let u = 1 - r; u = kn(wx, xx, u), t = kn(yx, Lf, on(t)), u < 1 ? (l = m => { const v = m * u, g = v * t, x = v - o, C = dl(m, u), b = Math.exp(-g); return cl - x / C * b }, d = m => { const g = m * u * t, x = g * o + o, C = Math.pow(u, 2) * Math.pow(m, 2) * t, b = Math.exp(-g), S = dl(Math.pow(m, 2), u); return (-l(m) + cl > 0 ? -1 : 1) * ((x - C) * b) / S }) : (l = m => { const v = Math.exp(-m * t), g = (m - o) * t + 1; return -cl + v * g }, d = m => { const v = Math.exp(-m * t), g = (o - m) * (t * t); return v * g }); const f = 5 / t, h = bx(l, d, f); if (t = $t(t), isNaN(h)) return { stiffness: 100, damping: 10, duration: t }; { const m = Math.pow(h, 2) * s; return { stiffness: m, damping: u * 2 * Math.sqrt(s * m), duration: t } } } const Cx = 12; function bx(t, r, o) { let s = o; for (let l = 1; l < Cx; l++)s = s - t(s) / r(s); return s } function dl(t, r) { return t * Math.sqrt(1 - r * r) } const kx = ["duration", "bounce"], Px = ["stiffness", "damping", "mass"]; function Df(t, r) { return r.some(o => t[o] !== void 0) } function Ex(t) { let r = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...t }; if (!Df(t, Px) && Df(t, kx)) { const o = Sx(t); r = { ...r, ...o, mass: 1 }, r.isResolvedFromDuration = !0 } return r } function jf({ keyframes: t, restDelta: r, restSpeed: o, ...s }) { const l = t[0], d = t[t.length - 1], u = { done: !1, value: l }, { stiffness: f, damping: h, mass: m, duration: v, velocity: g, isResolvedFromDuration: x } = Ex({ ...s, velocity: -on(s.velocity || 0) }), C = g || 0, b = h / (2 * Math.sqrt(f * m)), S = d - l, P = on(Math.sqrt(f / m)), R = Math.abs(S) < 5; o || (o = R ? .01 : 2), r || (r = R ? .005 : .5); let N; if (b < 1) { const M = dl(P, b); N = j => { const I = Math.exp(-b * P * j); return d - I * ((C + b * P * S) / M * Math.sin(M * j) + S * Math.cos(M * j)) } } else if (b === 1) N = M => d - Math.exp(-P * M) * (S + (C + P * S) * M); else { const M = P * Math.sqrt(b * b - 1); N = j => { const I = Math.exp(-b * P * j), H = Math.min(M * j, 300); return d - I * ((C + b * P * S) * Math.sinh(H) + M * S * Math.cosh(H)) / M } } return { calculatedDuration: x && v || null, next: M => { const j = N(M); if (x) u.done = M >= v; else { let I = 0; b < 1 && (I = M === 0 ? $t(C) : Mf(N, M, j)); const H = Math.abs(I) <= o, $ = Math.abs(d - j) <= r; u.done = H && $ } return u.value = u.done ? d : j, u } } } function Of({ keyframes: t, velocity: r = 0, power: o = .8, timeConstant: s = 325, bounceDamping: l = 10, bounceStiffness: d = 500, modifyTarget: u, min: f, max: h, restDelta: m = .5, restSpeed: v }) { const g = t[0], x = { done: !1, value: g }, C = W => f !== void 0 && W < f || h !== void 0 && W > h, b = W => f === void 0 ? h : h === void 0 || Math.abs(f - W) < Math.abs(h - W) ? f : h; let S = o * r; const P = g + S, R = u === void 0 ? P : u(P); R !== P && (S = R - g); const N = W => -S * Math.exp(-W / s), M = W => R + N(W), j = W => { const le = N(W), oe = M(W); x.done = Math.abs(le) <= m, x.value = x.done ? R : oe }; let I, H; const $ = W => { C(x.value) && (I = W, H = jf({ keyframes: [x.value, b(x.value)], velocity: Mf(M, W, x.value), damping: l, stiffness: d, restDelta: m, restSpeed: v })) }; return $(0), { calculatedDuration: null, next: W => { let le = !1; return !H && I === void 0 && (le = !0, j(W), $(W)), I !== void 0 && W >= I ? H.next(W - I) : (!le && j(W), x) } } } const _f = (t, r, o) => (((1 - 3 * o + 3 * r) * t + (3 * o - 6 * r)) * t + 3 * r) * t, Tx = 1e-7, Rx = 12; function Ax(t, r, o, s, l) { let d, u, f = 0; do u = r + (o - r) / 2, d = _f(u, s, l) - t, d > 0 ? o = u : r = u; while (Math.abs(d) > Tx && ++f < Rx); return u } function Ao(t, r, o, s) { if (t === r && o === s) return qe; const l = d => Ax(d, 0, 1, t, o); return d => d === 0 || d === 1 ? d : _f(l(d), r, s) } const Nx = Ao(.42, 0, 1, 1), Mx = Ao(0, 0, .58, 1), If = Ao(.42, 0, .58, 1), Lx = t => Array.isArray(t) && typeof t[0] != "number", Vf = t => r => r <= .5 ? t(2 * r) / 2 : (2 - t(2 * (1 - r))) / 2, Ff = t => r => 1 - t(1 - r), fl = t => 1 - Math.sin(Math.acos(t)), zf = Ff(fl), Dx = Vf(fl), Bf = Ao(.33, 1.53, .69, .99), pl = Ff(Bf), jx = Vf(pl), Ox = { linear: qe, easeIn: Nx, easeInOut: If, easeOut: Mx, circIn: fl, circInOut: Dx, circOut: zf, backIn: pl, backInOut: jx, backOut: Bf, anticipate: t => (t *= 2) < 1 ? .5 * pl(t) : .5 * (2 - Math.pow(2, -10 * (t - 1))) }, Uf = t => { if (Array.isArray(t)) { Ld(t.length === 4); const [r, o, s, l] = t; return Ao(r, o, s, l) } else if (typeof t == "string") return Ox[t]; return t }, No = (t, r, o) => { const s = r - t; return s === 0 ? 1 : (o - t) / s }, je = (t, r, o) => t + (r - t) * o; function hl(t, r, o) { return o < 0 && (o += 1), o > 1 && (o -= 1), o < 1 / 6 ? t + (r - t) * 6 * o : o < 1 / 2 ? r : o < 2 / 3 ? t + (r - t) * (2 / 3 - o) * 6 : t } function _x({ hue: t, saturation: r, lightness: o, alpha: s }) { t /= 360, r /= 100, o /= 100; let l = 0, d = 0, u = 0; if (!r) l = d = u = o; else { const f = o < .5 ? o * (1 + r) : o + r - o * r, h = 2 * o - f; l = hl(h, f, t + 1 / 3), d = hl(h, f, t), u = hl(h, f, t - 1 / 3) } return { red: Math.round(l * 255), green: Math.round(d * 255), blue: Math.round(u * 255), alpha: s } } function Ki(t, r) { return o => o > 0 ? r : t } const ml = (t, r, o) => { const s = t * t, l = o * (r * r - s) + s; return l < 0 ? 0 : Math.sqrt(l) }, Ix = [al, nr, Rr], Vx = t => Ix.find(r => r.test(t)); function Wf(t) { const r = Vx(t); if (!r) return !1; let o = r.parse(t); return r === Rr && (o = _x(o)), o } const $f = (t, r) => { const o = Wf(t), s = Wf(r); if (!o || !s) return Ki(t, r); const l = { ...o }; return d => (l.red = ml(o.red, s.red, d), l.green = ml(o.green, s.green, d), l.blue = ml(o.blue, s.blue, d), l.alpha = je(o.alpha, s.alpha, d), nr.transform(l)) }, gl = new Set(["none", "hidden"]); function Fx(t, r) { return gl.has(t) ? o => o <= 0 ? t : r : o => o >= 1 ? r : t } function zx(t, r) { return o => je(t, r, o) } function vl(t) { return typeof t == "number" ? zx : typeof t == "string" ? Ua(t) ? Ki : ot.test(t) ? $f : Wx : Array.isArray(t) ? Hf : typeof t == "object" ? ot.test(t) ? $f : Bx : Ki } function Hf(t, r) { const o = [...t], s = o.length, l = t.map((d, u) => vl(d)(d, r[u])); return d => { for (let u = 0; u < s; u++)o[u] = l[u](d); return o } } function Bx(t, r) { const o = { ...t, ...r }, s = {}; for (const l in o) t[l] !== void 0 && r[l] !== void 0 && (s[l] = vl(t[l])(t[l], r[l])); return l => { for (const d in s) o[d] = s[d](l); return o } } function Ux(t, r) { var o; const s = [], l = { color: 0, var: 0, number: 0 }; for (let d = 0; d < r.values.length; d++) { const u = r.types[d], f = t.indexes[u][l[u]], h = (o = t.values[f]) !== null && o !== void 0 ? o : 0; s[d] = h, l[u]++ } return s } const Wx = (t, r) => { const o = Tn.createTransformer(r), s = Ro(t), l = Ro(r); return s.indexes.var.length === l.indexes.var.length && s.indexes.color.length === l.indexes.color.length && s.indexes.number.length >= l.indexes.number.length ? gl.has(t) && !l.values.length || gl.has(r) && !s.values.length ? Fx(t, r) : rn(Hf(Ux(s, l), l.values), o) : Ki(t, r) }; function Kf(t, r, o) { return typeof t == "number" && typeof r == "number" && typeof o == "number" ? je(t, r, o) : vl(t)(t, r) } function $x(t, r, o) { const s = [], l = o || Kf, d = t.length - 1; for (let u = 0; u < d; u++) { let f = l(t[u], t[u + 1]); if (r) { const h = Array.isArray(r) ? r[u] || qe : r; f = rn(h, f) } s.push(f) } return s } function Hx(t, r, { clamp: o = !0, ease: s, mixer: l } = {}) { const d = t.length; if (Ld(d === r.length), d === 1) return () => r[0]; if (d === 2 && t[0] === t[1]) return () => r[1]; t[0] > t[d - 1] && (t = [...t].reverse(), r = [...r].reverse()); const u = $x(r, s, l), f = u.length, h = m => { let v = 0; if (f > 1) for (; v < t.length - 2 && !(m < t[v + 1]); v++); const g = No(t[v], t[v + 1], m); return u[v](g) }; return o ? m => h(kn(t[0], t[d - 1], m)) : h } function Kx(t, r) { const o = t[t.length - 1]; for (let s = 1; s <= r; s++) { const l = No(0, r, s); t.push(je(o, 1, l)) } } function Gx(t) { const r = [0]; return Kx(r, t.length - 1), r } function Yx(t, r) { return t.map(o => o * r) } function Xx(t, r) { return t.map(() => r || If).splice(0, t.length - 1) } function Gi({ duration: t = 300, keyframes: r, times: o, ease: s = "easeInOut" }) { const l = Lx(s) ? s.map(Uf) : Uf(s), d = { done: !1, value: r[0] }, u = Yx(o && o.length === r.length ? o : Gx(r), t), f = Hx(u, r, { ease: Array.isArray(l) ? l : Xx(r, l) }); return { calculatedDuration: t, next: h => (d.value = f(h), d.done = h >= t, d) } } const Gf = 2e4; function Qx(t) { let r = 0; const o = 50; let s = t.next(r); for (; !s.done && r < Gf;)r += o, s = t.next(r); return r >= Gf ? 1 / 0 : r } const qx = t => { const r = ({ timestamp: o }) => t(o); return { start: () => Te.update(r, !0), stop: () => en(r), now: () => Ze.isProcessing ? Ze.timestamp : sn.now() } }, Zx = { decay: Of, inertia: Of, tween: Gi, keyframes: Gi, spring: jf }, Jx = t => t / 100; class yl extends Af { constructor(r) { super(r), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.teardown(); const { onStop: h } = this.options; h && h() }; const { name: o, motionValue: s, element: l, keyframes: d } = this.options, u = l?.KeyframeResolver || ol, f = (h, m) => this.onKeyframesResolved(h, m); this.resolver = new u(d, f, o, s, l), this.resolver.scheduleResolve() } initPlayback(r) { const { type: o = "keyframes", repeat: s = 0, repeatDelay: l = 0, repeatType: d, velocity: u = 0 } = this.options, f = Zx[o] || Gi; let h, m; f !== Gi && typeof r[0] != "number" && (h = rn(Jx, Kf(r[0], r[1])), r = [0, 100]); const v = f({ ...this.options, keyframes: r }); d === "mirror" && (m = f({ ...this.options, keyframes: [...r].reverse(), velocity: -u })), v.calculatedDuration === null && (v.calculatedDuration = Qx(v)); const { calculatedDuration: g } = v, x = g + l, C = x * (s + 1) - l; return { generator: v, mirroredGenerator: m, mapPercentToKeyframes: h, calculatedDuration: g, resolvedDuration: x, totalDuration: C } } onPostResolved() { const { autoplay: r = !0 } = this.options; this.play(), this.pendingPlayState === "paused" || !r ? this.pause() : this.state = this.pendingPlayState } tick(r, o = !1) { const { resolved: s } = this; if (!s) { const { keyframes: W } = this.options; return { done: !0, value: W[W.length - 1] } } const { finalKeyframe: l, generator: d, mirroredGenerator: u, mapPercentToKeyframes: f, keyframes: h, calculatedDuration: m, totalDuration: v, resolvedDuration: g } = s; if (this.startTime === null) return d.next(0); const { delay: x, repeat: C, repeatType: b, repeatDelay: S, onUpdate: P } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, r) : this.speed < 0 && (this.startTime = Math.min(r - v / this.speed, this.startTime)), o ? this.currentTime = r : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(r - this.startTime) * this.speed; const R = this.currentTime - x * (this.speed >= 0 ? 1 : -1), N = this.speed >= 0 ? R < 0 : R > v; this.currentTime = Math.max(R, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = v); let M = this.currentTime, j = d; if (C) { const W = Math.min(this.currentTime, v) / g; let le = Math.floor(W), oe = W % 1; !oe && W >= 1 && (oe = 1), oe === 1 && le--, le = Math.min(le, C + 1), !!(le % 2) && (b === "reverse" ? (oe = 1 - oe, S && (oe -= S / g)) : b === "mirror" && (j = u)), M = kn(0, 1, oe) * g } const I = N ? { done: !1, value: h[0] } : j.next(M); f && (I.value = f(I.value)); let { done: H } = I; !N && m !== null && (H = this.speed >= 0 ? this.currentTime >= v : this.currentTime <= 0); const $ = this.holdTime === null && (this.state === "finished" || this.state === "running" && H); return $ && l !== void 0 && (I.value = $i(h, this.options, l)), P && P(I.value), $ && this.finish(), I } get duration() { const { resolved: r } = this; return r ? on(r.calculatedDuration) : 0 } get time() { return on(this.currentTime) } set time(r) { r = $t(r), this.currentTime = r, this.holdTime !== null || this.speed === 0 ? this.holdTime = r : this.driver && (this.startTime = this.driver.now() - r / this.speed) } get speed() { return this.playbackSpeed } set speed(r) { const o = this.playbackSpeed !== r; this.playbackSpeed = r, o && (this.time = on(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) { this.pendingPlayState = "running"; return } if (this.isStopped) return; const { driver: r = qx, onPlay: o, startTime: s } = this.options; this.driver || (this.driver = r(d => this.tick(d))), o && o(); const l = this.driver.now(); this.holdTime !== null ? this.startTime = l - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = l) : this.startTime = s ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var r; if (!this._resolved) { this.pendingPlayState = "paused"; return } this.state = "paused", this.holdTime = (r = this.currentTime) !== null && r !== void 0 ? r : 0 } complete() { this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; const { onComplete: r } = this.options; r && r() } cancel() { this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(r) { return this.startTime = 0, this.tick(r, !0) } } const Yf = t => Array.isArray(t) && typeof t[0] == "number"; function Xf(t) { return !!(!t || typeof t == "string" && t in wl || Yf(t) || Array.isArray(t) && t.every(Xf)) } const Mo = ([t, r, o, s]) => `cubic-bezier(${t}, ${r}, ${o}, ${s})`, wl = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: Mo([0, .65, .55, 1]), circOut: Mo([.55, 0, 1, .45]), backIn: Mo([.31, .01, .66, -.59]), backOut: Mo([.33, 1.53, .69, .99]) }; function e1(t) { return Qf(t) || wl.easeOut } function Qf(t) { if (t) return Yf(t) ? Mo(t) : Array.isArray(t) ? t.map(e1) : wl[t] } function t1(t, r, o, { delay: s = 0, duration: l = 300, repeat: d = 0, repeatType: u = "loop", ease: f, times: h } = {}) { const m = { [r]: o }; h && (m.offset = h); const v = Qf(f); return Array.isArray(v) && (m.easing = v), t.animate(m, { delay: s, duration: l, easing: Array.isArray(v) ? "linear" : v, fill: "both", iterations: d + 1, direction: u === "reverse" ? "alternate" : "normal" }) } const n1 = Tf(() => Object.hasOwnProperty.call(Element.prototype, "animate")), Yi = 10, r1 = 2e4; function o1(t) { return t.type === "spring" || !Xf(t.ease) } function i1(t, r) { const o = new yl({ ...r, keyframes: t, repeat: 0, delay: 0, isGenerator: !0 }); let s = { done: !1, value: t[0] }; const l = []; let d = 0; for (; !s.done && d < r1;)s = o.sample(d), l.push(s.value), d += Yi; return { times: void 0, keyframes: l, duration: d - Yi, ease: "linear" } } class qf extends Af { constructor(r) { super(r); const { name: o, motionValue: s, element: l, keyframes: d } = this.options; this.resolver = new Ef(d, (u, f) => this.onKeyframesResolved(u, f), o, s, l), this.resolver.scheduleResolve() } initPlayback(r, o) { var s; let { duration: l = 300, times: d, ease: u, type: f, motionValue: h, name: m, startTime: v } = this.options; if (!(!((s = h.owner) === null || s === void 0) && s.current)) return !1; if (o1(this.options)) { const { onComplete: x, onUpdate: C, motionValue: b, element: S, ...P } = this.options, R = i1(r, P); r = R.keyframes, r.length === 1 && (r[1] = r[0]), l = R.duration, d = R.times, u = R.ease, f = "keyframes" } const g = t1(h.owner.current, m, r, { ...this.options, duration: l, times: d, ease: u }); return g.startTime = v ?? this.calcStartTime(), this.pendingTimeline ? (g.timeline = this.pendingTimeline, this.pendingTimeline = void 0) : g.onfinish = () => { const { onComplete: x } = this.options; h.set($i(r, this.options, o)), x && x(), this.cancel(), this.resolveFinishedPromise() }, { animation: g, duration: l, times: d, type: f, ease: u, keyframes: r } } get duration() { const { resolved: r } = this; if (!r) return 0; const { duration: o } = r; return on(o) } get time() { const { resolved: r } = this; if (!r) return 0; const { animation: o } = r; return on(o.currentTime || 0) } set time(r) { const { resolved: o } = this; if (!o) return; const { animation: s } = o; s.currentTime = $t(r) } get speed() { const { resolved: r } = this; if (!r) return 1; const { animation: o } = r; return o.playbackRate } set speed(r) { const { resolved: o } = this; if (!o) return; const { animation: s } = o; s.playbackRate = r } get state() { const { resolved: r } = this; if (!r) return "idle"; const { animation: o } = r; return o.playState } get startTime() { const { resolved: r } = this; if (!r) return null; const { animation: o } = r; return o.startTime } attachTimeline(r) { if (!this._resolved) this.pendingTimeline = r; else { const { resolved: o } = this; if (!o) return qe; const { animation: s } = o; s.timeline = r, s.onfinish = null } return qe } play() { if (this.isStopped) return; const { resolved: r } = this; if (!r) return; const { animation: o } = r; o.playState === "finished" && this.updateFinishedPromise(), o.play() } pause() { const { resolved: r } = this; if (!r) return; const { animation: o } = r; o.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.resolveFinishedPromise(), this.updateFinishedPromise(); const { resolved: r } = this; if (!r) return; const { animation: o, keyframes: s, duration: l, type: d, ease: u, times: f } = r; if (o.playState === "idle" || o.playState === "finished") return; if (this.time) { const { motionValue: m, onUpdate: v, onComplete: g, element: x, ...C } = this.options, b = new yl({ ...C, keyframes: s, duration: l, type: d, ease: u, times: f, isGenerator: !0 }), S = $t(this.time); m.setWithVelocity(b.sample(S - Yi).value, b.sample(S).value, Yi) } const { onStop: h } = this.options; h && h(), this.cancel() } complete() { const { resolved: r } = this; r && r.animation.finish() } cancel() { const { resolved: r } = this; r && r.animation.cancel() } static supports(r) { const { motionValue: o, name: s, repeatDelay: l, repeatType: d, damping: u, type: f } = r; return n1() && s && Yd.has(s) && o && o.owner && o.owner.current instanceof HTMLElement && !o.owner.getProps().onUpdate && !l && d !== "mirror" && u !== 0 && f !== "inertia" } } function s1(t, r) { let o; const s = () => { const { currentTime: l } = r, u = (l === null ? 0 : l.value) / 100; o !== u && t(u), o = u }; return Te.update(s, !0), () => en(s) } const a1 = Tf(() => window.ScrollTimeline !== void 0); class l1 { constructor(r) { this.stop = () => this.runAll("stop"), this.animations = r.filter(Boolean) } then(r, o) { return Promise.all(this.animations).then(r).catch(o) } getAll(r) { return this.animations[0][r] } setAll(r, o) { for (let s = 0; s < this.animations.length; s++)this.animations[s][r] = o } attachTimeline(r) { const o = this.animations.map(s => { if (a1() && s.attachTimeline) s.attachTimeline(r); else return s.pause(), s1(l => { s.time = s.duration * l }, r) }); return () => { o.forEach((s, l) => { s && s(), this.animations[l].stop() }) } } get time() { return this.getAll("time") } set time(r) { this.setAll("time", r) } get speed() { return this.getAll("speed") } set speed(r) { this.setAll("speed", r) } get startTime() { return this.getAll("startTime") } get duration() { let r = 0; for (let o = 0; o < this.animations.length; o++)r = Math.max(r, this.animations[o].duration); return r } runAll(r) { this.animations.forEach(o => o[r]()) } play() { this.runAll("play") } pause() { this.runAll("pause") } cancel() { this.runAll("cancel") } complete() { this.runAll("complete") } } const xl = (t, r, o, s = {}, l, d, u) => f => { const h = tl(s, t) || {}, m = h.delay || s.delay || 0; let { elapsed: v = 0 } = s; v = v - $t(m); let g = { keyframes: Array.isArray(o) ? o : [null, o], ease: "easeOut", velocity: r.getVelocity(), ...h, delay: -v, onUpdate: C => { r.set(C), h.onUpdate && h.onUpdate(C) }, onComplete: () => { f(), h.onComplete && h.onComplete(), u && u() }, onStop: u, name: t, motionValue: r, element: d ? void 0 : l }; Ww(h) || (g = { ...g, ...Uw(t, g) }), g.duration && (g.duration = $t(g.duration)), g.repeatDelay && (g.repeatDelay = $t(g.repeatDelay)), g.from !== void 0 && (g.keyframes[0] = g.from); let x = !1; if ((g.type === !1 || g.duration === 0 && !g.repeatDelay) && (g.duration = 0, g.delay === 0 && (x = !0)), x && !d && r.get() !== void 0) { const C = $i(g.keyframes, h); if (C !== void 0) return Te.update(() => { g.onUpdate(C), g.onComplete() }), new l1([]) } return !d && qf.supports(g) ? new qf(g) : new yl(g) }; class Sl { constructor() { this.subscriptions = [] } add(r) { return zi(this.subscriptions, r), () => Bi(this.subscriptions, r) } notify(r, o, s) { const l = this.subscriptions.length; if (l) if (l === 1) this.subscriptions[0](r, o, s); else for (let d = 0; d < l; d++) { const u = this.subscriptions[d]; u && u(r, o, s) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const Zf = 30, u1 = t => !isNaN(parseFloat(t)); class Jf { constructor(r, o = {}) { this.version = "11.3.29", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (s, l = !0) => { const d = sn.now(); this.updatedAt !== d && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(s), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), l && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(r), this.owner = o.owner } setCurrent(r) { this.current = r, this.updatedAt = sn.now(), this.canTrackVelocity === null && r !== void 0 && (this.canTrackVelocity = u1(this.current)) } setPrevFrameValue(r = this.current) { this.prevFrameValue = r, this.prevUpdatedAt = this.updatedAt } onChange(r) { return this.on("change", r) } on(r, o) { this.events[r] || (this.events[r] = new Sl); const s = this.events[r].add(o); return r === "change" ? () => { s(), Te.read(() => { this.events.change.getSize() || this.stop() }) } : s } clearListeners() { for (const r in this.events) this.events[r].clear() } attach(r, o) { this.passiveEffect = r, this.stopPassiveEffect = o } set(r, o = !0) { !o || !this.passiveEffect ? this.updateAndNotify(r, o) : this.passiveEffect(r, this.updateAndNotify) } setWithVelocity(r, o, s) { this.set(o), this.prev = void 0, this.prevFrameValue = r, this.prevUpdatedAt = this.updatedAt - s } jump(r, o = !0) { this.updateAndNotify(r), this.prev = r, this.prevUpdatedAt = this.prevFrameValue = void 0, o && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const r = sn.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || r - this.updatedAt > Zf) return 0; const o = Math.min(this.updatedAt - this.prevUpdatedAt, Zf); return Nf(parseFloat(this.current) - parseFloat(this.prevFrameValue), o) } start(r) { return this.stop(), new Promise(o => { this.hasAnimated = !0, this.animation = r(o), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function Lo(t, r) { return new Jf(t, r) } function c1(t, r, o) { t.hasValue(r) ? t.getValue(r).set(o) : t.addValue(r, Lo(o)) } function d1(t, r) { const o = Wi(t, r); let { transitionEnd: s = {}, transition: l = {}, ...d } = o || {}; d = { ...d, ...s }; for (const u in d) { const f = yw(d[u]); c1(t, u, f) } } function ep(t) { return t.getProps()[kd] } class f1 extends Jf { constructor() { super(...arguments), this.output = [], this.counts = new Map } add(r) { const o = Xd(r); if (!o) return; const s = this.counts.get(o) || 0; this.counts.set(o, s + 1), s === 0 && (this.output.push(o), this.update()); let l = !1; return () => { if (l) return; l = !0; const d = this.counts.get(o) - 1; this.counts.set(o, d), d === 0 && (Bi(this.output, o), this.update()) } } update() { this.set(this.output.length ? this.output.join(", ") : "auto") } } function p1(t) { return !!(rt(t) && t.add) } function Cl(t, r) { var o; if (!t.applyWillChange) return; let s = t.getValue("willChange"); if (!s && !(!((o = t.props.style) === null || o === void 0) && o.willChange) && (s = new f1("auto"), t.addValue("willChange", s)), p1(s)) return s.add(r) } function h1({ protectedKeys: t, needsAnimating: r }, o) { const s = t.hasOwnProperty(o) && r[o] !== !0; return r[o] = !1, s } function tp(t, r, { delay: o = 0, transitionOverride: s, type: l } = {}) { var d; let { transition: u = t.getDefaultTransition(), transitionEnd: f, ...h } = r; s && (u = s); const m = [], v = l && t.animationState && t.animationState.getState()[l]; for (const g in h) { const x = t.getValue(g, (d = t.latestValues[g]) !== null && d !== void 0 ? d : null), C = h[g]; if (C === void 0 || v && h1(v, g)) continue; const b = { delay: o, ...tl(u || {}, g) }; let S = !1; if (window.MotionHandoffAnimation) { const R = ep(t); if (R) { const N = window.MotionHandoffAnimation(R, g, Te); N !== null && (b.startTime = N, S = !0) } } x.start(xl(g, x, C, t.shouldReduceMotion && bn.has(g) ? { type: !1 } : b, t, S, Cl(t, g))); const P = x.animation; P && m.push(P) } return f && Promise.all(m).then(() => { Te.update(() => { f && d1(t, f) }) }), m } function bl(t, r, o = {}) { var s; const l = Wi(t, r, o.type === "exit" ? (s = t.presenceContext) === null || s === void 0 ? void 0 : s.custom : void 0); let { transition: d = t.getDefaultTransition() || {} } = l || {}; o.transitionOverride && (d = o.transitionOverride); const u = l ? () => Promise.all(tp(t, l, o)) : () => Promise.resolve(), f = t.variantChildren && t.variantChildren.size ? (m = 0) => { const { delayChildren: v = 0, staggerChildren: g, staggerDirection: x } = d; return m1(t, r, v + m, g, x, o) } : () => Promise.resolve(), { when: h } = d; if (h) { const [m, v] = h === "beforeChildren" ? [u, f] : [f, u]; return m().then(() => v()) } else return Promise.all([u(), f(o.delay)]) } function m1(t, r, o = 0, s = 0, l = 1, d) { const u = [], f = (t.variantChildren.size - 1) * s, h = l === 1 ? (m = 0) => m * s : (m = 0) => f - m * s; return Array.from(t.variantChildren).sort(g1).forEach((m, v) => { m.notify("AnimationStart", r), u.push(bl(m, r, { ...d, delay: o + h(v) }).then(() => m.notify("AnimationComplete", r))) }), Promise.all(u) } function g1(t, r) { return t.sortNodePosition(r) } function v1(t, r, o = {}) { t.notify("AnimationStart", r); let s; if (Array.isArray(r)) { const l = r.map(d => bl(t, d, o)); s = Promise.all(l) } else if (typeof r == "string") s = bl(t, r, o); else { const l = typeof r == "function" ? Wi(t, r, o.custom) : r; s = Promise.all(tp(t, l, o)) } return s.then(() => { t.notify("AnimationComplete", r) }) } const y1 = [..._a].reverse(), w1 = _a.length; function x1(t) { return r => Promise.all(r.map(({ animation: o, options: s }) => v1(t, o, s))) } function S1(t) { let r = x1(t), o = np(), s = !0; const l = h => (m, v) => { var g; const x = Wi(t, v, h === "exit" ? (g = t.presenceContext) === null || g === void 0 ? void 0 : g.custom : void 0); if (x) { const { transition: C, transitionEnd: b, ...S } = x; m = { ...m, ...S, ...b } } return m }; function d(h) { r = h(t) } function u(h) { const m = t.getProps(), v = t.getVariantContext(!0) || {}, g = [], x = new Set; let C = {}, b = 1 / 0; for (let P = 0; P < w1; P++) { const R = y1[P], N = o[R], M = m[R] !== void 0 ? m[R] : v[R], j = So(M), I = R === h ? N.isActive : null; I === !1 && (b = P); let H = M === v[R] && M !== m[R] && j; if (H && s && t.manuallyAnimateOnMount && (H = !1), N.protectedKeys = { ...C }, !N.isActive && I === null || !M && !N.prevProp || Co(M) || typeof M == "boolean") continue; let W = C1(N.prevProp, M) || R === h && N.isActive && !H && j || P > b && j, le = !1; const oe = Array.isArray(M) ? M : [M]; let me = oe.reduce(l(R), {}); I === !1 && (me = {}); const { prevResolvedValues: Z = {} } = N, ge = { ...Z, ...me }, ne = J => { W = !0, x.has(J) && (le = !0, x.delete(J)), N.needsAnimating[J] = !0; const se = t.getValue(J); se && (se.liveStyle = !1) }; for (const J in ge) { const se = me[J], G = Z[J]; if (C.hasOwnProperty(J)) continue; let F = !1; Qa(se) && Qa(G) ? F = !af(se, G) : F = se !== G, F ? se != null ? ne(J) : x.add(J) : se !== void 0 && x.has(J) ? ne(J) : N.protectedKeys[J] = !0 } N.prevProp = M, N.prevResolvedValues = me, N.isActive && (C = { ...C, ...me }), s && t.blockInitialAnimation && (W = !1), W && (!H || le) && g.push(...oe.map(J => ({ animation: J, options: { type: R } }))) } if (x.size) { const P = {}; x.forEach(R => { const N = t.getBaseTarget(R), M = t.getValue(R); M && (M.liveStyle = !0), P[R] = N ?? null }), g.push({ animation: P }) } let S = !!g.length; return s && (m.initial === !1 || m.initial === m.animate) && !t.manuallyAnimateOnMount && (S = !1), s = !1, S ? r(g) : Promise.resolve() } function f(h, m) { var v; if (o[h].isActive === m) return Promise.resolve(); (v = t.variantChildren) === null || v === void 0 || v.forEach(x => { var C; return (C = x.animationState) === null || C === void 0 ? void 0 : C.setActive(h, m) }), o[h].isActive = m; const g = u(h); for (const x in o) o[x].protectedKeys = {}; return g } return { animateChanges: u, setActive: f, setAnimateFunction: d, getState: () => o, reset: () => { o = np(), s = !0 } } } function C1(t, r) { return typeof r == "string" ? r !== t : Array.isArray(r) ? !af(r, t) : !1 } function rr(t = !1) { return { isActive: t, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function np() { return { animate: rr(!0), whileInView: rr(), whileHover: rr(), whileTap: rr(), whileDrag: rr(), whileFocus: rr(), exit: rr() } } class b1 extends En { constructor(r) { super(r), r.animationState || (r.animationState = S1(r)) } updateAnimationControlsSubscription() { const { animate: r } = this.node.getProps(); Co(r) && (this.unmountControls = r.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: r } = this.node.getProps(), { animate: o } = this.node.prevProps || {}; r !== o && this.updateAnimationControlsSubscription() } unmount() { var r; this.node.animationState.reset(), (r = this.unmountControls) === null || r === void 0 || r.call(this) } } let k1 = 0; class P1 extends En { constructor() { super(...arguments), this.id = k1++ } update() { if (!this.node.presenceContext) return; const { isPresent: r, onExitComplete: o } = this.node.presenceContext, { isPresent: s } = this.node.prevPresenceContext || {}; if (!this.node.animationState || r === s) return; const l = this.node.animationState.setActive("exit", !r); o && !r && l.then(() => o(this.id)) } mount() { const { register: r } = this.node.presenceContext || {}; r && (this.unmount = r(this.id)) } unmount() { } } const E1 = { animation: { Feature: b1 }, exit: { Feature: P1 } }, rp = (t, r) => Math.abs(t - r); function T1(t, r) { const o = rp(t.x, r.x), s = rp(t.y, r.y); return Math.sqrt(o ** 2 + s ** 2) } class op { constructor(r, o, { transformPagePoint: s, contextWindow: l, dragSnapToOrigin: d = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const g = Pl(this.lastMoveEventInfo, this.history), x = this.startEvent !== null, C = T1(g.offset, { x: 0, y: 0 }) >= 3; if (!x && !C) return; const { point: b } = g, { timestamp: S } = Ze; this.history.push({ ...b, timestamp: S }); const { onStart: P, onMove: R } = this.handlers; x || (P && P(this.lastMoveEvent, g), this.startEvent = this.lastMoveEvent), R && R(this.lastMoveEvent, g) }, this.handlePointerMove = (g, x) => { this.lastMoveEvent = g, this.lastMoveEventInfo = kl(x, this.transformPagePoint), Te.update(this.updatePoint, !0) }, this.handlePointerUp = (g, x) => { this.end(); const { onEnd: C, onSessionEnd: b, resumeAnimation: S } = this.handlers; if (this.dragSnapToOrigin && S && S(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const P = Pl(g.type === "pointercancel" ? this.lastMoveEventInfo : kl(x, this.transformPagePoint), this.history); this.startEvent && C && C(g, P), b && b(g, P) }, !Zd(r)) return; this.dragSnapToOrigin = d, this.handlers = o, this.transformPagePoint = s, this.contextWindow = l || window; const u = Ui(r), f = kl(u, this.transformPagePoint), { point: h } = f, { timestamp: m } = Ze; this.history = [{ ...h, timestamp: m }]; const { onSessionStart: v } = o; v && v(r, Pl(f, this.history)), this.removeListeners = rn(nn(this.contextWindow, "pointermove", this.handlePointerMove), nn(this.contextWindow, "pointerup", this.handlePointerUp), nn(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(r) { this.handlers = r } end() { this.removeListeners && this.removeListeners(), en(this.updatePoint) } } function kl(t, r) { return r ? { point: r(t.point) } : t } function ip(t, r) { return { x: t.x - r.x, y: t.y - r.y } } function Pl({ point: t }, r) { return { point: t, delta: ip(t, sp(r)), offset: ip(t, R1(r)), velocity: A1(r, .1) } } function R1(t) { return t[0] } function sp(t) { return t[t.length - 1] } function A1(t, r) { if (t.length < 2) return { x: 0, y: 0 }; let o = t.length - 1, s = null; const l = sp(t); for (; o >= 0 && (s = t[o], !(l.timestamp - s.timestamp > $t(r)));)o--; if (!s) return { x: 0, y: 0 }; const d = on(l.timestamp - s.timestamp); if (d === 0) return { x: 0, y: 0 }; const u = { x: (l.x - s.x) / d, y: (l.y - s.y) / d }; return u.x === 1 / 0 && (u.x = 0), u.y === 1 / 0 && (u.y = 0), u } const ap = 1e-4, N1 = 1 - ap, M1 = 1 + ap, lp = .01, L1 = 0 - lp, D1 = 0 + lp; function vt(t) { return t.max - t.min } function j1(t, r, o) { return Math.abs(t - r) <= o } function up(t, r, o, s = .5) { t.origin = s, t.originPoint = je(r.min, r.max, t.origin), t.scale = vt(o) / vt(r), t.translate = je(o.min, o.max, t.origin) - t.originPoint, (t.scale >= N1 && t.scale <= M1 || isNaN(t.scale)) && (t.scale = 1), (t.translate >= L1 && t.translate <= D1 || isNaN(t.translate)) && (t.translate = 0) } function Do(t, r, o, s) { up(t.x, r.x, o.x, s ? s.originX : void 0), up(t.y, r.y, o.y, s ? s.originY : void 0) } function cp(t, r, o) { t.min = o.min + r.min, t.max = t.min + vt(r) } function O1(t, r, o) { cp(t.x, r.x, o.x), cp(t.y, r.y, o.y) } function dp(t, r, o) { t.min = r.min - o.min, t.max = t.min + vt(r) } function jo(t, r, o) { dp(t.x, r.x, o.x), dp(t.y, r.y, o.y) } function _1(t, { min: r, max: o }, s) { return r !== void 0 && t < r ? t = s ? je(r, t, s.min) : Math.max(t, r) : o !== void 0 && t > o && (t = s ? je(o, t, s.max) : Math.min(t, o)), t } function fp(t, r, o) { return { min: r !== void 0 ? t.min + r : void 0, max: o !== void 0 ? t.max + o - (t.max - t.min) : void 0 } } function I1(t, { top: r, left: o, bottom: s, right: l }) { return { x: fp(t.x, o, l), y: fp(t.y, r, s) } } function pp(t, r) { let o = r.min - t.min, s = r.max - t.max; return r.max - r.min < t.max - t.min && ([o, s] = [s, o]), { min: o, max: s } } function V1(t, r) { return { x: pp(t.x, r.x), y: pp(t.y, r.y) } } function F1(t, r) { let o = .5; const s = vt(t), l = vt(r); return l > s ? o = No(r.min, r.max - s, t.min) : s > l && (o = No(t.min, t.max - l, r.min)), kn(0, 1, o) } function z1(t, r) { const o = {}; return r.min !== void 0 && (o.min = r.min - t.min), r.max !== void 0 && (o.max = r.max - t.min), o } const El = .35; function B1(t = El) { return t === !1 ? t = 0 : t === !0 && (t = El), { x: hp(t, "left", "right"), y: hp(t, "top", "bottom") } } function hp(t, r, o) { return { min: mp(t, r), max: mp(t, o) } } function mp(t, r) { return typeof t == "number" ? t : t[r] || 0 } const gp = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), Ar = () => ({ x: gp(), y: gp() }), vp = () => ({ min: 0, max: 0 }), Fe = () => ({ x: vp(), y: vp() }); function kt(t) { return [t("x"), t("y")] } function yp({ top: t, left: r, right: o, bottom: s }) { return { x: { min: r, max: o }, y: { min: t, max: s } } } function U1({ x: t, y: r }) { return { top: r.min, right: t.max, bottom: r.max, left: t.min } } function W1(t, r) { if (!r) return t; const o = r({ x: t.left, y: t.top }), s = r({ x: t.right, y: t.bottom }); return { top: o.y, left: o.x, bottom: s.y, right: s.x } } function Tl(t) { return t === void 0 || t === 1 } function Rl({ scale: t, scaleX: r, scaleY: o }) { return !Tl(t) || !Tl(r) || !Tl(o) } function or(t) { return Rl(t) || wp(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY } function wp(t) { return xp(t.x) || xp(t.y) } function xp(t) { return t && t !== "0%" } function Xi(t, r, o) { const s = t - o, l = r * s; return o + l } function Sp(t, r, o, s, l) { return l !== void 0 && (t = Xi(t, l, s)), Xi(t, o, s) + r } function Al(t, r = 0, o = 1, s, l) { t.min = Sp(t.min, r, o, s, l), t.max = Sp(t.max, r, o, s, l) } function Cp(t, { x: r, y: o }) { Al(t.x, r.translate, r.scale, r.originPoint), Al(t.y, o.translate, o.scale, o.originPoint) } const bp = .999999999999, kp = 1.0000000000001; function $1(t, r, o, s = !1) { const l = o.length; if (!l) return; r.x = r.y = 1; let d, u; for (let f = 0; f < l; f++) { d = o[f], u = d.projectionDelta; const { visualElement: h } = d.options; h && h.props.style && h.props.style.display === "contents" || (s && d.options.layoutScroll && d.scroll && d !== d.root && Mr(t, { x: -d.scroll.offset.x, y: -d.scroll.offset.y }), u && (r.x *= u.x.scale, r.y *= u.y.scale, Cp(t, u)), s && or(d.latestValues) && Mr(t, d.latestValues)) } r.x < kp && r.x > bp && (r.x = 1), r.y < kp && r.y > bp && (r.y = 1) } function Nr(t, r) { t.min = t.min + r, t.max = t.max + r } function Pp(t, r, o, s, l = .5) { const d = je(t.min, t.max, l); Al(t, r, o, d, s) } function Mr(t, r) { Pp(t.x, r.x, r.scaleX, r.scale, r.originX), Pp(t.y, r.y, r.scaleY, r.scale, r.originY) } function Ep(t, r) { return yp(W1(t.getBoundingClientRect(), r)) } function H1(t, r, o) { const s = Ep(t, o), { scroll: l } = r; return l && (Nr(s.x, l.offset.x), Nr(s.y, l.offset.y)), s } const Tp = ({ current: t }) => t ? t.ownerDocument.defaultView : null, K1 = new WeakMap; class G1 { constructor(r) { this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Fe(), this.visualElement = r } start(r, { snapToCursor: o = !1 } = {}) { const { presenceContext: s } = this.visualElement; if (s && s.isPresent === !1) return; const l = v => { const { dragSnapToOrigin: g } = this.getProps(); g ? this.pauseAnimation() : this.stopAnimation(), o && this.snapToCursor(Ui(v, "page").point) }, d = (v, g) => { var x; const { drag: C, dragPropagation: b, onDragStart: S } = this.getProps(); if (C && !b && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = nf(C), !this.openGlobalLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), kt(R => { let N = this.getAxisMotionValue(R).get() || 0; if (Wt.test(N)) { const { projection: M } = this.visualElement; if (M && M.layout) { const j = M.layout.layoutBox[R]; j && (N = vt(j) * (parseFloat(N) / 100)) } } this.originPoint[R] = N }), S && Te.postRender(() => S(v, g)), (x = this.removeWillChange) === null || x === void 0 || x.call(this), this.removeWillChange = Cl(this.visualElement, "transform"); const { animationState: P } = this.visualElement; P && P.setActive("whileDrag", !0) }, u = (v, g) => { const { dragPropagation: x, dragDirectionLock: C, onDirectionLock: b, onDrag: S } = this.getProps(); if (!x && !this.openGlobalLock) return; const { offset: P } = g; if (C && this.currentDirection === null) { this.currentDirection = Y1(P), this.currentDirection !== null && b && b(this.currentDirection); return } this.updateAxis("x", g.point, P), this.updateAxis("y", g.point, P), this.visualElement.render(), S && S(v, g) }, f = (v, g) => this.stop(v, g), h = () => kt(v => { var g; return this.getAnimationState(v) === "paused" && ((g = this.getAxisMotionValue(v).animation) === null || g === void 0 ? void 0 : g.play()) }), { dragSnapToOrigin: m } = this.getProps(); this.panSession = new op(r, { onSessionStart: l, onStart: d, onMove: u, onSessionEnd: f, resumeAnimation: h }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: m, contextWindow: Tp(this.visualElement) }) } stop(r, o) { var s; (s = this.removeWillChange) === null || s === void 0 || s.call(this); const l = this.isDragging; if (this.cancel(), !l) return; const { velocity: d } = o; this.startAnimation(d); const { onDragEnd: u } = this.getProps(); u && Te.postRender(() => u(r, o)) } cancel() { this.isDragging = !1; const { projection: r, animationState: o } = this.visualElement; r && (r.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: s } = this.getProps(); !s && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), o && o.setActive("whileDrag", !1) } updateAxis(r, o, s) { const { drag: l } = this.getProps(); if (!s || !Qi(r, l, this.currentDirection)) return; const d = this.getAxisMotionValue(r); let u = this.originPoint[r] + s[r]; this.constraints && this.constraints[r] && (u = _1(u, this.constraints[r], this.elastic[r])), d.set(u) } resolveConstraints() { var r; const { dragConstraints: o, dragElastic: s } = this.getProps(), l = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (r = this.visualElement.projection) === null || r === void 0 ? void 0 : r.layout, d = this.constraints; o && kr(o) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : o && l ? this.constraints = I1(l.layoutBox, o) : this.constraints = !1, this.elastic = B1(s), d !== this.constraints && l && this.constraints && !this.hasMutatedConstraints && kt(u => { this.constraints !== !1 && this.getAxisMotionValue(u) && (this.constraints[u] = z1(l.layoutBox[u], this.constraints[u])) }) } resolveRefConstraints() { const { dragConstraints: r, onMeasureDragConstraints: o } = this.getProps(); if (!r || !kr(r)) return !1; const s = r.current, { projection: l } = this.visualElement; if (!l || !l.layout) return !1; const d = H1(s, l.root, this.visualElement.getTransformPagePoint()); let u = V1(l.layout.layoutBox, d); if (o) { const f = o(U1(u)); this.hasMutatedConstraints = !!f, f && (u = yp(f)) } return u } startAnimation(r) { const { drag: o, dragMomentum: s, dragElastic: l, dragTransition: d, dragSnapToOrigin: u, onDragTransitionEnd: f } = this.getProps(), h = this.constraints || {}, m = kt(v => { if (!Qi(v, o, this.currentDirection)) return; let g = h && h[v] || {}; u && (g = { min: 0, max: 0 }); const x = l ? 200 : 1e6, C = l ? 40 : 1e7, b = { type: "inertia", velocity: s ? r[v] : 0, bounceStiffness: x, bounceDamping: C, timeConstant: 750, restDelta: 1, restSpeed: 10, ...d, ...g }; return this.startAxisValueAnimation(v, b) }); return Promise.all(m).then(f) } startAxisValueAnimation(r, o) { const s = this.getAxisMotionValue(r); return s.start(xl(r, s, 0, o, this.visualElement, !1, Cl(this.visualElement, r))) } stopAnimation() { kt(r => this.getAxisMotionValue(r).stop()) } pauseAnimation() { kt(r => { var o; return (o = this.getAxisMotionValue(r).animation) === null || o === void 0 ? void 0 : o.pause() }) } getAnimationState(r) { var o; return (o = this.getAxisMotionValue(r).animation) === null || o === void 0 ? void 0 : o.state } getAxisMotionValue(r) { const o = `_drag${r.toUpperCase()}`, s = this.visualElement.getProps(), l = s[o]; return l || this.visualElement.getValue(r, (s.initial ? s.initial[r] : void 0) || 0) } snapToCursor(r) { kt(o => { const { drag: s } = this.getProps(); if (!Qi(o, s, this.currentDirection)) return; const { projection: l } = this.visualElement, d = this.getAxisMotionValue(o); if (l && l.layout) { const { min: u, max: f } = l.layout.layoutBox[o]; d.set(r[o] - je(u, f, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: r, dragConstraints: o } = this.getProps(), { projection: s } = this.visualElement; if (!kr(o) || !s || !this.constraints) return; this.stopAnimation(); const l = { x: 0, y: 0 }; kt(u => { const f = this.getAxisMotionValue(u); if (f && this.constraints !== !1) { const h = f.get(); l[u] = F1({ min: h, max: h }, this.constraints[u]) } }); const { transformTemplate: d } = this.visualElement.getProps(); this.visualElement.current.style.transform = d ? d({}, "") : "none", s.root && s.root.updateScroll(), s.updateLayout(), this.resolveConstraints(), kt(u => { if (!Qi(u, r, null)) return; const f = this.getAxisMotionValue(u), { min: h, max: m } = this.constraints[u]; f.set(je(h, m, l[u])) }) } addListeners() { if (!this.visualElement.current) return; K1.set(this.visualElement, this); const r = this.visualElement.current, o = nn(r, "pointerdown", h => { const { drag: m, dragListener: v = !0 } = this.getProps(); m && v && this.start(h) }), s = () => { const { dragConstraints: h } = this.getProps(); kr(h) && h.current && (this.constraints = this.resolveRefConstraints()) }, { projection: l } = this.visualElement, d = l.addEventListener("measure", s); l && !l.layout && (l.root && l.root.updateScroll(), l.updateLayout()), Te.read(s); const u = tn(window, "resize", () => this.scalePositionWithinConstraints()), f = l.addEventListener("didUpdate", ({ delta: h, hasLayoutChanged: m }) => { this.isDragging && m && (kt(v => { const g = this.getAxisMotionValue(v); g && (this.originPoint[v] += h[v].translate, g.set(g.get() + h[v].translate)) }), this.visualElement.render()) }); return () => { u(), o(), d(), f && f() } } getProps() { const r = this.visualElement.getProps(), { drag: o = !1, dragDirectionLock: s = !1, dragPropagation: l = !1, dragConstraints: d = !1, dragElastic: u = El, dragMomentum: f = !0 } = r; return { ...r, drag: o, dragDirectionLock: s, dragPropagation: l, dragConstraints: d, dragElastic: u, dragMomentum: f } } } function Qi(t, r, o) { return (r === !0 || r === t) && (o === null || o === t) } function Y1(t, r = 10) { let o = null; return Math.abs(t.y) > r ? o = "y" : Math.abs(t.x) > r && (o = "x"), o } class X1 extends En { constructor(r) { super(r), this.removeGroupControls = qe, this.removeListeners = qe, this.controls = new G1(r) } mount() { const { dragControls: r } = this.node.getProps(); r && (this.removeGroupControls = r.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || qe } unmount() { this.removeGroupControls(), this.removeListeners() } } const Rp = t => (r, o) => { t && Te.postRender(() => t(r, o)) }; class Q1 extends En { constructor() { super(...arguments), this.removePointerDownListener = qe } onPointerDown(r) { this.session = new op(r, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: Tp(this.node) }) } createPanHandlers() { const { onPanSessionStart: r, onPanStart: o, onPan: s, onPanEnd: l } = this.node.getProps(); return { onSessionStart: Rp(r), onStart: Rp(o), onMove: s, onEnd: (d, u) => { delete this.session, l && Te.postRender(() => l(d, u)) } } } mount() { this.removePointerDownListener = nn(this.node.current, "pointerdown", r => this.onPointerDown(r)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } function q1() { const t = w.useContext(Li); if (t === null) return [!0, null]; const { isPresent: r, onExitComplete: o, register: s } = t, l = w.useId(); w.useEffect(() => s(l), []); const d = w.useCallback(() => o && o(l), [l, o]); return !r && o ? [!1, d] : [!0] } const qi = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function Ap(t, r) { return r.max === r.min ? 0 : t / (r.max - r.min) * 100 } const Oo = { correct: (t, r) => { if (!r.target) return t; if (typeof t == "string") if (pe.test(t)) t = parseFloat(t); else return t; const o = Ap(t, r.target.x), s = Ap(t, r.target.y); return `${o}% ${s}%` } }, Z1 = { correct: (t, { treeScale: r, projectionDelta: o }) => { const s = t, l = Tn.parse(t); if (l.length > 5) return s; const d = Tn.createTransformer(t), u = typeof l[0] != "number" ? 1 : 0, f = o.x.scale * r.x, h = o.y.scale * r.y; l[0 + u] /= f, l[1 + u] /= h; const m = je(f, h, .5); return typeof l[2 + u] == "number" && (l[2 + u] /= m), typeof l[3 + u] == "number" && (l[3 + u] /= m), d(l) } }; class J1 extends w.Component { componentDidMount() { const { visualElement: r, layoutGroup: o, switchLayoutGroup: s, layoutId: l } = this.props, { projection: d } = r; Y0(eS), d && (o.group && o.group.add(d), s && s.register && l && s.register(d), d.root.didUpdate(), d.addEventListener("animationComplete", () => { this.safeToRemove() }), d.setOptions({ ...d.options, onExitComplete: () => this.safeToRemove() })), qi.hasEverUpdated = !0 } getSnapshotBeforeUpdate(r) { const { layoutDependency: o, visualElement: s, drag: l, isPresent: d } = this.props, u = s.projection; return u && (u.isPresent = d, l || r.layoutDependency !== o || o === void 0 ? u.willUpdate() : this.safeToRemove(), r.isPresent !== d && (d ? u.promote() : u.relegate() || Te.postRender(() => { const f = u.getStack(); (!f || !f.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: r } = this.props.visualElement; r && (r.root.didUpdate(), Oa.postRender(() => { !r.currentAnimation && r.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: r, layoutGroup: o, switchLayoutGroup: s } = this.props, { projection: l } = r; l && (l.scheduleCheckAfterUnmount(), o && o.group && o.group.remove(l), s && s.deregister && s.deregister(l)) } safeToRemove() { const { safeToRemove: r } = this.props; r && r() } render() { return null } } function Np(t) { const [r, o] = q1(), s = w.useContext(Va); return T.jsx(J1, { ...t, layoutGroup: s, switchLayoutGroup: w.useContext(Ed), isPresent: r, safeToRemove: o }) } const eS = { borderRadius: { ...Oo, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: Oo, borderTopRightRadius: Oo, borderBottomLeftRadius: Oo, borderBottomRightRadius: Oo, boxShadow: Z1 }, Mp = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], tS = Mp.length, Lp = t => typeof t == "string" ? parseFloat(t) : t, Dp = t => typeof t == "number" || pe.test(t); function nS(t, r, o, s, l, d) { l ? (t.opacity = je(0, o.opacity !== void 0 ? o.opacity : 1, rS(s)), t.opacityExit = je(r.opacity !== void 0 ? r.opacity : 1, 0, oS(s))) : d && (t.opacity = je(r.opacity !== void 0 ? r.opacity : 1, o.opacity !== void 0 ? o.opacity : 1, s)); for (let u = 0; u < tS; u++) { const f = `border${Mp[u]}Radius`; let h = jp(r, f), m = jp(o, f); if (h === void 0 && m === void 0) continue; h || (h = 0), m || (m = 0), h === 0 || m === 0 || Dp(h) === Dp(m) ? (t[f] = Math.max(je(Lp(h), Lp(m), s), 0), (Wt.test(m) || Wt.test(h)) && (t[f] += "%")) : t[f] = m } (r.rotate || o.rotate) && (t.rotate = je(r.rotate || 0, o.rotate || 0, s)) } function jp(t, r) { return t[r] !== void 0 ? t[r] : t.borderRadius } const rS = Op(0, .5, zf), oS = Op(.5, .95, qe); function Op(t, r, o) { return s => s < t ? 0 : s > r ? 1 : o(No(t, r, s)) } function _p(t, r) { t.min = r.min, t.max = r.max } function Pt(t, r) { _p(t.x, r.x), _p(t.y, r.y) } function Ip(t, r) { t.translate = r.translate, t.scale = r.scale, t.originPoint = r.originPoint, t.origin = r.origin } function Vp(t, r, o, s, l) { return t -= r, t = Xi(t, 1 / o, s), l !== void 0 && (t = Xi(t, 1 / l, s)), t } function iS(t, r = 0, o = 1, s = .5, l, d = t, u = t) { if (Wt.test(r) && (r = parseFloat(r), r = je(u.min, u.max, r / 100) - u.min), typeof r != "number") return; let f = je(d.min, d.max, s); t === d && (f -= r), t.min = Vp(t.min, r, o, f, l), t.max = Vp(t.max, r, o, f, l) } function Fp(t, r, [o, s, l], d, u) { iS(t, r[o], r[s], r[l], r.scale, d, u) } const sS = ["x", "scaleX", "originX"], aS = ["y", "scaleY", "originY"]; function zp(t, r, o, s) { Fp(t.x, r, sS, o ? o.x : void 0, s ? s.x : void 0), Fp(t.y, r, aS, o ? o.y : void 0, s ? s.y : void 0) } function Bp(t) { return t.translate === 0 && t.scale === 1 } function Up(t) { return Bp(t.x) && Bp(t.y) } function Wp(t, r) { return t.min === r.min && t.max === r.max } function lS(t, r) { return Wp(t.x, r.x) && Wp(t.y, r.y) } function $p(t, r) { return Math.round(t.min) === Math.round(r.min) && Math.round(t.max) === Math.round(r.max) } function Hp(t, r) { return $p(t.x, r.x) && $p(t.y, r.y) } function Kp(t) { return vt(t.x) / vt(t.y) } function Gp(t, r) { return t.translate === r.translate && t.scale === r.scale && t.originPoint === r.originPoint } class uS { constructor() { this.members = [] } add(r) { zi(this.members, r), r.scheduleRender() } remove(r) { if (Bi(this.members, r), r === this.prevLead && (this.prevLead = void 0), r === this.lead) { const o = this.members[this.members.length - 1]; o && this.promote(o) } } relegate(r) { const o = this.members.findIndex(l => r === l); if (o === 0) return !1; let s; for (let l = o; l >= 0; l--) { const d = this.members[l]; if (d.isPresent !== !1) { s = d; break } } return s ? (this.promote(s), !0) : !1 } promote(r, o) { const s = this.lead; if (r !== s && (this.prevLead = s, this.lead = r, r.show(), s)) { s.instance && s.scheduleRender(), r.scheduleRender(), r.resumeFrom = s, o && (r.resumeFrom.preserveOpacity = !0), s.snapshot && (r.snapshot = s.snapshot, r.snapshot.latestValues = s.animationValues || s.latestValues), r.root && r.root.isUpdating && (r.isLayoutDirty = !0); const { crossfade: l } = r.options; l === !1 && s.hide() } } exitAnimationComplete() { this.members.forEach(r => { const { options: o, resumingFrom: s } = r; o.onExitComplete && o.onExitComplete(), s && s.options.onExitComplete && s.options.onExitComplete() }) } scheduleRender() { this.members.forEach(r => { r.instance && r.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function cS(t, r, o) { let s = ""; const l = t.x.translate / r.x, d = t.y.translate / r.y, u = o?.z || 0; if ((l || d || u) && (s = `translate3d(${l}px, ${d}px, ${u}px) `), (r.x !== 1 || r.y !== 1) && (s += `scale(${1 / r.x}, ${1 / r.y}) `), o) { const { transformPerspective: m, rotate: v, rotateX: g, rotateY: x, skewX: C, skewY: b } = o; m && (s = `perspective(${m}px) ${s}`), v && (s += `rotate(${v}deg) `), g && (s += `rotateX(${g}deg) `), x && (s += `rotateY(${x}deg) `), C && (s += `skewX(${C}deg) `), b && (s += `skewY(${b}deg) `) } const f = t.x.scale * r.x, h = t.y.scale * r.y; return (f !== 1 || h !== 1) && (s += `scale(${f}, ${h})`), s || "none" } const dS = (t, r) => t.depth - r.depth; class fS { constructor() { this.children = [], this.isDirty = !1 } add(r) { zi(this.children, r), this.isDirty = !0 } remove(r) { Bi(this.children, r), this.isDirty = !0 } forEach(r) { this.isDirty && this.children.sort(dS), this.isDirty = !1, this.children.forEach(r) } } function pS(t, r) { const o = sn.now(), s = ({ timestamp: l }) => { const d = l - o; d >= r && (en(s), t(d - r)) }; return Te.read(s, !0), () => en(s) } function hS(t) { return t instanceof SVGElement && t.tagName !== "svg" } function mS(t, r, o) { const s = rt(t) ? t : Lo(t); return s.start(xl("", s, r, o)), s.animation } const ir = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }, _o = typeof window < "u" && window.MotionDebug !== void 0, Nl = ["", "X", "Y", "Z"], gS = { visibility: "hidden" }, Yp = 1e3; let vS = 0; function Ml(t, r, o, s) { const { latestValues: l } = r; l[t] && (o[t] = l[t], r.setStaticValue(t, 0), s && (s[t] = 0)) } function Xp(t) { if (t.hasCheckedOptimisedAppear = !0, t.root === t) return; const { visualElement: r } = t.options; if (!r) return; const o = ep(r); window.MotionHasOptimisedTransformAnimation(o) && window.MotionCancelOptimisedTransform(o); const { parent: s } = t; s && !s.hasCheckedOptimisedAppear && Xp(s) } function Qp({ attachResizeListener: t, defaultParent: r, measureScroll: o, checkIsScrollRoot: s, resetTransform: l }) { return class { constructor(u = {}, f = r?.()) { this.id = vS++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, _o && (ir.totalNodes = ir.resolvedTargetDeltas = ir.recalculatedProjection = 0), this.nodes.forEach(xS), this.nodes.forEach(PS), this.nodes.forEach(ES), this.nodes.forEach(SS), _o && window.MotionDebug.record(ir) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = u, this.root = f ? f.root || f : this, this.path = f ? [...f.path, f] : [], this.parent = f, this.depth = f ? f.depth + 1 : 0; for (let h = 0; h < this.path.length; h++)this.path[h].shouldResetTransform = !0; this.root === this && (this.nodes = new fS) } addEventListener(u, f) { return this.eventHandlers.has(u) || this.eventHandlers.set(u, new Sl), this.eventHandlers.get(u).add(f) } notifyListeners(u, ...f) { const h = this.eventHandlers.get(u); h && h.notify(...f) } hasListeners(u) { return this.eventHandlers.has(u) } mount(u, f = this.root.hasTreeAnimated) { if (this.instance) return; this.isSVG = hS(u), this.instance = u; const { layoutId: h, layout: m, visualElement: v } = this.options; if (v && !v.current && v.mount(u), this.root.nodes.add(this), this.parent && this.parent.children.add(this), f && (m || h) && (this.isLayoutDirty = !0), t) { let g; const x = () => this.root.updateBlockedByResize = !1; t(u, () => { this.root.updateBlockedByResize = !0, g && g(), g = pS(x, 250), qi.hasAnimatedSinceResize && (qi.hasAnimatedSinceResize = !1, this.nodes.forEach(Zp)) }) } h && this.root.registerSharedNode(h, this), this.options.animate !== !1 && v && (h || m) && this.addEventListener("didUpdate", ({ delta: g, hasLayoutChanged: x, hasRelativeTargetChanged: C, layout: b }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const S = this.options.transition || v.getDefaultTransition() || MS, { onLayoutAnimationStart: P, onLayoutAnimationComplete: R } = v.getProps(), N = !this.targetLayout || !Hp(this.targetLayout, b) || C, M = !x && C; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || M || x && (N || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(g, M); const j = { ...tl(S, "layout"), onPlay: P, onComplete: R }; (v.shouldReduceMotion || this.options.layoutRoot) && (j.delay = 0, j.type = !1), this.startAnimation(j) } else x || Zp(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = b }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const u = this.getStack(); u && u.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, en(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(TS), this.animationId++) } getTransformTemplate() { const { visualElement: u } = this.options; return u && u.getProps().transformTemplate } willUpdate(u = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedTransform && !this.hasCheckedOptimisedAppear && Xp(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let v = 0; v < this.path.length; v++) { const g = this.path[v]; g.shouldResetTransform = !0, g.updateScroll("snapshot"), g.options.layoutRoot && g.willUpdate(!1) } const { layoutId: f, layout: h } = this.options; if (f === void 0 && !h) return; const m = this.getTransformTemplate(); this.prevTransformTemplateValue = m ? m(this.latestValues, "") : void 0, this.updateSnapshot(), u && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(qp); return } this.isUpdating || this.nodes.forEach(bS), this.isUpdating = !1, this.nodes.forEach(kS), this.nodes.forEach(yS), this.nodes.forEach(wS), this.clearAllSnapshots(); const f = sn.now(); Ze.delta = kn(0, 1e3 / 60, f - Ze.timestamp), Ze.timestamp = f, Ze.isProcessing = !0, qa.update.process(Ze), qa.preRender.process(Ze), qa.render.process(Ze), Ze.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, Oa.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(CS), this.sharedNodes.forEach(RS) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Te.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { Te.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let h = 0; h < this.path.length; h++)this.path[h].updateScroll(); const u = this.layout; this.layout = this.measure(!1), this.layoutCorrected = Fe(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: f } = this.options; f && f.notify("LayoutMeasure", this.layout.layoutBox, u ? u.layoutBox : void 0) } updateScroll(u = "measure") { let f = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === u && (f = !1), f) { const h = s(this.instance); this.scroll = { animationId: this.root.animationId, phase: u, isRoot: h, offset: o(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : h } } } resetTransform() { if (!l) return; const u = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, f = this.projectionDelta && !Up(this.projectionDelta), h = this.getTransformTemplate(), m = h ? h(this.latestValues, "") : void 0, v = m !== this.prevTransformTemplateValue; u && (f || or(this.latestValues) || v) && (l(this.instance, m), this.shouldResetTransform = !1, this.scheduleRender()) } measure(u = !0) { const f = this.measurePageBox(); let h = this.removeElementScroll(f); return u && (h = this.removeTransform(h)), LS(h), { animationId: this.root.animationId, measuredBox: f, layoutBox: h, latestValues: {}, source: this.id } } measurePageBox() { var u; const { visualElement: f } = this.options; if (!f) return Fe(); const h = f.measureViewportBox(); if (!(((u = this.scroll) === null || u === void 0 ? void 0 : u.wasRoot) || this.path.some(DS))) { const { scroll: v } = this.root; v && (Nr(h.x, v.offset.x), Nr(h.y, v.offset.y)) } return h } removeElementScroll(u) { var f; const h = Fe(); if (Pt(h, u), !((f = this.scroll) === null || f === void 0) && f.wasRoot) return h; for (let m = 0; m < this.path.length; m++) { const v = this.path[m], { scroll: g, options: x } = v; v !== this.root && g && x.layoutScroll && (g.wasRoot && Pt(h, u), Nr(h.x, g.offset.x), Nr(h.y, g.offset.y)) } return h } applyTransform(u, f = !1) { const h = Fe(); Pt(h, u); for (let m = 0; m < this.path.length; m++) { const v = this.path[m]; !f && v.options.layoutScroll && v.scroll && v !== v.root && Mr(h, { x: -v.scroll.offset.x, y: -v.scroll.offset.y }), or(v.latestValues) && Mr(h, v.latestValues) } return or(this.latestValues) && Mr(h, this.latestValues), h } removeTransform(u) { const f = Fe(); Pt(f, u); for (let h = 0; h < this.path.length; h++) { const m = this.path[h]; if (!m.instance || !or(m.latestValues)) continue; Rl(m.latestValues) && m.updateSnapshot(); const v = Fe(), g = m.measurePageBox(); Pt(v, g), zp(f, m.latestValues, m.snapshot ? m.snapshot.layoutBox : void 0, v) } return or(this.latestValues) && zp(f, this.latestValues), f } setTargetDelta(u) { this.targetDelta = u, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(u) { this.options = { ...this.options, ...u, crossfade: u.crossfade !== void 0 ? u.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Ze.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(u = !1) { var f; const h = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = h.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = h.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = h.isSharedProjectionDirty); const m = !!this.resumingFrom || this !== h; if (!(u || m && this.isSharedProjectionDirty || this.isProjectionDirty || !((f = this.parent) === null || f === void 0) && f.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: g, layoutId: x } = this.options; if (!(!this.layout || !(g || x))) { if (this.resolvedRelativeTargetAt = Ze.timestamp, !this.targetDelta && !this.relativeTarget) { const C = this.getClosestProjectingParent(); C && C.layout && this.animationProgress !== 1 ? (this.relativeParent = C, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Fe(), this.relativeTargetOrigin = Fe(), jo(this.relativeTargetOrigin, this.layout.layoutBox, C.layout.layoutBox), Pt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = Fe(), this.targetWithTransforms = Fe()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), O1(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Pt(this.target, this.layout.layoutBox), Cp(this.target, this.targetDelta)) : Pt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; const C = this.getClosestProjectingParent(); C && !!C.resumingFrom == !!this.resumingFrom && !C.options.layoutScroll && C.target && this.animationProgress !== 1 ? (this.relativeParent = C, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Fe(), this.relativeTargetOrigin = Fe(), jo(this.relativeTargetOrigin, this.target, C.target), Pt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } _o && ir.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || Rl(this.parent.latestValues) || wp(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var u; const f = this.getLead(), h = !!this.resumingFrom || this !== f; let m = !0; if ((this.isProjectionDirty || !((u = this.parent) === null || u === void 0) && u.isProjectionDirty) && (m = !1), h && (this.isSharedProjectionDirty || this.isTransformDirty) && (m = !1), this.resolvedRelativeTargetAt === Ze.timestamp && (m = !1), m) return; const { layout: v, layoutId: g } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(v || g)) return; Pt(this.layoutCorrected, this.layout.layoutBox); const x = this.treeScale.x, C = this.treeScale.y; $1(this.layoutCorrected, this.treeScale, this.path, h), f.layout && !f.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (f.target = f.layout.layoutBox, f.targetWithTransforms = Fe()); const { target: b } = f; if (!b) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Ip(this.prevProjectionDelta.x, this.projectionDelta.x), Ip(this.prevProjectionDelta.y, this.projectionDelta.y)), Do(this.projectionDelta, this.layoutCorrected, b, this.latestValues), (this.treeScale.x !== x || this.treeScale.y !== C || !Gp(this.projectionDelta.x, this.prevProjectionDelta.x) || !Gp(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", b)), _o && ir.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(u = !0) { var f; if ((f = this.options.visualElement) === null || f === void 0 || f.scheduleRender(), u) { const h = this.getStack(); h && h.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = Ar(), this.projectionDelta = Ar(), this.projectionDeltaWithTransform = Ar() } setAnimationOrigin(u, f = !1) { const h = this.snapshot, m = h ? h.latestValues : {}, v = { ...this.latestValues }, g = Ar(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !f; const x = Fe(), C = h ? h.source : void 0, b = this.layout ? this.layout.source : void 0, S = C !== b, P = this.getStack(), R = !P || P.members.length <= 1, N = !!(S && !R && this.options.crossfade === !0 && !this.path.some(NS)); this.animationProgress = 0; let M; this.mixTargetDelta = j => { const I = j / 1e3; Jp(g.x, u.x, I), Jp(g.y, u.y, I), this.setTargetDelta(g), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (jo(x, this.layout.layoutBox, this.relativeParent.layout.layoutBox), AS(this.relativeTarget, this.relativeTargetOrigin, x, I), M && lS(this.relativeTarget, M) && (this.isProjectionDirty = !1), M || (M = Fe()), Pt(M, this.relativeTarget)), S && (this.animationValues = v, nS(v, m, this.latestValues, I, N, R)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = I }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(u) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (en(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Te.update(() => { qi.hasAnimatedSinceResize = !0, this.currentAnimation = mS(0, Yp, { ...u, onUpdate: f => { this.mixTargetDelta(f), u.onUpdate && u.onUpdate(f) }, onComplete: () => { u.onComplete && u.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const u = this.getStack(); u && u.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Yp), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const u = this.getLead(); let { targetWithTransforms: f, target: h, layout: m, latestValues: v } = u; if (!(!f || !h || !m)) { if (this !== u && this.layout && m && oh(this.options.animationType, this.layout.layoutBox, m.layoutBox)) { h = this.target || Fe(); const g = vt(this.layout.layoutBox.x); h.x.min = u.target.x.min, h.x.max = h.x.min + g; const x = vt(this.layout.layoutBox.y); h.y.min = u.target.y.min, h.y.max = h.y.min + x } Pt(f, h), Mr(f, v), Do(this.projectionDeltaWithTransform, this.layoutCorrected, f, v) } } registerSharedNode(u, f) { this.sharedNodes.has(u) || this.sharedNodes.set(u, new uS), this.sharedNodes.get(u).add(f); const m = f.options.initialPromotionConfig; f.promote({ transition: m ? m.transition : void 0, preserveFollowOpacity: m && m.shouldPreserveFollowOpacity ? m.shouldPreserveFollowOpacity(f) : void 0 }) } isLead() { const u = this.getStack(); return u ? u.lead === this : !0 } getLead() { var u; const { layoutId: f } = this.options; return f ? ((u = this.getStack()) === null || u === void 0 ? void 0 : u.lead) || this : this } getPrevLead() { var u; const { layoutId: f } = this.options; return f ? (u = this.getStack()) === null || u === void 0 ? void 0 : u.prevLead : void 0 } getStack() { const { layoutId: u } = this.options; if (u) return this.root.sharedNodes.get(u) } promote({ needsReset: u, transition: f, preserveFollowOpacity: h } = {}) { const m = this.getStack(); m && m.promote(this, h), u && (this.projectionDelta = void 0, this.needsReset = !0), f && this.setOptions({ transition: f }) } relegate() { const u = this.getStack(); return u ? u.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: u } = this.options; if (!u) return; let f = !1; const { latestValues: h } = u; if ((h.z || h.rotate || h.rotateX || h.rotateY || h.rotateZ || h.skewX || h.skewY) && (f = !0), !f) return; const m = {}; h.z && Ml("z", u, m, this.animationValues); for (let v = 0; v < Nl.length; v++)Ml(`rotate${Nl[v]}`, u, m, this.animationValues), Ml(`skew${Nl[v]}`, u, m, this.animationValues); u.render(); for (const v in m) u.setStaticValue(v, m[v]), this.animationValues && (this.animationValues[v] = m[v]); u.scheduleRender() } getProjectionStyles(u) { var f, h; if (!this.instance || this.isSVG) return; if (!this.isVisible) return gS; const m = { visibility: "" }, v = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, m.opacity = "", m.pointerEvents = Fi(u?.pointerEvents) || "", m.transform = v ? v(this.latestValues, "") : "none", m; const g = this.getLead(); if (!this.projectionDelta || !this.layout || !g.target) { const S = {}; return this.options.layoutId && (S.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, S.pointerEvents = Fi(u?.pointerEvents) || ""), this.hasProjected && !or(this.latestValues) && (S.transform = v ? v({}, "") : "none", this.hasProjected = !1), S } const x = g.animationValues || g.latestValues; this.applyTransformsToTarget(), m.transform = cS(this.projectionDeltaWithTransform, this.treeScale, x), v && (m.transform = v(x, m.transform)); const { x: C, y: b } = this.projectionDelta; m.transformOrigin = `${C.origin * 100}% ${b.origin * 100}% 0`, g.animationValues ? m.opacity = g === this ? (h = (f = x.opacity) !== null && f !== void 0 ? f : this.latestValues.opacity) !== null && h !== void 0 ? h : 1 : this.preserveOpacity ? this.latestValues.opacity : x.opacityExit : m.opacity = g === this ? x.opacity !== void 0 ? x.opacity : "" : x.opacityExit !== void 0 ? x.opacityExit : 0; for (const S in _i) { if (x[S] === void 0) continue; const { correct: P, applyTo: R } = _i[S], N = m.transform === "none" ? x[S] : P(x[S], g); if (R) { const M = R.length; for (let j = 0; j < M; j++)m[R[j]] = N } else m[S] = N } return this.options.layoutId && (m.pointerEvents = g === this ? Fi(u?.pointerEvents) || "" : "none"), m } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(u => { var f; return (f = u.currentAnimation) === null || f === void 0 ? void 0 : f.stop() }), this.root.nodes.forEach(qp), this.root.sharedNodes.clear() } } } function yS(t) { t.updateLayout() } function wS(t) { var r; const o = ((r = t.resumeFrom) === null || r === void 0 ? void 0 : r.snapshot) || t.snapshot; if (t.isLead() && t.layout && o && t.hasListeners("didUpdate")) { const { layoutBox: s, measuredBox: l } = t.layout, { animationType: d } = t.options, u = o.source !== t.layout.source; d === "size" ? kt(g => { const x = u ? o.measuredBox[g] : o.layoutBox[g], C = vt(x); x.min = s[g].min, x.max = x.min + C }) : oh(d, o.layoutBox, s) && kt(g => { const x = u ? o.measuredBox[g] : o.layoutBox[g], C = vt(s[g]); x.max = x.min + C, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[g].max = t.relativeTarget[g].min + C) }); const f = Ar(); Do(f, s, o.layoutBox); const h = Ar(); u ? Do(h, t.applyTransform(l, !0), o.measuredBox) : Do(h, s, o.layoutBox); const m = !Up(f); let v = !1; if (!t.resumeFrom) { const g = t.getClosestProjectingParent(); if (g && !g.resumeFrom) { const { snapshot: x, layout: C } = g; if (x && C) { const b = Fe(); jo(b, o.layoutBox, x.layoutBox); const S = Fe(); jo(S, s, C.layoutBox), Hp(b, S) || (v = !0), g.options.layoutRoot && (t.relativeTarget = S, t.relativeTargetOrigin = b, t.relativeParent = g) } } } t.notifyListeners("didUpdate", { layout: s, snapshot: o, delta: h, layoutDelta: f, hasLayoutChanged: m, hasRelativeTargetChanged: v }) } else if (t.isLead()) { const { onExitComplete: s } = t.options; s && s() } t.options.transition = void 0 } function xS(t) { _o && ir.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty)) } function SS(t) { t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1 } function CS(t) { t.clearSnapshot() } function qp(t) { t.clearMeasurements() } function bS(t) { t.isLayoutDirty = !1 } function kS(t) { const { visualElement: r } = t.options; r && r.getProps().onBeforeLayoutMeasure && r.notify("BeforeLayoutMeasure"), t.resetTransform() } function Zp(t) { t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0 } function PS(t) { t.resolveTargetDelta() } function ES(t) { t.calcProjection() } function TS(t) { t.resetSkewAndRotation() } function RS(t) { t.removeLeadSnapshot() } function Jp(t, r, o) { t.translate = je(r.translate, 0, o), t.scale = je(r.scale, 1, o), t.origin = r.origin, t.originPoint = r.originPoint } function eh(t, r, o, s) { t.min = je(r.min, o.min, s), t.max = je(r.max, o.max, s) } function AS(t, r, o, s) { eh(t.x, r.x, o.x, s), eh(t.y, r.y, o.y, s) } function NS(t) { return t.animationValues && t.animationValues.opacityExit !== void 0 } const MS = { duration: .45, ease: [.4, 0, .1, 1] }, th = t => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), nh = th("applewebkit/") && !th("chrome/") ? Math.round : qe; function rh(t) { t.min = nh(t.min), t.max = nh(t.max) } function LS(t) { rh(t.x), rh(t.y) } function oh(t, r, o) { return t === "position" || t === "preserve-aspect" && !j1(Kp(r), Kp(o), .2) } function DS(t) { var r; return t !== t.root && ((r = t.scroll) === null || r === void 0 ? void 0 : r.wasRoot) } const jS = Qp({ attachResizeListener: (t, r) => tn(t, "resize", r), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Ll = { current: void 0 }, ih = Qp({ measureScroll: t => ({ x: t.scrollLeft, y: t.scrollTop }), defaultParent: () => { if (!Ll.current) { const t = new jS({}); t.mount(window), t.setOptions({ layoutScroll: !0 }), Ll.current = t } return Ll.current }, resetTransform: (t, r) => { t.style.transform = r !== void 0 ? r : "none" }, checkIsScrollRoot: t => window.getComputedStyle(t).position === "fixed" }), OS = { pan: { Feature: Q1 }, drag: { Feature: X1, ProjectionNode: ih, MeasureLayout: Np } }, Dl = { current: null }, sh = { current: !1 }; function _S() { if (sh.current = !0, !!ja) if (window.matchMedia) { const t = window.matchMedia("(prefers-reduced-motion)"), r = () => Dl.current = t.matches; t.addListener(r), r() } else Dl.current = !1 } function IS(t, r, o) { for (const s in r) { const l = r[s], d = o[s]; if (rt(l)) t.addValue(s, l); else if (rt(d)) t.addValue(s, Lo(l, { owner: t })); else if (d !== l) if (t.hasValue(s)) { const u = t.getValue(s); u.liveStyle === !0 ? u.jump(l) : u.hasAnimated || u.set(l) } else { const u = t.getStaticValue(s); t.addValue(s, Lo(u !== void 0 ? u : l, { owner: t })) } } for (const s in o) r[s] === void 0 && t.removeValue(s); return r } const ah = new WeakMap, VS = [...mf, ot, Tn], FS = t => VS.find(hf(t)), lh = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"], zS = Ia.length; class BS { scrapeMotionValuesFromProps(r, o, s) { return {} } constructor({ parent: r, props: o, presenceContext: s, reducedMotionConfig: l, blockInitialAnimation: d, visualState: u }, f = {}) { this.applyWillChange = !1, this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = ol, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.isRenderScheduled = !1, this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.isRenderScheduled = !1, this.scheduleRender = () => { this.isRenderScheduled || (this.isRenderScheduled = !0, Te.render(this.render, !1, !0)) }; const { latestValues: h, renderState: m } = u; this.latestValues = h, this.baseTarget = { ...h }, this.initialValues = o.initial ? { ...h } : {}, this.renderState = m, this.parent = r, this.props = o, this.presenceContext = s, this.depth = r ? r.depth + 1 : 0, this.reducedMotionConfig = l, this.options = f, this.blockInitialAnimation = !!d, this.isControllingVariants = Oi(o), this.isVariantNode = Ad(o), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(r && r.current); const { willChange: v, ...g } = this.scrapeMotionValuesFromProps(o, {}, this); for (const x in g) { const C = g[x]; h[x] !== void 0 && rt(C) && C.set(h[x], !1) } } mount(r) { this.current = r, ah.set(r, this), this.projection && !this.projection.instance && this.projection.mount(r), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((o, s) => this.bindToMotionValue(s, o)), sh.current || _S(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Dl.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { ah.delete(this.current), this.projection && this.projection.unmount(), en(this.notifyUpdate), en(this.render), this.valueSubscriptions.forEach(r => r()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const r in this.events) this.events[r].clear(); for (const r in this.features) { const o = this.features[r]; o && (o.unmount(), o.isMounted = !1) } this.current = null } bindToMotionValue(r, o) { const s = bn.has(r), l = o.on("change", u => { this.latestValues[r] = u, this.props.onUpdate && Te.preRender(this.notifyUpdate), s && this.projection && (this.projection.isTransformDirty = !0) }), d = o.on("renderRequest", this.scheduleRender); this.valueSubscriptions.set(r, () => { l(), d(), o.owner && o.stop() }) } sortNodePosition(r) { return !this.current || !this.sortInstanceNodePosition || this.type !== r.type ? 0 : this.sortInstanceNodePosition(this.current, r.current) } updateFeatures() { let r = "animation"; for (r in Pr) { const o = Pr[r]; if (!o) continue; const { isEnabled: s, Feature: l } = o; if (!this.features[r] && l && s(this.props) && (this.features[r] = new l(this)), this.features[r]) { const d = this.features[r]; d.isMounted ? d.update() : (d.mount(), d.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Fe() } getStaticValue(r) { return this.latestValues[r] } setStaticValue(r, o) { this.latestValues[r] = o } update(r, o) { (r.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = r, this.prevPresenceContext = this.presenceContext, this.presenceContext = o; for (let s = 0; s < lh.length; s++) { const l = lh[s]; this.propEventSubscriptions[l] && (this.propEventSubscriptions[l](), delete this.propEventSubscriptions[l]); const d = "on" + l, u = r[d]; u && (this.propEventSubscriptions[l] = this.on(l, u)) } this.prevMotionValues = IS(this, this.scrapeMotionValuesFromProps(r, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(r) { return this.props.variants ? this.props.variants[r] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } getVariantContext(r = !1) { if (r) return this.parent ? this.parent.getVariantContext() : void 0; if (!this.isControllingVariants) { const s = this.parent ? this.parent.getVariantContext() || {} : {}; return this.props.initial !== void 0 && (s.initial = this.props.initial), s } const o = {}; for (let s = 0; s < zS; s++) { const l = Ia[s], d = this.props[l]; (So(d) || d === !1) && (o[l] = d) } return o } addVariantChild(r) { const o = this.getClosestVariantNode(); if (o) return o.variantChildren && o.variantChildren.add(r), () => o.variantChildren.delete(r) } addValue(r, o) { const s = this.values.get(r); o !== s && (s && this.removeValue(r), this.bindToMotionValue(r, o), this.values.set(r, o), this.latestValues[r] = o.get()) } removeValue(r) { this.values.delete(r); const o = this.valueSubscriptions.get(r); o && (o(), this.valueSubscriptions.delete(r)), delete this.latestValues[r], this.removeValueFromRenderState(r, this.renderState) } hasValue(r) { return this.values.has(r) } getValue(r, o) { if (this.props.values && this.props.values[r]) return this.props.values[r]; let s = this.values.get(r); return s === void 0 && o !== void 0 && (s = Lo(o === null ? void 0 : o, { owner: this }), this.addValue(r, s)), s } readValue(r, o) { var s; let l = this.latestValues[r] !== void 0 || !this.current ? this.latestValues[r] : (s = this.getBaseTargetFromProps(this.props, r)) !== null && s !== void 0 ? s : this.readValueFromInstance(this.current, r, this.options); return l != null && (typeof l == "string" && (uf(l) || lf(l)) ? l = parseFloat(l) : !FS(l) && Tn.test(o) && (l = Pf(r, o)), this.setBaseTarget(r, rt(l) ? l.get() : l)), rt(l) ? l.get() : l } setBaseTarget(r, o) { this.baseTarget[r] = o } getBaseTarget(r) { var o; const { initial: s } = this.props; let l; if (typeof s == "string" || typeof s == "object") { const u = Ya(this.props, s, (o = this.presenceContext) === null || o === void 0 ? void 0 : o.custom); u && (l = u[r]) } if (s && l !== void 0) return l; const d = this.getBaseTargetFromProps(this.props, r); return d !== void 0 && !rt(d) ? d : this.initialValues[r] !== void 0 && l === void 0 ? void 0 : this.baseTarget[r] } on(r, o) { return this.events[r] || (this.events[r] = new Sl), this.events[r].add(o) } notify(r, ...o) { this.events[r] && this.events[r].notify(...o) } } class uh extends BS { constructor() { super(...arguments), this.KeyframeResolver = Ef } sortInstanceNodePosition(r, o) { return r.compareDocumentPosition(o) & 2 ? 1 : -1 } getBaseTargetFromProps(r, o) { return r.style ? r.style[o] : void 0 } removeValueFromRenderState(r, { vars: o, style: s }) { delete o[r], delete s[r] } } function US(t) { return window.getComputedStyle(t) } class WS extends uh { constructor() { super(...arguments), this.type = "html", this.applyWillChange = !0, this.renderInstance = Wd } readValueFromInstance(r, o) { if (bn.has(o)) { const s = ul(o); return s && s.default || 0 } else { const s = US(r), l = (Vd(o) ? s.getPropertyValue(o) : s[o]) || 0; return typeof l == "string" ? l.trim() : l } } measureInstanceViewportBox(r, { transformPagePoint: o }) { return Ep(r, o) } build(r, o, s) { Wa(r, o, s.transformTemplate) } scrapeMotionValuesFromProps(r, o, s) { return Ga(r, o, s) } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: r } = this.props; rt(r) && (this.childSubscription = r.on("change", o => { this.current && (this.current.textContent = `${o}`) })) } } class $S extends uh { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Fe } getBaseTargetFromProps(r, o) { return r[o] } readValueFromInstance(r, o) { if (bn.has(o)) { const s = ul(o); return s && s.default || 0 } return o = $d.has(o) ? o : Di(o), r.getAttribute(o) } scrapeMotionValuesFromProps(r, o, s) { return Kd(r, o, s) } build(r, o, s) { Ha(r, o, this.isSVGTag, s.transformTemplate) } renderInstance(r, o, s, l) { Hd(r, o, s, l) } mount(r) { this.isSVGTag = Ka(r.tagName), super.mount(r) } } const HS = (t, r) => Fa(t) ? new $S(r) : new WS(r, { allowProjection: t !== w.Fragment }), KS = { ...E1, ...Iw, ...OS, ...{ layout: { ProjectionNode: ih, MeasureLayout: Np } } }, sr = K0((t, r) => kw(t, r, KS, HS)); class GS extends w.Component { getSnapshotBeforeUpdate(r) { const o = this.props.childRef.current; if (o && r.isPresent && !this.props.isPresent) { const s = this.props.sizeRef.current; s.height = o.offsetHeight || 0, s.width = o.offsetWidth || 0, s.top = o.offsetTop, s.left = o.offsetLeft } return null } componentDidUpdate() { } render() { return this.props.children } } function YS({ children: t, isPresent: r }) {
    const o = w.useId(), s = w.useRef(null), l = w.useRef({ width: 0, height: 0, top: 0, left: 0 }), { nonce: d } = w.useContext(Da); return w.useInsertionEffect(() => {
      const { width: u, height: f, top: h, left: m } = l.current; if (r || !s.current || !u || !f) return; s.current.dataset.motionPopId = o; const v = document.createElement("style"); return d && (v.nonce = d), document.head.appendChild(v), v.sheet && v.sheet.insertRule(`
          [data-motion-pop-id="${o}"] {
            position: absolute !important;
            width: ${u}px !important;
            height: ${f}px !important;
            top: ${h}px !important;
            left: ${m}px !important;
          }
        `), () => { document.head.removeChild(v) }
    }, [r]), T.jsx(GS, { isPresent: r, childRef: s, sizeRef: l, children: w.cloneElement(t, { ref: s }) })
  } const XS = ({ children: t, initial: r, isPresent: o, onExitComplete: s, custom: l, presenceAffectsLayout: d, mode: u }) => { const f = Xa(QS), h = w.useId(), m = w.useMemo(() => ({ id: h, initial: r, isPresent: o, custom: l, onExitComplete: v => { f.set(v, !0); for (const g of f.values()) if (!g) return; s && s() }, register: v => (f.set(v, !1), () => f.delete(v)) }), d ? [Math.random()] : [o]); return w.useMemo(() => { f.forEach((v, g) => f.set(g, !1)) }, [o]), w.useEffect(() => { !o && !f.size && s && s() }, [o]), u === "popLayout" && (t = T.jsx(YS, { isPresent: o, children: t })), T.jsx(Li.Provider, { value: m, children: t }) }; function QS() { return new Map } const Zi = t => t.key || ""; function ch(t) { const r = []; return w.Children.forEach(t, o => { w.isValidElement(o) && r.push(o) }), r } const qS = ({ children: t, exitBeforeEnter: r, custom: o, initial: s = !0, onExitComplete: l, presenceAffectsLayout: d = !0, mode: u = "sync" }) => { const f = w.useMemo(() => ch(t), [t]), h = f.map(Zi), m = w.useRef(!0), v = w.useRef(f), g = Xa(() => new Map), [x, C] = w.useState(f), [b, S] = w.useState(f); Cd(() => { m.current = !1, v.current = f; for (let N = 0; N < b.length; N++) { const M = Zi(b[N]); h.includes(M) ? g.delete(M) : g.get(M) !== !0 && g.set(M, !1) } }, [b, h.length, h.join("-")]); const P = []; if (f !== x) { let N = [...f]; for (let M = 0; M < b.length; M++) { const j = b[M], I = Zi(j); h.includes(I) || (N.splice(M, 0, j), P.push(j)) } u === "wait" && P.length && (N = P), S(ch(N)), C(f); return } const { forceRender: R } = w.useContext(Va); return T.jsx(T.Fragment, { children: b.map(N => { const M = Zi(N), j = f === b || h.includes(M), I = () => { if (g.has(M)) g.set(M, !0); else return; let H = !0; g.forEach($ => { $ || (H = !1) }), H && (R?.(), S(v.current), l && l()) }; return T.jsx(XS, { isPresent: j, initial: !m.current || s ? void 0 : !1, custom: j ? void 0 : o, presenceAffectsLayout: d, mode: u, onExitComplete: j ? void 0 : I, children: N }, M) }) }) }, jl = "-", ZS = t => { const r = eC(t), { conflictingClassGroups: o, conflictingClassGroupModifiers: s } = t; return { getClassGroupId: u => { const f = u.split(jl); return f[0] === "" && f.length !== 1 && f.shift(), dh(f, r) || JS(u) }, getConflictingClassGroupIds: (u, f) => { const h = o[u] || []; return f && s[u] ? [...h, ...s[u]] : h } } }, dh = (t, r) => { if (t.length === 0) return r.classGroupId; const o = t[0], s = r.nextPart.get(o), l = s ? dh(t.slice(1), s) : void 0; if (l) return l; if (r.validators.length === 0) return; const d = t.join(jl); return r.validators.find(({ validator: u }) => u(d))?.classGroupId }, fh = /^\[(.+)\]$/, JS = t => { if (fh.test(t)) { const r = fh.exec(t)[1], o = r?.substring(0, r.indexOf(":")); if (o) return "arbitrary.." + o } }, eC = t => { const { theme: r, prefix: o } = t, s = { nextPart: new Map, validators: [] }; return nC(Object.entries(t.classGroups), o).forEach(([d, u]) => { Ol(u, s, d, r) }), s }, Ol = (t, r, o, s) => { t.forEach(l => { if (typeof l == "string") { const d = l === "" ? r : ph(r, l); d.classGroupId = o; return } if (typeof l == "function") { if (tC(l)) { Ol(l(s), r, o, s); return } r.validators.push({ validator: l, classGroupId: o }); return } Object.entries(l).forEach(([d, u]) => { Ol(u, ph(r, d), o, s) }) }) }, ph = (t, r) => { let o = t; return r.split(jl).forEach(s => { o.nextPart.has(s) || o.nextPart.set(s, { nextPart: new Map, validators: [] }), o = o.nextPart.get(s) }), o }, tC = t => t.isThemeGetter, nC = (t, r) => r ? t.map(([o, s]) => { const l = s.map(d => typeof d == "string" ? r + d : typeof d == "object" ? Object.fromEntries(Object.entries(d).map(([u, f]) => [r + u, f])) : d); return [o, l] }) : t, rC = t => { if (t < 1) return { get: () => { }, set: () => { } }; let r = 0, o = new Map, s = new Map; const l = (d, u) => { o.set(d, u), r++, r > t && (r = 0, s = o, o = new Map) }; return { get(d) { let u = o.get(d); if (u !== void 0) return u; if ((u = s.get(d)) !== void 0) return l(d, u), u }, set(d, u) { o.has(d) ? o.set(d, u) : l(d, u) } } }, hh = "!", oC = t => { const { separator: r, experimentalParseClassName: o } = t, s = r.length === 1, l = r[0], d = r.length, u = f => { const h = []; let m = 0, v = 0, g; for (let P = 0; P < f.length; P++) { let R = f[P]; if (m === 0) { if (R === l && (s || f.slice(P, P + d) === r)) { h.push(f.slice(v, P)), v = P + d; continue } if (R === "/") { g = P; continue } } R === "[" ? m++ : R === "]" && m-- } const x = h.length === 0 ? f : f.substring(v), C = x.startsWith(hh), b = C ? x.substring(1) : x, S = g && g > v ? g - v : void 0; return { modifiers: h, hasImportantModifier: C, baseClassName: b, maybePostfixModifierPosition: S } }; return o ? f => o({ className: f, parseClassName: u }) : u }, iC = t => { if (t.length <= 1) return t; const r = []; let o = []; return t.forEach(s => { s[0] === "[" ? (r.push(...o.sort(), s), o = []) : o.push(s) }), r.push(...o.sort()), r }, sC = t => ({ cache: rC(t.cacheSize), parseClassName: oC(t), ...ZS(t) }), aC = /\s+/, lC = (t, r) => { const { parseClassName: o, getClassGroupId: s, getConflictingClassGroupIds: l } = r, d = [], u = t.trim().split(aC); let f = ""; for (let h = u.length - 1; h >= 0; h -= 1) { const m = u[h], { modifiers: v, hasImportantModifier: g, baseClassName: x, maybePostfixModifierPosition: C } = o(m); let b = !!C, S = s(b ? x.substring(0, C) : x); if (!S) { if (!b) { f = m + (f.length > 0 ? " " + f : f); continue } if (S = s(x), !S) { f = m + (f.length > 0 ? " " + f : f); continue } b = !1 } const P = iC(v).join(":"), R = g ? P + hh : P, N = R + S; if (d.includes(N)) continue; d.push(N); const M = l(S, b); for (let j = 0; j < M.length; ++j) { const I = M[j]; d.push(R + I) } f = m + (f.length > 0 ? " " + f : f) } return f }; function uC() { let t = 0, r, o, s = ""; for (; t < arguments.length;)(r = arguments[t++]) && (o = mh(r)) && (s && (s += " "), s += o); return s } const mh = t => { if (typeof t == "string") return t; let r, o = ""; for (let s = 0; s < t.length; s++)t[s] && (r = mh(t[s])) && (o && (o += " "), o += r); return o }; function cC(t, ...r) { let o, s, l, d = u; function u(h) { const m = r.reduce((v, g) => g(v), t()); return o = sC(m), s = o.cache.get, l = o.cache.set, d = f, f(h) } function f(h) { const m = s(h); if (m) return m; const v = lC(h, o); return l(h, v), v } return function () { return d(uC.apply(null, arguments)) } } const Ne = t => { const r = o => o[t] || []; return r.isThemeGetter = !0, r }, gh = /^\[(?:([a-z-]+):)?(.+)\]$/i, dC = /^\d+\/\d+$/, fC = new Set(["px", "full", "screen"]), pC = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, hC = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, mC = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, gC = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, vC = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, an = t => Lr(t) || fC.has(t) || dC.test(t), Rn = t => Dr(t, "length", PC), Lr = t => !!t && !Number.isNaN(Number(t)), _l = t => Dr(t, "number", Lr), Io = t => !!t && Number.isInteger(Number(t)), yC = t => t.endsWith("%") && Lr(t.slice(0, -1)), xe = t => gh.test(t), An = t => pC.test(t), wC = new Set(["length", "size", "percentage"]), xC = t => Dr(t, wC, vh), SC = t => Dr(t, "position", vh), CC = new Set(["image", "url"]), bC = t => Dr(t, CC, TC), kC = t => Dr(t, "", EC), Vo = () => !0, Dr = (t, r, o) => { const s = gh.exec(t); return s ? s[1] ? typeof r == "string" ? s[1] === r : r.has(s[1]) : o(s[2]) : !1 }, PC = t => hC.test(t) && !mC.test(t), vh = () => !1, EC = t => gC.test(t), TC = t => vC.test(t), Je = cC(() => { const t = Ne("colors"), r = Ne("spacing"), o = Ne("blur"), s = Ne("brightness"), l = Ne("borderColor"), d = Ne("borderRadius"), u = Ne("borderSpacing"), f = Ne("borderWidth"), h = Ne("contrast"), m = Ne("grayscale"), v = Ne("hueRotate"), g = Ne("invert"), x = Ne("gap"), C = Ne("gradientColorStops"), b = Ne("gradientColorStopPositions"), S = Ne("inset"), P = Ne("margin"), R = Ne("opacity"), N = Ne("padding"), M = Ne("saturate"), j = Ne("scale"), I = Ne("sepia"), H = Ne("skew"), $ = Ne("space"), W = Ne("translate"), le = () => ["auto", "contain", "none"], oe = () => ["auto", "hidden", "clip", "visible", "scroll"], me = () => ["auto", xe, r], Z = () => [xe, r], ge = () => ["", an, Rn], ne = () => ["auto", Lr, xe], J = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], se = () => ["solid", "dashed", "dotted", "double", "none"], G = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], F = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], Y = () => ["", "0", xe], X = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], E = () => [Lr, xe]; return { cacheSize: 500, separator: ":", theme: { colors: [Vo], spacing: [an, Rn], blur: ["none", "", An, xe], brightness: E(), borderColor: [t], borderRadius: ["none", "", "full", An, xe], borderSpacing: Z(), borderWidth: ge(), contrast: E(), grayscale: Y(), hueRotate: E(), invert: Y(), gap: Z(), gradientColorStops: [t], gradientColorStopPositions: [yC, Rn], inset: me(), margin: me(), opacity: E(), padding: Z(), saturate: E(), scale: E(), sepia: Y(), skew: E(), space: Z(), translate: Z() }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", xe] }], container: ["container"], columns: [{ columns: [An] }], "break-after": [{ "break-after": X() }], "break-before": [{ "break-before": X() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: [...J(), xe] }], overflow: [{ overflow: oe() }], "overflow-x": [{ "overflow-x": oe() }], "overflow-y": [{ "overflow-y": oe() }], overscroll: [{ overscroll: le() }], "overscroll-x": [{ "overscroll-x": le() }], "overscroll-y": [{ "overscroll-y": le() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [S] }], "inset-x": [{ "inset-x": [S] }], "inset-y": [{ "inset-y": [S] }], start: [{ start: [S] }], end: [{ end: [S] }], top: [{ top: [S] }], right: [{ right: [S] }], bottom: [{ bottom: [S] }], left: [{ left: [S] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", Io, xe] }], basis: [{ basis: me() }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", xe] }], grow: [{ grow: Y() }], shrink: [{ shrink: Y() }], order: [{ order: ["first", "last", "none", Io, xe] }], "grid-cols": [{ "grid-cols": [Vo] }], "col-start-end": [{ col: ["auto", { span: ["full", Io, xe] }, xe] }], "col-start": [{ "col-start": ne() }], "col-end": [{ "col-end": ne() }], "grid-rows": [{ "grid-rows": [Vo] }], "row-start-end": [{ row: ["auto", { span: [Io, xe] }, xe] }], "row-start": [{ "row-start": ne() }], "row-end": [{ "row-end": ne() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", xe] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", xe] }], gap: [{ gap: [x] }], "gap-x": [{ "gap-x": [x] }], "gap-y": [{ "gap-y": [x] }], "justify-content": [{ justify: ["normal", ...F()] }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal", ...F(), "baseline"] }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": [...F(), "baseline"] }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [N] }], px: [{ px: [N] }], py: [{ py: [N] }], ps: [{ ps: [N] }], pe: [{ pe: [N] }], pt: [{ pt: [N] }], pr: [{ pr: [N] }], pb: [{ pb: [N] }], pl: [{ pl: [N] }], m: [{ m: [P] }], mx: [{ mx: [P] }], my: [{ my: [P] }], ms: [{ ms: [P] }], me: [{ me: [P] }], mt: [{ mt: [P] }], mr: [{ mr: [P] }], mb: [{ mb: [P] }], ml: [{ ml: [P] }], "space-x": [{ "space-x": [$] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [$] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", xe, r] }], "min-w": [{ "min-w": [xe, r, "min", "max", "fit"] }], "max-w": [{ "max-w": [xe, r, "none", "full", "min", "max", "fit", "prose", { screen: [An] }, An] }], h: [{ h: [xe, r, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }], "min-h": [{ "min-h": [xe, r, "min", "max", "fit", "svh", "lvh", "dvh"] }], "max-h": [{ "max-h": [xe, r, "min", "max", "fit", "svh", "lvh", "dvh"] }], size: [{ size: [xe, r, "auto", "min", "max", "fit"] }], "font-size": [{ text: ["base", An, Rn] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", _l] }], "font-family": [{ font: [Vo] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractons"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", xe] }], "line-clamp": [{ "line-clamp": ["none", Lr, _l] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", an, xe] }], "list-image": [{ "list-image": ["none", xe] }], "list-style-type": [{ list: ["none", "disc", "decimal", xe] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [t] }], "placeholder-opacity": [{ "placeholder-opacity": [R] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [t] }], "text-opacity": [{ "text-opacity": [R] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...se(), "wavy"] }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", an, Rn] }], "underline-offset": [{ "underline-offset": ["auto", an, xe] }], "text-decoration-color": [{ decoration: [t] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: Z() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", xe] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", xe] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [R] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: [...J(), SC] }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", xC] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, bC] }], "bg-color": [{ bg: [t] }], "gradient-from-pos": [{ from: [b] }], "gradient-via-pos": [{ via: [b] }], "gradient-to-pos": [{ to: [b] }], "gradient-from": [{ from: [C] }], "gradient-via": [{ via: [C] }], "gradient-to": [{ to: [C] }], rounded: [{ rounded: [d] }], "rounded-s": [{ "rounded-s": [d] }], "rounded-e": [{ "rounded-e": [d] }], "rounded-t": [{ "rounded-t": [d] }], "rounded-r": [{ "rounded-r": [d] }], "rounded-b": [{ "rounded-b": [d] }], "rounded-l": [{ "rounded-l": [d] }], "rounded-ss": [{ "rounded-ss": [d] }], "rounded-se": [{ "rounded-se": [d] }], "rounded-ee": [{ "rounded-ee": [d] }], "rounded-es": [{ "rounded-es": [d] }], "rounded-tl": [{ "rounded-tl": [d] }], "rounded-tr": [{ "rounded-tr": [d] }], "rounded-br": [{ "rounded-br": [d] }], "rounded-bl": [{ "rounded-bl": [d] }], "border-w": [{ border: [f] }], "border-w-x": [{ "border-x": [f] }], "border-w-y": [{ "border-y": [f] }], "border-w-s": [{ "border-s": [f] }], "border-w-e": [{ "border-e": [f] }], "border-w-t": [{ "border-t": [f] }], "border-w-r": [{ "border-r": [f] }], "border-w-b": [{ "border-b": [f] }], "border-w-l": [{ "border-l": [f] }], "border-opacity": [{ "border-opacity": [R] }], "border-style": [{ border: [...se(), "hidden"] }], "divide-x": [{ "divide-x": [f] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [f] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [R] }], "divide-style": [{ divide: se() }], "border-color": [{ border: [l] }], "border-color-x": [{ "border-x": [l] }], "border-color-y": [{ "border-y": [l] }], "border-color-t": [{ "border-t": [l] }], "border-color-r": [{ "border-r": [l] }], "border-color-b": [{ "border-b": [l] }], "border-color-l": [{ "border-l": [l] }], "divide-color": [{ divide: [l] }], "outline-style": [{ outline: ["", ...se()] }], "outline-offset": [{ "outline-offset": [an, xe] }], "outline-w": [{ outline: [an, Rn] }], "outline-color": [{ outline: [t] }], "ring-w": [{ ring: ge() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [t] }], "ring-opacity": [{ "ring-opacity": [R] }], "ring-offset-w": [{ "ring-offset": [an, Rn] }], "ring-offset-color": [{ "ring-offset": [t] }], shadow: [{ shadow: ["", "inner", "none", An, kC] }], "shadow-color": [{ shadow: [Vo] }], opacity: [{ opacity: [R] }], "mix-blend": [{ "mix-blend": [...G(), "plus-lighter", "plus-darker"] }], "bg-blend": [{ "bg-blend": G() }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [o] }], brightness: [{ brightness: [s] }], contrast: [{ contrast: [h] }], "drop-shadow": [{ "drop-shadow": ["", "none", An, xe] }], grayscale: [{ grayscale: [m] }], "hue-rotate": [{ "hue-rotate": [v] }], invert: [{ invert: [g] }], saturate: [{ saturate: [M] }], sepia: [{ sepia: [I] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [o] }], "backdrop-brightness": [{ "backdrop-brightness": [s] }], "backdrop-contrast": [{ "backdrop-contrast": [h] }], "backdrop-grayscale": [{ "backdrop-grayscale": [m] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [v] }], "backdrop-invert": [{ "backdrop-invert": [g] }], "backdrop-opacity": [{ "backdrop-opacity": [R] }], "backdrop-saturate": [{ "backdrop-saturate": [M] }], "backdrop-sepia": [{ "backdrop-sepia": [I] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [u] }], "border-spacing-x": [{ "border-spacing-x": [u] }], "border-spacing-y": [{ "border-spacing-y": [u] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", xe] }], duration: [{ duration: E() }], ease: [{ ease: ["linear", "in", "out", "in-out", xe] }], delay: [{ delay: E() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", xe] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [j] }], "scale-x": [{ "scale-x": [j] }], "scale-y": [{ "scale-y": [j] }], rotate: [{ rotate: [Io, xe] }], "translate-x": [{ "translate-x": [W] }], "translate-y": [{ "translate-y": [W] }], "skew-x": [{ "skew-x": [H] }], "skew-y": [{ "skew-y": [H] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", xe] }], accent: [{ accent: ["auto", t] }], appearance: [{ appearance: ["none", "auto"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", xe] }], "caret-color": [{ caret: [t] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": Z() }], "scroll-mx": [{ "scroll-mx": Z() }], "scroll-my": [{ "scroll-my": Z() }], "scroll-ms": [{ "scroll-ms": Z() }], "scroll-me": [{ "scroll-me": Z() }], "scroll-mt": [{ "scroll-mt": Z() }], "scroll-mr": [{ "scroll-mr": Z() }], "scroll-mb": [{ "scroll-mb": Z() }], "scroll-ml": [{ "scroll-ml": Z() }], "scroll-p": [{ "scroll-p": Z() }], "scroll-px": [{ "scroll-px": Z() }], "scroll-py": [{ "scroll-py": Z() }], "scroll-ps": [{ "scroll-ps": Z() }], "scroll-pe": [{ "scroll-pe": Z() }], "scroll-pt": [{ "scroll-pt": Z() }], "scroll-pr": [{ "scroll-pr": Z() }], "scroll-pb": [{ "scroll-pb": Z() }], "scroll-pl": [{ "scroll-pl": Z() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", xe] }], fill: [{ fill: [t, "none"] }], "stroke-w": [{ stroke: [an, Rn, _l] }], stroke: [{ stroke: [t, "none"] }], sr: ["sr-only", "not-sr-only"], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } } }); function yh(t) { var r, o, s = ""; if (typeof t == "string" || typeof t == "number") s += t; else if (typeof t == "object") if (Array.isArray(t)) { var l = t.length; for (r = 0; r < l; r++)t[r] && (o = yh(t[r])) && (s && (s += " "), s += o) } else for (o in t) t[o] && (s && (s += " "), s += o); return s } function RC() { for (var t, r, o = 0, s = "", l = arguments.length; o < l; o++)(t = arguments[o]) && (r = yh(t)) && (s && (s += " "), s += r); return s } function Oe(...t) { return Je(RC(t)) } function jr({ className: t, ...r }) { return T.jsx("div", { className: Oe("animate-pulse rounded-md bg-muted", t), ...r }) } function AC(t, r) { typeof t == "function" ? t(r) : t != null && (t.current = r) } function wh(...t) { return r => t.forEach(o => AC(o, r)) } function et(...t) { return w.useCallback(wh(...t), t) } var Or = w.forwardRef((t, r) => { const { children: o, ...s } = t, l = w.Children.toArray(o), d = l.find(MC); if (d) { const u = d.props.children, f = l.map(h => h === d ? w.Children.count(u) > 1 ? w.Children.only(null) : w.isValidElement(u) ? u.props.children : null : h); return T.jsx(Il, { ...s, ref: r, children: w.isValidElement(u) ? w.cloneElement(u, void 0, f) : null }) } return T.jsx(Il, { ...s, ref: r, children: o }) }); Or.displayName = "Slot"; var Il = w.forwardRef((t, r) => { const { children: o, ...s } = t; if (w.isValidElement(o)) { const l = DC(o); return w.cloneElement(o, { ...LC(s, o.props), ref: r ? wh(r, l) : l }) } return w.Children.count(o) > 1 ? w.Children.only(null) : null }); Il.displayName = "SlotClone"; var NC = ({ children: t }) => T.jsx(T.Fragment, { children: t }); function MC(t) { return w.isValidElement(t) && t.type === NC } function LC(t, r) { const o = { ...r }; for (const s in r) { const l = t[s], d = r[s]; /^on[A-Z]/.test(s) ? l && d ? o[s] = (...f) => { d(...f), l(...f) } : l && (o[s] = l) : s === "style" ? o[s] = { ...l, ...d } : s === "className" && (o[s] = [l, d].filter(Boolean).join(" ")) } return { ...t, ...o } } function DC(t) { let r = Object.getOwnPropertyDescriptor(t.props, "ref")?.get, o = r && "isReactWarning" in r && r.isReactWarning; return o ? t.ref : (r = Object.getOwnPropertyDescriptor(t, "ref")?.get, o = r && "isReactWarning" in r && r.isReactWarning, o ? t.props.ref : t.props.ref || t.ref) } function xh(t) { var r, o, s = ""; if (typeof t == "string" || typeof t == "number") s += t; else if (typeof t == "object") if (Array.isArray(t)) for (r = 0; r < t.length; r++)t[r] && (o = xh(t[r])) && (s && (s += " "), s += o); else for (r in t) t[r] && (s && (s += " "), s += r); return s } function jC() { for (var t, r, o = 0, s = ""; o < arguments.length;)(t = arguments[o++]) && (r = xh(t)) && (s && (s += " "), s += r); return s } const Sh = t => typeof t == "boolean" ? "".concat(t) : t === 0 ? "0" : t, Ch = jC, Vl = (t, r) => o => { var s; if (r?.variants == null) return Ch(t, o?.class, o?.className); const { variants: l, defaultVariants: d } = r, u = Object.keys(l).map(m => { const v = o?.[m], g = d?.[m]; if (v === null) return null; const x = Sh(v) || Sh(g); return l[m][x] }), f = o && Object.entries(o).reduce((m, v) => { let [g, x] = v; return x === void 0 || (m[g] = x), m }, {}), h = r == null || (s = r.compoundVariants) === null || s === void 0 ? void 0 : s.reduce((m, v) => { let { class: g, className: x, ...C } = v; return Object.entries(C).every(b => { let [S, P] = b; return Array.isArray(P) ? P.includes({ ...d, ...f }[S]) : { ...d, ...f }[S] === P }) ? [...m, g, x] : m }, []); return Ch(t, u, h, o?.class, o?.className) }, OC = Vl("inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50", { variants: { variant: { default: "bg-primary text-primary-foreground hover:bg-primary/90", destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90", outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground", secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80", ghost: "hover:bg-accent hover:text-accent-foreground", link: "text-primary underline-offset-4 hover:underline" }, size: { default: "h-10 px-4 py-2", sm: "h-9 rounded-md px-3", lg: "h-11 rounded-md px-8", icon: "h-10 w-10" } }, defaultVariants: { variant: "default", size: "default" } }), Fo = w.forwardRef(({ className: t, variant: r, size: o, asChild: s = !1, ...l }, d) => { const u = s ? Or : "button"; return T.jsx(u, { className: Oe(OC({ variant: r, size: o, className: t })), ref: d, ...l }) }); Fo.displayName = "Button"; const ln = w.forwardRef(({ className: t, type: r, ...o }, s) => T.jsx("input", { type: r, className: Oe("flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", t), ref: s, ...o })); ln.displayName = "Input"; var _C = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"], ze = _C.reduce((t, r) => { const o = w.forwardRef((s, l) => { const { asChild: d, ...u } = s, f = d ? Or : r; return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), T.jsx(f, { ...u, ref: l }) }); return o.displayName = `Primitive.${r}`, { ...t, [r]: o } }, {}); function IC(t, r) { t && xo.flushSync(() => t.dispatchEvent(r)) } var VC = "Label", bh = w.forwardRef((t, r) => T.jsx(ze.label, { ...t, ref: r, onMouseDown: o => { o.target.closest("button, input, select, textarea") || (t.onMouseDown?.(o), !o.defaultPrevented && o.detail > 1 && o.preventDefault()) } })); bh.displayName = VC; var kh = bh; const FC = Vl("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"), Dt = w.forwardRef(({ className: t, ...r }, o) => T.jsx(kh, { ref: o, className: Oe(FC(), t), ...r })); Dt.displayName = kh.displayName; const Ph = w.forwardRef(({ className: t, ...r }, o) => T.jsx("textarea", { className: Oe("flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", t), ref: o, ...r })); Ph.displayName = "Textarea"; var zC = "Separator", Eh = "horizontal", BC = ["horizontal", "vertical"], Th = w.forwardRef((t, r) => { const { decorative: o, orientation: s = Eh, ...l } = t, d = UC(s) ? s : Eh, f = o ? { role: "none" } : { "aria-orientation": d === "vertical" ? d : void 0, role: "separator" }; return T.jsx(ze.div, { "data-orientation": d, ...f, ...l, ref: r }) }); Th.displayName = zC; function UC(t) { return BC.includes(t) } var Rh = Th; const Ah = w.forwardRef(({ className: t, orientation: r = "horizontal", decorative: o = !0, ...s }, l) => T.jsx(Rh, { ref: l, decorative: o, orientation: r, className: Oe("shrink-0 bg-border", r === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]", t), ...s })); Ah.displayName = Rh.displayName; const WC = Vl("relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground", { variants: { variant: { default: "bg-background text-foreground", destructive: "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive" } }, defaultVariants: { variant: "default" } }), Nh = w.forwardRef(({ className: t, variant: r, ...o }, s) => T.jsx("div", { ref: s, role: "alert", className: Oe(WC({ variant: r }), t), ...o })); Nh.displayName = "Alert"; const Mh = w.forwardRef(({ className: t, ...r }, o) => T.jsx("h5", { ref: o, className: Oe("mb-1 font-medium leading-none tracking-tight", t), ...r })); Mh.displayName = "AlertTitle"; const Lh = w.forwardRef(({ className: t, ...r }, o) => T.jsx("div", { ref: o, className: Oe("text-sm [&_p]:leading-relaxed", t), ...r })); Lh.displayName = "AlertDescription"; function Dh(t, [r, o]) { return Math.min(o, Math.max(r, t)) } function Ge(t, r, { checkForDefaultPrevented: o = !0 } = {}) { return function (l) { if (t?.(l), o === !1 || !l.defaultPrevented) return r?.(l) } } function Fl(t, r = []) { let o = []; function s(d, u) { const f = w.createContext(u), h = o.length; o = [...o, u]; function m(g) { const { scope: x, children: C, ...b } = g, S = x?.[t][h] || f, P = w.useMemo(() => b, Object.values(b)); return T.jsx(S.Provider, { value: P, children: C }) } function v(g, x) { const C = x?.[t][h] || f, b = w.useContext(C); if (b) return b; if (u !== void 0) return u; throw new Error(`\`${g}\` must be used within \`${d}\``) } return m.displayName = d + "Provider", [m, v] } const l = () => { const d = o.map(u => w.createContext(u)); return function (f) { const h = f?.[t] || d; return w.useMemo(() => ({ [`__scope${t}`]: { ...f, [t]: h } }), [f, h]) } }; return l.scopeName = t, [s, $C(l, ...r)] } function $C(...t) { const r = t[0]; if (t.length === 1) return r; const o = () => { const s = t.map(l => ({ useScope: l(), scopeName: l.scopeName })); return function (d) { const u = s.reduce((f, { useScope: h, scopeName: m }) => { const g = h(d)[`__scope${m}`]; return { ...f, ...g } }, {}); return w.useMemo(() => ({ [`__scope${r.scopeName}`]: u }), [u]) } }; return o.scopeName = r.scopeName, o } function HC(t) { const r = t + "CollectionProvider", [o, s] = Fl(r), [l, d] = o(r, { collectionRef: { current: null }, itemMap: new Map }), u = C => { const { scope: b, children: S } = C, P = Cn.useRef(null), R = Cn.useRef(new Map).current; return T.jsx(l, { scope: b, itemMap: R, collectionRef: P, children: S }) }; u.displayName = r; const f = t + "CollectionSlot", h = Cn.forwardRef((C, b) => { const { scope: S, children: P } = C, R = d(f, S), N = et(b, R.collectionRef); return T.jsx(Or, { ref: N, children: P }) }); h.displayName = f; const m = t + "CollectionItemSlot", v = "data-radix-collection-item", g = Cn.forwardRef((C, b) => { const { scope: S, children: P, ...R } = C, N = Cn.useRef(null), M = et(b, N), j = d(m, S); return Cn.useEffect(() => (j.itemMap.set(N, { ref: N, ...R }), () => void j.itemMap.delete(N))), T.jsx(Or, { [v]: "", ref: M, children: P }) }); g.displayName = m; function x(C) { const b = d(t + "CollectionConsumer", C); return Cn.useCallback(() => { const P = b.collectionRef.current; if (!P) return []; const R = Array.from(P.querySelectorAll(`[${v}]`)); return Array.from(b.itemMap.values()).sort((j, I) => R.indexOf(j.ref.current) - R.indexOf(I.ref.current)) }, [b.collectionRef, b.itemMap]) } return [{ Provider: u, Slot: h, ItemSlot: g }, x, s] } var KC = w.createContext(void 0); function GC(t) { const r = w.useContext(KC); return t || r || "ltr" } function un(t) { const r = w.useRef(t); return w.useEffect(() => { r.current = t }), w.useMemo(() => (...o) => r.current?.(...o), []) } function YC(t, r = globalThis?.document) { const o = un(t); w.useEffect(() => { const s = l => { l.key === "Escape" && o(l) }; return r.addEventListener("keydown", s, { capture: !0 }), () => r.removeEventListener("keydown", s, { capture: !0 }) }, [o, r]) } var XC = "DismissableLayer", zl = "dismissableLayer.update", QC = "dismissableLayer.pointerDownOutside", qC = "dismissableLayer.focusOutside", jh, Oh = w.createContext({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), _h = w.forwardRef((t, r) => { const { disableOutsidePointerEvents: o = !1, onEscapeKeyDown: s, onPointerDownOutside: l, onFocusOutside: d, onInteractOutside: u, onDismiss: f, ...h } = t, m = w.useContext(Oh), [v, g] = w.useState(null), x = v?.ownerDocument ?? globalThis?.document, [, C] = w.useState({}), b = et(r, $ => g($)), S = Array.from(m.layers), [P] = [...m.layersWithOutsidePointerEventsDisabled].slice(-1), R = S.indexOf(P), N = v ? S.indexOf(v) : -1, M = m.layersWithOutsidePointerEventsDisabled.size > 0, j = N >= R, I = eb($ => { const W = $.target, le = [...m.branches].some(oe => oe.contains(W)); !j || le || (l?.($), u?.($), $.defaultPrevented || f?.()) }, x), H = tb($ => { const W = $.target;[...m.branches].some(oe => oe.contains(W)) || (d?.($), u?.($), $.defaultPrevented || f?.()) }, x); return YC($ => { N === m.layers.size - 1 && (s?.($), !$.defaultPrevented && f && ($.preventDefault(), f())) }, x), w.useEffect(() => { if (v) return o && (m.layersWithOutsidePointerEventsDisabled.size === 0 && (jh = x.body.style.pointerEvents, x.body.style.pointerEvents = "none"), m.layersWithOutsidePointerEventsDisabled.add(v)), m.layers.add(v), Ih(), () => { o && m.layersWithOutsidePointerEventsDisabled.size === 1 && (x.body.style.pointerEvents = jh) } }, [v, x, o, m]), w.useEffect(() => () => { v && (m.layers.delete(v), m.layersWithOutsidePointerEventsDisabled.delete(v), Ih()) }, [v, m]), w.useEffect(() => { const $ = () => C({}); return document.addEventListener(zl, $), () => document.removeEventListener(zl, $) }, []), T.jsx(ze.div, { ...h, ref: b, style: { pointerEvents: M ? j ? "auto" : "none" : void 0, ...t.style }, onFocusCapture: Ge(t.onFocusCapture, H.onFocusCapture), onBlurCapture: Ge(t.onBlurCapture, H.onBlurCapture), onPointerDownCapture: Ge(t.onPointerDownCapture, I.onPointerDownCapture) }) }); _h.displayName = XC; var ZC = "DismissableLayerBranch", JC = w.forwardRef((t, r) => { const o = w.useContext(Oh), s = w.useRef(null), l = et(r, s); return w.useEffect(() => { const d = s.current; if (d) return o.branches.add(d), () => { o.branches.delete(d) } }, [o.branches]), T.jsx(ze.div, { ...t, ref: l }) }); JC.displayName = ZC; function eb(t, r = globalThis?.document) { const o = un(t), s = w.useRef(!1), l = w.useRef(() => { }); return w.useEffect(() => { const d = f => { if (f.target && !s.current) { let h = function () { Vh(QC, o, m, { discrete: !0 }) }; const m = { originalEvent: f }; f.pointerType === "touch" ? (r.removeEventListener("click", l.current), l.current = h, r.addEventListener("click", l.current, { once: !0 })) : h() } else r.removeEventListener("click", l.current); s.current = !1 }, u = window.setTimeout(() => { r.addEventListener("pointerdown", d) }, 0); return () => { window.clearTimeout(u), r.removeEventListener("pointerdown", d), r.removeEventListener("click", l.current) } }, [r, o]), { onPointerDownCapture: () => s.current = !0 } } function tb(t, r = globalThis?.document) { const o = un(t), s = w.useRef(!1); return w.useEffect(() => { const l = d => { d.target && !s.current && Vh(qC, o, { originalEvent: d }, { discrete: !1 }) }; return r.addEventListener("focusin", l), () => r.removeEventListener("focusin", l) }, [r, o]), { onFocusCapture: () => s.current = !0, onBlurCapture: () => s.current = !1 } } function Ih() { const t = new CustomEvent(zl); document.dispatchEvent(t) } function Vh(t, r, o, { discrete: s }) { const l = o.originalEvent.target, d = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: o }); r && l.addEventListener(t, r, { once: !0 }), s ? IC(l, d) : l.dispatchEvent(d) } var Bl = 0; function nb() { w.useEffect(() => { const t = document.querySelectorAll("[data-radix-focus-guard]"); return document.body.insertAdjacentElement("afterbegin", t[0] ?? Fh()), document.body.insertAdjacentElement("beforeend", t[1] ?? Fh()), Bl++, () => { Bl === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(r => r.remove()), Bl-- } }, []) } function Fh() { const t = document.createElement("span"); return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", t } var Ul = "focusScope.autoFocusOnMount", Wl = "focusScope.autoFocusOnUnmount", zh = { bubbles: !1, cancelable: !0 }, rb = "FocusScope", Bh = w.forwardRef((t, r) => { const { loop: o = !1, trapped: s = !1, onMountAutoFocus: l, onUnmountAutoFocus: d, ...u } = t, [f, h] = w.useState(null), m = un(l), v = un(d), g = w.useRef(null), x = et(r, S => h(S)), C = w.useRef({ paused: !1, pause() { this.paused = !0 }, resume() { this.paused = !1 } }).current; w.useEffect(() => { if (s) { let S = function (M) { if (C.paused || !f) return; const j = M.target; f.contains(j) ? g.current = j : Nn(g.current, { select: !0 }) }, P = function (M) { if (C.paused || !f) return; const j = M.relatedTarget; j !== null && (f.contains(j) || Nn(g.current, { select: !0 })) }, R = function (M) { if (document.activeElement === document.body) for (const I of M) I.removedNodes.length > 0 && Nn(f) }; document.addEventListener("focusin", S), document.addEventListener("focusout", P); const N = new MutationObserver(R); return f && N.observe(f, { childList: !0, subtree: !0 }), () => { document.removeEventListener("focusin", S), document.removeEventListener("focusout", P), N.disconnect() } } }, [s, f, C.paused]), w.useEffect(() => { if (f) { $h.add(C); const S = document.activeElement; if (!f.contains(S)) { const R = new CustomEvent(Ul, zh); f.addEventListener(Ul, m), f.dispatchEvent(R), R.defaultPrevented || (ob(ub(Uh(f)), { select: !0 }), document.activeElement === S && Nn(f)) } return () => { f.removeEventListener(Ul, m), setTimeout(() => { const R = new CustomEvent(Wl, zh); f.addEventListener(Wl, v), f.dispatchEvent(R), R.defaultPrevented || Nn(S ?? document.body, { select: !0 }), f.removeEventListener(Wl, v), $h.remove(C) }, 0) } } }, [f, m, v, C]); const b = w.useCallback(S => { if (!o && !s || C.paused) return; const P = S.key === "Tab" && !S.altKey && !S.ctrlKey && !S.metaKey, R = document.activeElement; if (P && R) { const N = S.currentTarget, [M, j] = ib(N); M && j ? !S.shiftKey && R === j ? (S.preventDefault(), o && Nn(M, { select: !0 })) : S.shiftKey && R === M && (S.preventDefault(), o && Nn(j, { select: !0 })) : R === N && S.preventDefault() } }, [o, s, C.paused]); return T.jsx(ze.div, { tabIndex: -1, ...u, ref: x, onKeyDown: b }) }); Bh.displayName = rb; function ob(t, { select: r = !1 } = {}) { const o = document.activeElement; for (const s of t) if (Nn(s, { select: r }), document.activeElement !== o) return } function ib(t) { const r = Uh(t), o = Wh(r, t), s = Wh(r.reverse(), t); return [o, s] } function Uh(t) { const r = [], o = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, { acceptNode: s => { const l = s.tagName === "INPUT" && s.type === "hidden"; return s.disabled || s.hidden || l ? NodeFilter.FILTER_SKIP : s.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; o.nextNode();)r.push(o.currentNode); return r } function Wh(t, r) { for (const o of t) if (!sb(o, { upTo: r })) return o } function sb(t, { upTo: r }) { if (getComputedStyle(t).visibility === "hidden") return !0; for (; t;) { if (r !== void 0 && t === r) return !1; if (getComputedStyle(t).display === "none") return !0; t = t.parentElement } return !1 } function ab(t) { return t instanceof HTMLInputElement && "select" in t } function Nn(t, { select: r = !1 } = {}) { if (t && t.focus) { const o = document.activeElement; t.focus({ preventScroll: !0 }), t !== o && ab(t) && r && t.select() } } var $h = lb(); function lb() { let t = []; return { add(r) { const o = t[0]; r !== o && o?.pause(), t = Hh(t, r), t.unshift(r) }, remove(r) { t = Hh(t, r), t[0]?.resume() } } } function Hh(t, r) { const o = [...t], s = o.indexOf(r); return s !== -1 && o.splice(s, 1), o } function ub(t) { return t.filter(r => r.tagName !== "A") } var Et = globalThis?.document ? w.useLayoutEffect : () => { }, cb = C0["useId".toString()] || (() => { }), db = 0; function $l(t) { const [r, o] = w.useState(cb()); return Et(() => { t || o(s => s ?? String(db++)) }, [t]), t || (r ? `radix-${r}` : "") } const fb = ["top", "right", "bottom", "left"], Ht = Math.min, yt = Math.max, Ji = Math.round, es = Math.floor, Mn = t => ({ x: t, y: t }), pb = { left: "right", right: "left", bottom: "top", top: "bottom" }, hb = { start: "end", end: "start" }; function Hl(t, r, o) { return yt(t, Ht(r, o)) } function cn(t, r) { return typeof t == "function" ? t(r) : t } function dn(t) { return t.split("-")[0] } function _r(t) { return t.split("-")[1] } function Kl(t) { return t === "x" ? "y" : "x" } function Gl(t) { return t === "y" ? "height" : "width" } function Ln(t) { return ["top", "bottom"].includes(dn(t)) ? "y" : "x" } function Yl(t) { return Kl(Ln(t)) } function mb(t, r, o) { o === void 0 && (o = !1); const s = _r(t), l = Yl(t), d = Gl(l); let u = l === "x" ? s === (o ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top"; return r.reference[d] > r.floating[d] && (u = ts(u)), [u, ts(u)] } function gb(t) { const r = ts(t); return [Xl(t), r, Xl(r)] } function Xl(t) { return t.replace(/start|end/g, r => hb[r]) } function vb(t, r, o) { const s = ["left", "right"], l = ["right", "left"], d = ["top", "bottom"], u = ["bottom", "top"]; switch (t) { case "top": case "bottom": return o ? r ? l : s : r ? s : l; case "left": case "right": return r ? d : u; default: return [] } } function yb(t, r, o, s) { const l = _r(t); let d = vb(dn(t), o === "start", s); return l && (d = d.map(u => u + "-" + l), r && (d = d.concat(d.map(Xl)))), d } function ts(t) { return t.replace(/left|right|bottom|top/g, r => pb[r]) } function wb(t) { return { top: 0, right: 0, bottom: 0, left: 0, ...t } } function Kh(t) { return typeof t != "number" ? wb(t) : { top: t, right: t, bottom: t, left: t } } function ns(t) { const { x: r, y: o, width: s, height: l } = t; return { width: s, height: l, top: o, left: r, right: r + s, bottom: o + l, x: r, y: o } } function Gh(t, r, o) { let { reference: s, floating: l } = t; const d = Ln(r), u = Yl(r), f = Gl(u), h = dn(r), m = d === "y", v = s.x + s.width / 2 - l.width / 2, g = s.y + s.height / 2 - l.height / 2, x = s[f] / 2 - l[f] / 2; let C; switch (h) { case "top": C = { x: v, y: s.y - l.height }; break; case "bottom": C = { x: v, y: s.y + s.height }; break; case "right": C = { x: s.x + s.width, y: g }; break; case "left": C = { x: s.x - l.width, y: g }; break; default: C = { x: s.x, y: s.y } }switch (_r(r)) { case "start": C[u] -= x * (o && m ? -1 : 1); break; case "end": C[u] += x * (o && m ? -1 : 1); break }return C } const xb = async (t, r, o) => { const { placement: s = "bottom", strategy: l = "absolute", middleware: d = [], platform: u } = o, f = d.filter(Boolean), h = await (u.isRTL == null ? void 0 : u.isRTL(r)); let m = await u.getElementRects({ reference: t, floating: r, strategy: l }), { x: v, y: g } = Gh(m, s, h), x = s, C = {}, b = 0; for (let S = 0; S < f.length; S++) { const { name: P, fn: R } = f[S], { x: N, y: M, data: j, reset: I } = await R({ x: v, y: g, initialPlacement: s, placement: x, strategy: l, middlewareData: C, rects: m, platform: u, elements: { reference: t, floating: r } }); v = N ?? v, g = M ?? g, C = { ...C, [P]: { ...C[P], ...j } }, I && b <= 50 && (b++, typeof I == "object" && (I.placement && (x = I.placement), I.rects && (m = I.rects === !0 ? await u.getElementRects({ reference: t, floating: r, strategy: l }) : I.rects), { x: v, y: g } = Gh(m, x, h)), S = -1) } return { x: v, y: g, placement: x, strategy: l, middlewareData: C } }; async function zo(t, r) { var o; r === void 0 && (r = {}); const { x: s, y: l, platform: d, rects: u, elements: f, strategy: h } = t, { boundary: m = "clippingAncestors", rootBoundary: v = "viewport", elementContext: g = "floating", altBoundary: x = !1, padding: C = 0 } = cn(r, t), b = Kh(C), P = f[x ? g === "floating" ? "reference" : "floating" : g], R = ns(await d.getClippingRect({ element: (o = await (d.isElement == null ? void 0 : d.isElement(P))) == null || o ? P : P.contextElement || await (d.getDocumentElement == null ? void 0 : d.getDocumentElement(f.floating)), boundary: m, rootBoundary: v, strategy: h })), N = g === "floating" ? { x: s, y: l, width: u.floating.width, height: u.floating.height } : u.reference, M = await (d.getOffsetParent == null ? void 0 : d.getOffsetParent(f.floating)), j = await (d.isElement == null ? void 0 : d.isElement(M)) ? await (d.getScale == null ? void 0 : d.getScale(M)) || { x: 1, y: 1 } : { x: 1, y: 1 }, I = ns(d.convertOffsetParentRelativeRectToViewportRelativeRect ? await d.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: f, rect: N, offsetParent: M, strategy: h }) : N); return { top: (R.top - I.top + b.top) / j.y, bottom: (I.bottom - R.bottom + b.bottom) / j.y, left: (R.left - I.left + b.left) / j.x, right: (I.right - R.right + b.right) / j.x } } const Sb = t => ({ name: "arrow", options: t, async fn(r) { const { x: o, y: s, placement: l, rects: d, platform: u, elements: f, middlewareData: h } = r, { element: m, padding: v = 0 } = cn(t, r) || {}; if (m == null) return {}; const g = Kh(v), x = { x: o, y: s }, C = Yl(l), b = Gl(C), S = await u.getDimensions(m), P = C === "y", R = P ? "top" : "left", N = P ? "bottom" : "right", M = P ? "clientHeight" : "clientWidth", j = d.reference[b] + d.reference[C] - x[C] - d.floating[b], I = x[C] - d.reference[C], H = await (u.getOffsetParent == null ? void 0 : u.getOffsetParent(m)); let $ = H ? H[M] : 0; (!$ || !await (u.isElement == null ? void 0 : u.isElement(H))) && ($ = f.floating[M] || d.floating[b]); const W = j / 2 - I / 2, le = $ / 2 - S[b] / 2 - 1, oe = Ht(g[R], le), me = Ht(g[N], le), Z = oe, ge = $ - S[b] - me, ne = $ / 2 - S[b] / 2 + W, J = Hl(Z, ne, ge), se = !h.arrow && _r(l) != null && ne !== J && d.reference[b] / 2 - (ne < Z ? oe : me) - S[b] / 2 < 0, G = se ? ne < Z ? ne - Z : ne - ge : 0; return { [C]: x[C] + G, data: { [C]: J, centerOffset: ne - J - G, ...se && { alignmentOffset: G } }, reset: se } } }), Cb = function (t) { return t === void 0 && (t = {}), { name: "flip", options: t, async fn(r) { var o, s; const { placement: l, middlewareData: d, rects: u, initialPlacement: f, platform: h, elements: m } = r, { mainAxis: v = !0, crossAxis: g = !0, fallbackPlacements: x, fallbackStrategy: C = "bestFit", fallbackAxisSideDirection: b = "none", flipAlignment: S = !0, ...P } = cn(t, r); if ((o = d.arrow) != null && o.alignmentOffset) return {}; const R = dn(l), N = Ln(f), M = dn(f) === f, j = await (h.isRTL == null ? void 0 : h.isRTL(m.floating)), I = x || (M || !S ? [ts(f)] : gb(f)), H = b !== "none"; !x && H && I.push(...yb(f, S, b, j)); const $ = [f, ...I], W = await zo(r, P), le = []; let oe = ((s = d.flip) == null ? void 0 : s.overflows) || []; if (v && le.push(W[R]), g) { const ne = mb(l, u, j); le.push(W[ne[0]], W[ne[1]]) } if (oe = [...oe, { placement: l, overflows: le }], !le.every(ne => ne <= 0)) { var me, Z; const ne = (((me = d.flip) == null ? void 0 : me.index) || 0) + 1, J = $[ne]; if (J) return { data: { index: ne, overflows: oe }, reset: { placement: J } }; let se = (Z = oe.filter(G => G.overflows[0] <= 0).sort((G, F) => G.overflows[1] - F.overflows[1])[0]) == null ? void 0 : Z.placement; if (!se) switch (C) { case "bestFit": { var ge; const G = (ge = oe.filter(F => { if (H) { const Y = Ln(F.placement); return Y === N || Y === "y" } return !0 }).map(F => [F.placement, F.overflows.filter(Y => Y > 0).reduce((Y, X) => Y + X, 0)]).sort((F, Y) => F[1] - Y[1])[0]) == null ? void 0 : ge[0]; G && (se = G); break } case "initialPlacement": se = f; break }if (l !== se) return { reset: { placement: se } } } return {} } } }; function Yh(t, r) { return { top: t.top - r.height, right: t.right - r.width, bottom: t.bottom - r.height, left: t.left - r.width } } function Xh(t) { return fb.some(r => t[r] >= 0) } const bb = function (t) { return t === void 0 && (t = {}), { name: "hide", options: t, async fn(r) { const { rects: o } = r, { strategy: s = "referenceHidden", ...l } = cn(t, r); switch (s) { case "referenceHidden": { const d = await zo(r, { ...l, elementContext: "reference" }), u = Yh(d, o.reference); return { data: { referenceHiddenOffsets: u, referenceHidden: Xh(u) } } } case "escaped": { const d = await zo(r, { ...l, altBoundary: !0 }), u = Yh(d, o.floating); return { data: { escapedOffsets: u, escaped: Xh(u) } } } default: return {} } } } }; async function kb(t, r) { const { placement: o, platform: s, elements: l } = t, d = await (s.isRTL == null ? void 0 : s.isRTL(l.floating)), u = dn(o), f = _r(o), h = Ln(o) === "y", m = ["left", "top"].includes(u) ? -1 : 1, v = d && h ? -1 : 1, g = cn(r, t); let { mainAxis: x, crossAxis: C, alignmentAxis: b } = typeof g == "number" ? { mainAxis: g, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...g }; return f && typeof b == "number" && (C = f === "end" ? b * -1 : b), h ? { x: C * v, y: x * m } : { x: x * m, y: C * v } } const Pb = function (t) { return t === void 0 && (t = 0), { name: "offset", options: t, async fn(r) { var o, s; const { x: l, y: d, placement: u, middlewareData: f } = r, h = await kb(r, t); return u === ((o = f.offset) == null ? void 0 : o.placement) && (s = f.arrow) != null && s.alignmentOffset ? {} : { x: l + h.x, y: d + h.y, data: { ...h, placement: u } } } } }, Eb = function (t) { return t === void 0 && (t = {}), { name: "shift", options: t, async fn(r) { const { x: o, y: s, placement: l } = r, { mainAxis: d = !0, crossAxis: u = !1, limiter: f = { fn: P => { let { x: R, y: N } = P; return { x: R, y: N } } }, ...h } = cn(t, r), m = { x: o, y: s }, v = await zo(r, h), g = Ln(dn(l)), x = Kl(g); let C = m[x], b = m[g]; if (d) { const P = x === "y" ? "top" : "left", R = x === "y" ? "bottom" : "right", N = C + v[P], M = C - v[R]; C = Hl(N, C, M) } if (u) { const P = g === "y" ? "top" : "left", R = g === "y" ? "bottom" : "right", N = b + v[P], M = b - v[R]; b = Hl(N, b, M) } const S = f.fn({ ...r, [x]: C, [g]: b }); return { ...S, data: { x: S.x - o, y: S.y - s } } } } }, Tb = function (t) { return t === void 0 && (t = {}), { options: t, fn(r) { const { x: o, y: s, placement: l, rects: d, middlewareData: u } = r, { offset: f = 0, mainAxis: h = !0, crossAxis: m = !0 } = cn(t, r), v = { x: o, y: s }, g = Ln(l), x = Kl(g); let C = v[x], b = v[g]; const S = cn(f, r), P = typeof S == "number" ? { mainAxis: S, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...S }; if (h) { const M = x === "y" ? "height" : "width", j = d.reference[x] - d.floating[M] + P.mainAxis, I = d.reference[x] + d.reference[M] - P.mainAxis; C < j ? C = j : C > I && (C = I) } if (m) { var R, N; const M = x === "y" ? "width" : "height", j = ["top", "left"].includes(dn(l)), I = d.reference[g] - d.floating[M] + (j && ((R = u.offset) == null ? void 0 : R[g]) || 0) + (j ? 0 : P.crossAxis), H = d.reference[g] + d.reference[M] + (j ? 0 : ((N = u.offset) == null ? void 0 : N[g]) || 0) - (j ? P.crossAxis : 0); b < I ? b = I : b > H && (b = H) } return { [x]: C, [g]: b } } } }, Rb = function (t) { return t === void 0 && (t = {}), { name: "size", options: t, async fn(r) { const { placement: o, rects: s, platform: l, elements: d } = r, { apply: u = () => { }, ...f } = cn(t, r), h = await zo(r, f), m = dn(o), v = _r(o), g = Ln(o) === "y", { width: x, height: C } = s.floating; let b, S; m === "top" || m === "bottom" ? (b = m, S = v === (await (l.isRTL == null ? void 0 : l.isRTL(d.floating)) ? "start" : "end") ? "left" : "right") : (S = m, b = v === "end" ? "top" : "bottom"); const P = C - h.top - h.bottom, R = x - h.left - h.right, N = Ht(C - h[b], P), M = Ht(x - h[S], R), j = !r.middlewareData.shift; let I = N, H = M; if (g ? H = v || j ? Ht(M, R) : R : I = v || j ? Ht(N, P) : P, j && !v) { const W = yt(h.left, 0), le = yt(h.right, 0), oe = yt(h.top, 0), me = yt(h.bottom, 0); g ? H = x - 2 * (W !== 0 || le !== 0 ? W + le : yt(h.left, h.right)) : I = C - 2 * (oe !== 0 || me !== 0 ? oe + me : yt(h.top, h.bottom)) } await u({ ...r, availableWidth: H, availableHeight: I }); const $ = await l.getDimensions(d.floating); return x !== $.width || C !== $.height ? { reset: { rects: !0 } } : {} } } }; function Ir(t) { return Qh(t) ? (t.nodeName || "").toLowerCase() : "#document" } function wt(t) { var r; return (t == null || (r = t.ownerDocument) == null ? void 0 : r.defaultView) || window } function fn(t) { var r; return (r = (Qh(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : r.documentElement } function Qh(t) { return t instanceof Node || t instanceof wt(t).Node } function Kt(t) { return t instanceof Element || t instanceof wt(t).Element } function Gt(t) { return t instanceof HTMLElement || t instanceof wt(t).HTMLElement } function qh(t) { return typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof wt(t).ShadowRoot } function Bo(t) { const { overflow: r, overflowX: o, overflowY: s, display: l } = jt(t); return /auto|scroll|overlay|hidden|clip/.test(r + s + o) && !["inline", "contents"].includes(l) } function Ab(t) { return ["table", "td", "th"].includes(Ir(t)) } function rs(t) { return [":popover-open", ":modal"].some(r => { try { return t.matches(r) } catch { return !1 } }) } function Ql(t) { const r = ql(), o = jt(t); return o.transform !== "none" || o.perspective !== "none" || (o.containerType ? o.containerType !== "normal" : !1) || !r && (o.backdropFilter ? o.backdropFilter !== "none" : !1) || !r && (o.filter ? o.filter !== "none" : !1) || ["transform", "perspective", "filter"].some(s => (o.willChange || "").includes(s)) || ["paint", "layout", "strict", "content"].some(s => (o.contain || "").includes(s)) } function Nb(t) { let r = Dn(t); for (; Gt(r) && !Vr(r);) { if (rs(r)) return null; if (Ql(r)) return r; r = Dn(r) } return null } function ql() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } function Vr(t) { return ["html", "body", "#document"].includes(Ir(t)) } function jt(t) { return wt(t).getComputedStyle(t) } function os(t) { return Kt(t) ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } : { scrollLeft: t.scrollX, scrollTop: t.scrollY } } function Dn(t) { if (Ir(t) === "html") return t; const r = t.assignedSlot || t.parentNode || qh(t) && t.host || fn(t); return qh(r) ? r.host : r } function Zh(t) { const r = Dn(t); return Vr(r) ? t.ownerDocument ? t.ownerDocument.body : t.body : Gt(r) && Bo(r) ? r : Zh(r) } function Uo(t, r, o) { var s; r === void 0 && (r = []), o === void 0 && (o = !0); const l = Zh(t), d = l === ((s = t.ownerDocument) == null ? void 0 : s.body), u = wt(l); return d ? r.concat(u, u.visualViewport || [], Bo(l) ? l : [], u.frameElement && o ? Uo(u.frameElement) : []) : r.concat(l, Uo(l, [], o)) } function Jh(t) { const r = jt(t); let o = parseFloat(r.width) || 0, s = parseFloat(r.height) || 0; const l = Gt(t), d = l ? t.offsetWidth : o, u = l ? t.offsetHeight : s, f = Ji(o) !== d || Ji(s) !== u; return f && (o = d, s = u), { width: o, height: s, $: f } } function Zl(t) { return Kt(t) ? t : t.contextElement } function Fr(t) { const r = Zl(t); if (!Gt(r)) return Mn(1); const o = r.getBoundingClientRect(), { width: s, height: l, $: d } = Jh(r); let u = (d ? Ji(o.width) : o.width) / s, f = (d ? Ji(o.height) : o.height) / l; return (!u || !Number.isFinite(u)) && (u = 1), (!f || !Number.isFinite(f)) && (f = 1), { x: u, y: f } } const Mb = Mn(0); function em(t) { const r = wt(t); return !ql() || !r.visualViewport ? Mb : { x: r.visualViewport.offsetLeft, y: r.visualViewport.offsetTop } } function Lb(t, r, o) { return r === void 0 && (r = !1), !o || r && o !== wt(t) ? !1 : r } function ar(t, r, o, s) { r === void 0 && (r = !1), o === void 0 && (o = !1); const l = t.getBoundingClientRect(), d = Zl(t); let u = Mn(1); r && (s ? Kt(s) && (u = Fr(s)) : u = Fr(t)); const f = Lb(d, o, s) ? em(d) : Mn(0); let h = (l.left + f.x) / u.x, m = (l.top + f.y) / u.y, v = l.width / u.x, g = l.height / u.y; if (d) { const x = wt(d), C = s && Kt(s) ? wt(s) : s; let b = x, S = b.frameElement; for (; S && s && C !== b;) { const P = Fr(S), R = S.getBoundingClientRect(), N = jt(S), M = R.left + (S.clientLeft + parseFloat(N.paddingLeft)) * P.x, j = R.top + (S.clientTop + parseFloat(N.paddingTop)) * P.y; h *= P.x, m *= P.y, v *= P.x, g *= P.y, h += M, m += j, b = wt(S), S = b.frameElement } } return ns({ width: v, height: g, x: h, y: m }) } function Db(t) { let { elements: r, rect: o, offsetParent: s, strategy: l } = t; const d = l === "fixed", u = fn(s), f = r ? rs(r.floating) : !1; if (s === u || f && d) return o; let h = { scrollLeft: 0, scrollTop: 0 }, m = Mn(1); const v = Mn(0), g = Gt(s); if ((g || !g && !d) && ((Ir(s) !== "body" || Bo(u)) && (h = os(s)), Gt(s))) { const x = ar(s); m = Fr(s), v.x = x.x + s.clientLeft, v.y = x.y + s.clientTop } return { width: o.width * m.x, height: o.height * m.y, x: o.x * m.x - h.scrollLeft * m.x + v.x, y: o.y * m.y - h.scrollTop * m.y + v.y } } function jb(t) { return Array.from(t.getClientRects()) } function tm(t) { return ar(fn(t)).left + os(t).scrollLeft } function Ob(t) { const r = fn(t), o = os(t), s = t.ownerDocument.body, l = yt(r.scrollWidth, r.clientWidth, s.scrollWidth, s.clientWidth), d = yt(r.scrollHeight, r.clientHeight, s.scrollHeight, s.clientHeight); let u = -o.scrollLeft + tm(t); const f = -o.scrollTop; return jt(s).direction === "rtl" && (u += yt(r.clientWidth, s.clientWidth) - l), { width: l, height: d, x: u, y: f } } function _b(t, r) { const o = wt(t), s = fn(t), l = o.visualViewport; let d = s.clientWidth, u = s.clientHeight, f = 0, h = 0; if (l) { d = l.width, u = l.height; const m = ql(); (!m || m && r === "fixed") && (f = l.offsetLeft, h = l.offsetTop) } return { width: d, height: u, x: f, y: h } } function Ib(t, r) { const o = ar(t, !0, r === "fixed"), s = o.top + t.clientTop, l = o.left + t.clientLeft, d = Gt(t) ? Fr(t) : Mn(1), u = t.clientWidth * d.x, f = t.clientHeight * d.y, h = l * d.x, m = s * d.y; return { width: u, height: f, x: h, y: m } } function nm(t, r, o) { let s; if (r === "viewport") s = _b(t, o); else if (r === "document") s = Ob(fn(t)); else if (Kt(r)) s = Ib(r, o); else { const l = em(t); s = { ...r, x: r.x - l.x, y: r.y - l.y } } return ns(s) } function rm(t, r) { const o = Dn(t); return o === r || !Kt(o) || Vr(o) ? !1 : jt(o).position === "fixed" || rm(o, r) } function Vb(t, r) { const o = r.get(t); if (o) return o; let s = Uo(t, [], !1).filter(f => Kt(f) && Ir(f) !== "body"), l = null; const d = jt(t).position === "fixed"; let u = d ? Dn(t) : t; for (; Kt(u) && !Vr(u);) { const f = jt(u), h = Ql(u); !h && f.position === "fixed" && (l = null), (d ? !h && !l : !h && f.position === "static" && !!l && ["absolute", "fixed"].includes(l.position) || Bo(u) && !h && rm(t, u)) ? s = s.filter(v => v !== u) : l = f, u = Dn(u) } return r.set(t, s), s } function Fb(t) { let { element: r, boundary: o, rootBoundary: s, strategy: l } = t; const u = [...o === "clippingAncestors" ? rs(r) ? [] : Vb(r, this._c) : [].concat(o), s], f = u[0], h = u.reduce((m, v) => { const g = nm(r, v, l); return m.top = yt(g.top, m.top), m.right = Ht(g.right, m.right), m.bottom = Ht(g.bottom, m.bottom), m.left = yt(g.left, m.left), m }, nm(r, f, l)); return { width: h.right - h.left, height: h.bottom - h.top, x: h.left, y: h.top } } function zb(t) { const { width: r, height: o } = Jh(t); return { width: r, height: o } } function Bb(t, r, o) { const s = Gt(r), l = fn(r), d = o === "fixed", u = ar(t, !0, d, r); let f = { scrollLeft: 0, scrollTop: 0 }; const h = Mn(0); if (s || !s && !d) if ((Ir(r) !== "body" || Bo(l)) && (f = os(r)), s) { const g = ar(r, !0, d, r); h.x = g.x + r.clientLeft, h.y = g.y + r.clientTop } else l && (h.x = tm(l)); const m = u.left + f.scrollLeft - h.x, v = u.top + f.scrollTop - h.y; return { x: m, y: v, width: u.width, height: u.height } } function Jl(t) { return jt(t).position === "static" } function om(t, r) { return !Gt(t) || jt(t).position === "fixed" ? null : r ? r(t) : t.offsetParent } function im(t, r) { const o = wt(t); if (rs(t)) return o; if (!Gt(t)) { let l = Dn(t); for (; l && !Vr(l);) { if (Kt(l) && !Jl(l)) return l; l = Dn(l) } return o } let s = om(t, r); for (; s && Ab(s) && Jl(s);)s = om(s, r); return s && Vr(s) && Jl(s) && !Ql(s) ? o : s || Nb(t) || o } const Ub = async function (t) { const r = this.getOffsetParent || im, o = this.getDimensions, s = await o(t.floating); return { reference: Bb(t.reference, await r(t.floating), t.strategy), floating: { x: 0, y: 0, width: s.width, height: s.height } } }; function Wb(t) { return jt(t).direction === "rtl" } const $b = { convertOffsetParentRelativeRectToViewportRelativeRect: Db, getDocumentElement: fn, getClippingRect: Fb, getOffsetParent: im, getElementRects: Ub, getClientRects: jb, getDimensions: zb, getScale: Fr, isElement: Kt, isRTL: Wb }; function Hb(t, r) { let o = null, s; const l = fn(t); function d() { var f; clearTimeout(s), (f = o) == null || f.disconnect(), o = null } function u(f, h) { f === void 0 && (f = !1), h === void 0 && (h = 1), d(); const { left: m, top: v, width: g, height: x } = t.getBoundingClientRect(); if (f || r(), !g || !x) return; const C = es(v), b = es(l.clientWidth - (m + g)), S = es(l.clientHeight - (v + x)), P = es(m), N = { rootMargin: -C + "px " + -b + "px " + -S + "px " + -P + "px", threshold: yt(0, Ht(1, h)) || 1 }; let M = !0; function j(I) { const H = I[0].intersectionRatio; if (H !== h) { if (!M) return u(); H ? u(!1, H) : s = setTimeout(() => { u(!1, 1e-7) }, 1e3) } M = !1 } try { o = new IntersectionObserver(j, { ...N, root: l.ownerDocument }) } catch { o = new IntersectionObserver(j, N) } o.observe(t) } return u(!0), d } function Kb(t, r, o, s) { s === void 0 && (s = {}); const { ancestorScroll: l = !0, ancestorResize: d = !0, elementResize: u = typeof ResizeObserver == "function", layoutShift: f = typeof IntersectionObserver == "function", animationFrame: h = !1 } = s, m = Zl(t), v = l || d ? [...m ? Uo(m) : [], ...Uo(r)] : []; v.forEach(R => { l && R.addEventListener("scroll", o, { passive: !0 }), d && R.addEventListener("resize", o) }); const g = m && f ? Hb(m, o) : null; let x = -1, C = null; u && (C = new ResizeObserver(R => { let [N] = R; N && N.target === m && C && (C.unobserve(r), cancelAnimationFrame(x), x = requestAnimationFrame(() => { var M; (M = C) == null || M.observe(r) })), o() }), m && !h && C.observe(m), C.observe(r)); let b, S = h ? ar(t) : null; h && P(); function P() { const R = ar(t); S && (R.x !== S.x || R.y !== S.y || R.width !== S.width || R.height !== S.height) && o(), S = R, b = requestAnimationFrame(P) } return o(), () => { var R; v.forEach(N => { l && N.removeEventListener("scroll", o), d && N.removeEventListener("resize", o) }), g?.(), (R = C) == null || R.disconnect(), C = null, h && cancelAnimationFrame(b) } } const Gb = Pb, Yb = Eb, Xb = Cb, Qb = Rb, qb = bb, sm = Sb, Zb = Tb, Jb = (t, r, o) => { const s = new Map, l = { platform: $b, ...o }, d = { ...l.platform, _c: s }; return xb(t, r, { ...l, platform: d }) }; var is = typeof document < "u" ? w.useLayoutEffect : w.useEffect; function ss(t, r) { if (t === r) return !0; if (typeof t != typeof r) return !1; if (typeof t == "function" && t.toString() === r.toString()) return !0; let o, s, l; if (t && r && typeof t == "object") { if (Array.isArray(t)) { if (o = t.length, o !== r.length) return !1; for (s = o; s-- !== 0;)if (!ss(t[s], r[s])) return !1; return !0 } if (l = Object.keys(t), o = l.length, o !== Object.keys(r).length) return !1; for (s = o; s-- !== 0;)if (!{}.hasOwnProperty.call(r, l[s])) return !1; for (s = o; s-- !== 0;) { const d = l[s]; if (!(d === "_owner" && t.$$typeof) && !ss(t[d], r[d])) return !1 } return !0 } return t !== t && r !== r } function am(t) { return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1 } function lm(t, r) { const o = am(t); return Math.round(r * o) / o } function um(t) { const r = w.useRef(t); return is(() => { r.current = t }), r } function ek(t) { t === void 0 && (t = {}); const { placement: r = "bottom", strategy: o = "absolute", middleware: s = [], platform: l, elements: { reference: d, floating: u } = {}, transform: f = !0, whileElementsMounted: h, open: m } = t, [v, g] = w.useState({ x: 0, y: 0, strategy: o, placement: r, middlewareData: {}, isPositioned: !1 }), [x, C] = w.useState(s); ss(x, s) || C(s); const [b, S] = w.useState(null), [P, R] = w.useState(null), N = w.useCallback(G => { G !== H.current && (H.current = G, S(G)) }, []), M = w.useCallback(G => { G !== $.current && ($.current = G, R(G)) }, []), j = d || b, I = u || P, H = w.useRef(null), $ = w.useRef(null), W = w.useRef(v), le = h != null, oe = um(h), me = um(l), Z = w.useCallback(() => { if (!H.current || !$.current) return; const G = { placement: r, strategy: o, middleware: x }; me.current && (G.platform = me.current), Jb(H.current, $.current, G).then(F => { const Y = { ...F, isPositioned: !0 }; ge.current && !ss(W.current, Y) && (W.current = Y, xo.flushSync(() => { g(Y) })) }) }, [x, r, o, me]); is(() => { m === !1 && W.current.isPositioned && (W.current.isPositioned = !1, g(G => ({ ...G, isPositioned: !1 }))) }, [m]); const ge = w.useRef(!1); is(() => (ge.current = !0, () => { ge.current = !1 }), []), is(() => { if (j && (H.current = j), I && ($.current = I), j && I) { if (oe.current) return oe.current(j, I, Z); Z() } }, [j, I, Z, oe, le]); const ne = w.useMemo(() => ({ reference: H, floating: $, setReference: N, setFloating: M }), [N, M]), J = w.useMemo(() => ({ reference: j, floating: I }), [j, I]), se = w.useMemo(() => { const G = { position: o, left: 0, top: 0 }; if (!J.floating) return G; const F = lm(J.floating, v.x), Y = lm(J.floating, v.y); return f ? { ...G, transform: "translate(" + F + "px, " + Y + "px)", ...am(J.floating) >= 1.5 && { willChange: "transform" } } : { position: o, left: F, top: Y } }, [o, f, J.floating, v.x, v.y]); return w.useMemo(() => ({ ...v, update: Z, refs: ne, elements: J, floatingStyles: se }), [v, Z, ne, J, se]) } const tk = t => { function r(o) { return {}.hasOwnProperty.call(o, "current") } return { name: "arrow", options: t, fn(o) { const { element: s, padding: l } = typeof t == "function" ? t(o) : t; return s && r(s) ? s.current != null ? sm({ element: s.current, padding: l }).fn(o) : {} : s ? sm({ element: s, padding: l }).fn(o) : {} } } }, nk = (t, r) => ({ ...Gb(t), options: [t, r] }), rk = (t, r) => ({ ...Yb(t), options: [t, r] }), ok = (t, r) => ({ ...Zb(t), options: [t, r] }), ik = (t, r) => ({ ...Xb(t), options: [t, r] }), sk = (t, r) => ({ ...Qb(t), options: [t, r] }), ak = (t, r) => ({ ...qb(t), options: [t, r] }), lk = (t, r) => ({ ...tk(t), options: [t, r] }); var uk = "Arrow", cm = w.forwardRef((t, r) => { const { children: o, width: s = 10, height: l = 5, ...d } = t; return T.jsx(ze.svg, { ...d, ref: r, width: s, height: l, viewBox: "0 0 30 10", preserveAspectRatio: "none", children: t.asChild ? o : T.jsx("polygon", { points: "0,0 30,0 15,10" }) }) }); cm.displayName = uk; var ck = cm; function dk(t) { const [r, o] = w.useState(void 0); return Et(() => { if (t) { o({ width: t.offsetWidth, height: t.offsetHeight }); const s = new ResizeObserver(l => { if (!Array.isArray(l) || !l.length) return; const d = l[0]; let u, f; if ("borderBoxSize" in d) { const h = d.borderBoxSize, m = Array.isArray(h) ? h[0] : h; u = m.inlineSize, f = m.blockSize } else u = t.offsetWidth, f = t.offsetHeight; o({ width: u, height: f }) }); return s.observe(t, { box: "border-box" }), () => s.unobserve(t) } else o(void 0) }, [t]), r } var eu = "Popper", [dm, fm] = Fl(eu), [fk, pm] = dm(eu), hm = t => { const { __scopePopper: r, children: o } = t, [s, l] = w.useState(null); return T.jsx(fk, { scope: r, anchor: s, onAnchorChange: l, children: o }) }; hm.displayName = eu; var mm = "PopperAnchor", gm = w.forwardRef((t, r) => { const { __scopePopper: o, virtualRef: s, ...l } = t, d = pm(mm, o), u = w.useRef(null), f = et(r, u); return w.useEffect(() => { d.onAnchorChange(s?.current || u.current) }), s ? null : T.jsx(ze.div, { ...l, ref: f }) }); gm.displayName = mm; var tu = "PopperContent", [pk, hk] = dm(tu), vm = w.forwardRef((t, r) => { const { __scopePopper: o, side: s = "bottom", sideOffset: l = 0, align: d = "center", alignOffset: u = 0, arrowPadding: f = 0, avoidCollisions: h = !0, collisionBoundary: m = [], collisionPadding: v = 0, sticky: g = "partial", hideWhenDetached: x = !1, updatePositionStrategy: C = "optimized", onPlaced: b, ...S } = t, P = pm(tu, o), [R, N] = w.useState(null), M = et(r, Q => N(Q)), [j, I] = w.useState(null), H = dk(j), $ = H?.width ?? 0, W = H?.height ?? 0, le = s + (d !== "center" ? "-" + d : ""), oe = typeof v == "number" ? v : { top: 0, right: 0, bottom: 0, left: 0, ...v }, me = Array.isArray(m) ? m : [m], Z = me.length > 0, ge = { padding: oe, boundary: me.filter(gk), altBoundary: Z }, { refs: ne, floatingStyles: J, placement: se, isPositioned: G, middlewareData: F } = ek({ strategy: "fixed", placement: le, whileElementsMounted: (...Q) => Kb(...Q, { animationFrame: C === "always" }), elements: { reference: P.anchor }, middleware: [nk({ mainAxis: l + W, alignmentAxis: u }), h && rk({ mainAxis: !0, crossAxis: !1, limiter: g === "partial" ? ok() : void 0, ...ge }), h && ik({ ...ge }), sk({ ...ge, apply: ({ elements: Q, rects: ue, availableWidth: ye, availableHeight: we }) => { const { width: be, height: Re } = ue.reference, Be = Q.floating.style; Be.setProperty("--radix-popper-available-width", `${ye}px`), Be.setProperty("--radix-popper-available-height", `${we}px`), Be.setProperty("--radix-popper-anchor-width", `${be}px`), Be.setProperty("--radix-popper-anchor-height", `${Re}px`) } }), j && lk({ element: j, padding: f }), vk({ arrowWidth: $, arrowHeight: W }), x && ak({ strategy: "referenceHidden", ...ge })] }), [Y, X] = xm(se), E = un(b); Et(() => { G && E?.() }, [G, E]); const V = F.arrow?.x, ce = F.arrow?.y, ae = F.arrow?.centerOffset !== 0, [Se, ve] = w.useState(); return Et(() => { R && ve(window.getComputedStyle(R).zIndex) }, [R]), T.jsx("div", { ref: ne.setFloating, "data-radix-popper-content-wrapper": "", style: { ...J, transform: G ? J.transform : "translate(0, -200%)", minWidth: "max-content", zIndex: Se, "--radix-popper-transform-origin": [F.transformOrigin?.x, F.transformOrigin?.y].join(" "), ...F.hide?.referenceHidden && { visibility: "hidden", pointerEvents: "none" } }, dir: t.dir, children: T.jsx(pk, { scope: o, placedSide: Y, onArrowChange: I, arrowX: V, arrowY: ce, shouldHideArrow: ae, children: T.jsx(ze.div, { "data-side": Y, "data-align": X, ...S, ref: M, style: { ...S.style, animation: G ? void 0 : "none" } }) }) }) }); vm.displayName = tu; var ym = "PopperArrow", mk = { top: "bottom", right: "left", bottom: "top", left: "right" }, wm = w.forwardRef(function (r, o) { const { __scopePopper: s, ...l } = r, d = hk(ym, s), u = mk[d.placedSide]; return T.jsx("span", { ref: d.onArrowChange, style: { position: "absolute", left: d.arrowX, top: d.arrowY, [u]: 0, transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[d.placedSide], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[d.placedSide], visibility: d.shouldHideArrow ? "hidden" : void 0 }, children: T.jsx(ck, { ...l, ref: o, style: { ...l.style, display: "block" } }) }) }); wm.displayName = ym; function gk(t) { return t !== null } var vk = t => ({ name: "transformOrigin", options: t, fn(r) { const { placement: o, rects: s, middlewareData: l } = r, u = l.arrow?.centerOffset !== 0, f = u ? 0 : t.arrowWidth, h = u ? 0 : t.arrowHeight, [m, v] = xm(o), g = { start: "0%", center: "50%", end: "100%" }[v], x = (l.arrow?.x ?? 0) + f / 2, C = (l.arrow?.y ?? 0) + h / 2; let b = "", S = ""; return m === "bottom" ? (b = u ? g : `${x}px`, S = `${-h}px`) : m === "top" ? (b = u ? g : `${x}px`, S = `${s.floating.height + h}px`) : m === "right" ? (b = `${-h}px`, S = u ? g : `${C}px`) : m === "left" && (b = `${s.floating.width + h}px`, S = u ? g : `${C}px`), { data: { x: b, y: S } } } }); function xm(t) { const [r, o = "center"] = t.split("-"); return [r, o] } var yk = hm, wk = gm, xk = vm, Sk = wm; function Sm({ prop: t, defaultProp: r, onChange: o = () => { } }) { const [s, l] = Ck({ defaultProp: r, onChange: o }), d = t !== void 0, u = d ? t : s, f = un(o), h = w.useCallback(m => { if (d) { const g = typeof m == "function" ? m(t) : m; g !== t && f(g) } else l(m) }, [d, t, l, f]); return [u, h] } function Ck({ defaultProp: t, onChange: r }) { const o = w.useState(t), [s] = o, l = w.useRef(s), d = un(r); return w.useEffect(() => { l.current !== s && (d(s), l.current = s) }, [s, l, d]), o } function bk(t) { const r = w.useRef({ value: t, previous: t }); return w.useMemo(() => (r.current.value !== t && (r.current.previous = r.current.value, r.current.value = t), r.current.previous), [t]) } var kk = "VisuallyHidden", Cm = w.forwardRef((t, r) => T.jsx(ze.span, { ...t, ref: r, style: { position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal", ...t.style } })); Cm.displayName = kk; var Pk = function (t) { if (typeof document > "u") return null; var r = Array.isArray(t) ? t[0] : t; return r.ownerDocument.body }, zr = new WeakMap, as = new WeakMap, ls = {}, nu = 0, bm = function (t) { return t && (t.host || bm(t.parentNode)) }, Ek = function (t, r) { return r.map(function (o) { if (t.contains(o)) return o; var s = bm(o); return s && t.contains(s) ? s : (console.error("aria-hidden", o, "in not contained inside", t, ". Doing nothing"), null) }).filter(function (o) { return !!o }) }, Tk = function (t, r, o, s) { var l = Ek(r, Array.isArray(t) ? t : [t]); ls[o] || (ls[o] = new WeakMap); var d = ls[o], u = [], f = new Set, h = new Set(l), m = function (g) { !g || f.has(g) || (f.add(g), m(g.parentNode)) }; l.forEach(m); var v = function (g) { !g || h.has(g) || Array.prototype.forEach.call(g.children, function (x) { if (f.has(x)) v(x); else try { var C = x.getAttribute(s), b = C !== null && C !== "false", S = (zr.get(x) || 0) + 1, P = (d.get(x) || 0) + 1; zr.set(x, S), d.set(x, P), u.push(x), S === 1 && b && as.set(x, !0), P === 1 && x.setAttribute(o, "true"), b || x.setAttribute(s, "true") } catch (R) { console.error("aria-hidden: cannot operate on ", x, R) } }) }; return v(r), f.clear(), nu++, function () { u.forEach(function (g) { var x = zr.get(g) - 1, C = d.get(g) - 1; zr.set(g, x), d.set(g, C), x || (as.has(g) || g.removeAttribute(s), as.delete(g)), C || g.removeAttribute(o) }), nu--, nu || (zr = new WeakMap, zr = new WeakMap, as = new WeakMap, ls = {}) } }, Rk = function (t, r, o) { o === void 0 && (o = "data-aria-hidden"); var s = Array.from(Array.isArray(t) ? t : [t]), l = r || Pk(t); return l ? (s.push.apply(s, Array.from(l.querySelectorAll("[aria-live]"))), Tk(s, l, o, "aria-hidden")) : function () { return null } }, Yt = function () { return Yt = Object.assign || function (r) { for (var o, s = 1, l = arguments.length; s < l; s++) { o = arguments[s]; for (var d in o) Object.prototype.hasOwnProperty.call(o, d) && (r[d] = o[d]) } return r }, Yt.apply(this, arguments) }; function km(t, r) { var o = {}; for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && r.indexOf(s) < 0 && (o[s] = t[s]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, s = Object.getOwnPropertySymbols(t); l < s.length; l++)r.indexOf(s[l]) < 0 && Object.prototype.propertyIsEnumerable.call(t, s[l]) && (o[s[l]] = t[s[l]]); return o } function Ak(t, r, o) { if (o || arguments.length === 2) for (var s = 0, l = r.length, d; s < l; s++)(d || !(s in r)) && (d || (d = Array.prototype.slice.call(r, 0, s)), d[s] = r[s]); return t.concat(d || Array.prototype.slice.call(r)) } typeof SuppressedError == "function" && SuppressedError; var us = "right-scroll-bar-position", cs = "width-before-scroll-bar", Nk = "with-scroll-bars-hidden", Mk = "--removed-body-scroll-bar-size"; function ru(t, r) { return typeof t == "function" ? t(r) : t && (t.current = r), t } function Lk(t, r) { var o = w.useState(function () { return { value: t, callback: r, facade: { get current() { return o.value }, set current(s) { var l = o.value; l !== s && (o.value = s, o.callback(s, l)) } } } })[0]; return o.callback = r, o.facade } var Dk = typeof window < "u" ? w.useLayoutEffect : w.useEffect, Pm = new WeakMap; function jk(t, r) { var o = Lk(r || null, function (s) { return t.forEach(function (l) { return ru(l, s) }) }); return Dk(function () { var s = Pm.get(o); if (s) { var l = new Set(s), d = new Set(t), u = o.current; l.forEach(function (f) { d.has(f) || ru(f, null) }), d.forEach(function (f) { l.has(f) || ru(f, u) }) } Pm.set(o, t) }, [t]), o } function Ok(t) { return t } function _k(t, r) { r === void 0 && (r = Ok); var o = [], s = !1, l = { read: function () { if (s) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."); return o.length ? o[o.length - 1] : t }, useMedium: function (d) { var u = r(d, s); return o.push(u), function () { o = o.filter(function (f) { return f !== u }) } }, assignSyncMedium: function (d) { for (s = !0; o.length;) { var u = o; o = [], u.forEach(d) } o = { push: function (f) { return d(f) }, filter: function () { return o } } }, assignMedium: function (d) { s = !0; var u = []; if (o.length) { var f = o; o = [], f.forEach(d), u = o } var h = function () { var v = u; u = [], v.forEach(d) }, m = function () { return Promise.resolve().then(h) }; m(), o = { push: function (v) { u.push(v), m() }, filter: function (v) { return u = u.filter(v), o } } } }; return l } function Ik(t) { t === void 0 && (t = {}); var r = _k(null); return r.options = Yt({ async: !0, ssr: !1 }, t), r } var Em = function (t) { var r = t.sideCar, o = km(t, ["sideCar"]); if (!r) throw new Error("Sidecar: please provide `sideCar` property to import the right car"); var s = r.read(); if (!s) throw new Error("Sidecar medium not found"); return w.createElement(s, Yt({}, o)) }; Em.isSideCarExport = !0; function Vk(t, r) { return t.useMedium(r), Em } var Tm = Ik(), ou = function () { }, ds = w.forwardRef(function (t, r) { var o = w.useRef(null), s = w.useState({ onScrollCapture: ou, onWheelCapture: ou, onTouchMoveCapture: ou }), l = s[0], d = s[1], u = t.forwardProps, f = t.children, h = t.className, m = t.removeScrollBar, v = t.enabled, g = t.shards, x = t.sideCar, C = t.noIsolation, b = t.inert, S = t.allowPinchZoom, P = t.as, R = P === void 0 ? "div" : P, N = t.gapMode, M = km(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), j = x, I = jk([o, r]), H = Yt(Yt({}, M), l); return w.createElement(w.Fragment, null, v && w.createElement(j, { sideCar: Tm, removeScrollBar: m, shards: g, noIsolation: C, inert: b, setCallbacks: d, allowPinchZoom: !!S, lockRef: o, gapMode: N }), u ? w.cloneElement(w.Children.only(f), Yt(Yt({}, H), { ref: I })) : w.createElement(R, Yt({}, H, { className: h, ref: I }), f)) }); ds.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }, ds.classNames = { fullWidth: cs, zeroRight: us }; var Rm, Fk = function () { if (Rm) return Rm; if (typeof __webpack_nonce__ < "u") return __webpack_nonce__ }; function zk() { if (!document) return null; var t = document.createElement("style"); t.type = "text/css"; var r = Fk(); return r && t.setAttribute("nonce", r), t } function Bk(t, r) { t.styleSheet ? t.styleSheet.cssText = r : t.appendChild(document.createTextNode(r)) } function Uk(t) { var r = document.head || document.getElementsByTagName("head")[0]; r.appendChild(t) } var Wk = function () { var t = 0, r = null; return { add: function (o) { t == 0 && (r = zk()) && (Bk(r, o), Uk(r)), t++ }, remove: function () { t--, !t && r && (r.parentNode && r.parentNode.removeChild(r), r = null) } } }, $k = function () { var t = Wk(); return function (r, o) { w.useEffect(function () { return t.add(r), function () { t.remove() } }, [r && o]) } }, Am = function () { var t = $k(), r = function (o) { var s = o.styles, l = o.dynamic; return t(s, l), null }; return r }, Hk = { left: 0, top: 0, right: 0, gap: 0 }, iu = function (t) { return parseInt(t || "", 10) || 0 }, Kk = function (t) { var r = window.getComputedStyle(document.body), o = r[t === "padding" ? "paddingLeft" : "marginLeft"], s = r[t === "padding" ? "paddingTop" : "marginTop"], l = r[t === "padding" ? "paddingRight" : "marginRight"]; return [iu(o), iu(s), iu(l)] }, Gk = function (t) { if (t === void 0 && (t = "margin"), typeof window > "u") return Hk; var r = Kk(t), o = document.documentElement.clientWidth, s = window.innerWidth; return { left: r[0], top: r[1], right: r[2], gap: Math.max(0, s - o + r[2] - r[0]) } }, Yk = Am(), Br = "data-scroll-locked", Xk = function (t, r, o, s) {
    var l = t.left, d = t.top, u = t.right, f = t.gap; return o === void 0 && (o = "margin"), `
  .`.concat(Nk, ` {
   overflow: hidden `).concat(s, `;
   padding-right: `).concat(f, "px ").concat(s, `;
  }
  body[`).concat(Br, `] {
    overflow: hidden `).concat(s, `;
    overscroll-behavior: contain;
    `).concat([r && "position: relative ".concat(s, ";"), o === "margin" && `
    padding-left: `.concat(l, `px;
    padding-top: `).concat(d, `px;
    padding-right: `).concat(u, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(f, "px ").concat(s, `;
    `), o === "padding" && "padding-right: ".concat(f, "px ").concat(s, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(us, ` {
    right: `).concat(f, "px ").concat(s, `;
  }
  
  .`).concat(cs, ` {
    margin-right: `).concat(f, "px ").concat(s, `;
  }
  
  .`).concat(us, " .").concat(us, ` {
    right: 0 `).concat(s, `;
  }
  
  .`).concat(cs, " .").concat(cs, ` {
    margin-right: 0 `).concat(s, `;
  }
  
  body[`).concat(Br, `] {
    `).concat(Mk, ": ").concat(f, `px;
  }
`)
  }, Nm = function () { var t = parseInt(document.body.getAttribute(Br) || "0", 10); return isFinite(t) ? t : 0 }, Qk = function () { w.useEffect(function () { return document.body.setAttribute(Br, (Nm() + 1).toString()), function () { var t = Nm() - 1; t <= 0 ? document.body.removeAttribute(Br) : document.body.setAttribute(Br, t.toString()) } }, []) }, qk = function (t) { var r = t.noRelative, o = t.noImportant, s = t.gapMode, l = s === void 0 ? "margin" : s; Qk(); var d = w.useMemo(function () { return Gk(l) }, [l]); return w.createElement(Yk, { styles: Xk(d, !r, l, o ? "" : "!important") }) }, su = !1; if (typeof window < "u") try { var fs = Object.defineProperty({}, "passive", { get: function () { return su = !0, !0 } }); window.addEventListener("test", fs, fs), window.removeEventListener("test", fs, fs) } catch { su = !1 } var Ur = su ? { passive: !1 } : !1, Zk = function (t) { return t.tagName === "TEXTAREA" }, Mm = function (t, r) { var o = window.getComputedStyle(t); return o[r] !== "hidden" && !(o.overflowY === o.overflowX && !Zk(t) && o[r] === "visible") }, Jk = function (t) { return Mm(t, "overflowY") }, eP = function (t) { return Mm(t, "overflowX") }, Lm = function (t, r) { var o = r.ownerDocument, s = r; do { typeof ShadowRoot < "u" && s instanceof ShadowRoot && (s = s.host); var l = Dm(t, s); if (l) { var d = jm(t, s), u = d[1], f = d[2]; if (u > f) return !0 } s = s.parentNode } while (s && s !== o.body); return !1 }, tP = function (t) { var r = t.scrollTop, o = t.scrollHeight, s = t.clientHeight; return [r, o, s] }, nP = function (t) { var r = t.scrollLeft, o = t.scrollWidth, s = t.clientWidth; return [r, o, s] }, Dm = function (t, r) { return t === "v" ? Jk(r) : eP(r) }, jm = function (t, r) { return t === "v" ? tP(r) : nP(r) }, rP = function (t, r) { return t === "h" && r === "rtl" ? -1 : 1 }, oP = function (t, r, o, s, l) { var d = rP(t, window.getComputedStyle(r).direction), u = d * s, f = o.target, h = r.contains(f), m = !1, v = u > 0, g = 0, x = 0; do { var C = jm(t, f), b = C[0], S = C[1], P = C[2], R = S - P - d * b; (b || R) && Dm(t, f) && (g += R, x += b), f instanceof ShadowRoot ? f = f.host : f = f.parentNode } while (!h && f !== document.body || h && (r.contains(f) || r === f)); return (v && (l && Math.abs(g) < 1 || !l && u > g) || !v && (l && Math.abs(x) < 1 || !l && -u > x)) && (m = !0), m }, ps = function (t) { return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0] }, Om = function (t) { return [t.deltaX, t.deltaY] }, _m = function (t) { return t && "current" in t ? t.current : t }, iP = function (t, r) { return t[0] === r[0] && t[1] === r[1] }, sP = function (t) {
    return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`)
  }, aP = 0, Wr = []; function lP(t) { var r = w.useRef([]), o = w.useRef([0, 0]), s = w.useRef(), l = w.useState(aP++)[0], d = w.useState(Am)[0], u = w.useRef(t); w.useEffect(function () { u.current = t }, [t]), w.useEffect(function () { if (t.inert) { document.body.classList.add("block-interactivity-".concat(l)); var S = Ak([t.lockRef.current], (t.shards || []).map(_m), !0).filter(Boolean); return S.forEach(function (P) { return P.classList.add("allow-interactivity-".concat(l)) }), function () { document.body.classList.remove("block-interactivity-".concat(l)), S.forEach(function (P) { return P.classList.remove("allow-interactivity-".concat(l)) }) } } }, [t.inert, t.lockRef.current, t.shards]); var f = w.useCallback(function (S, P) { if ("touches" in S && S.touches.length === 2) return !u.current.allowPinchZoom; var R = ps(S), N = o.current, M = "deltaX" in S ? S.deltaX : N[0] - R[0], j = "deltaY" in S ? S.deltaY : N[1] - R[1], I, H = S.target, $ = Math.abs(M) > Math.abs(j) ? "h" : "v"; if ("touches" in S && $ === "h" && H.type === "range") return !1; var W = Lm($, H); if (!W) return !0; if (W ? I = $ : (I = $ === "v" ? "h" : "v", W = Lm($, H)), !W) return !1; if (!s.current && "changedTouches" in S && (M || j) && (s.current = I), !I) return !0; var le = s.current || I; return oP(le, P, S, le === "h" ? M : j, !0) }, []), h = w.useCallback(function (S) { var P = S; if (!(!Wr.length || Wr[Wr.length - 1] !== d)) { var R = "deltaY" in P ? Om(P) : ps(P), N = r.current.filter(function (I) { return I.name === P.type && (I.target === P.target || P.target === I.shadowParent) && iP(I.delta, R) })[0]; if (N && N.should) { P.cancelable && P.preventDefault(); return } if (!N) { var M = (u.current.shards || []).map(_m).filter(Boolean).filter(function (I) { return I.contains(P.target) }), j = M.length > 0 ? f(P, M[0]) : !u.current.noIsolation; j && P.cancelable && P.preventDefault() } } }, []), m = w.useCallback(function (S, P, R, N) { var M = { name: S, delta: P, target: R, should: N, shadowParent: uP(R) }; r.current.push(M), setTimeout(function () { r.current = r.current.filter(function (j) { return j !== M }) }, 1) }, []), v = w.useCallback(function (S) { o.current = ps(S), s.current = void 0 }, []), g = w.useCallback(function (S) { m(S.type, Om(S), S.target, f(S, t.lockRef.current)) }, []), x = w.useCallback(function (S) { m(S.type, ps(S), S.target, f(S, t.lockRef.current)) }, []); w.useEffect(function () { return Wr.push(d), t.setCallbacks({ onScrollCapture: g, onWheelCapture: g, onTouchMoveCapture: x }), document.addEventListener("wheel", h, Ur), document.addEventListener("touchmove", h, Ur), document.addEventListener("touchstart", v, Ur), function () { Wr = Wr.filter(function (S) { return S !== d }), document.removeEventListener("wheel", h, Ur), document.removeEventListener("touchmove", h, Ur), document.removeEventListener("touchstart", v, Ur) } }, []); var C = t.removeScrollBar, b = t.inert; return w.createElement(w.Fragment, null, b ? w.createElement(d, { styles: sP(l) }) : null, C ? w.createElement(qk, { gapMode: t.gapMode }) : null) } function uP(t) { for (var r = null; t !== null;)t instanceof ShadowRoot && (r = t.host, t = t.host), t = t.parentNode; return r } const cP = Vk(Tm, lP); var Im = w.forwardRef(function (t, r) { return w.createElement(ds, Yt({}, t, { ref: r, sideCar: cP })) }); Im.classNames = ds.classNames; const dP = Im; var fP = [" ", "Enter", "ArrowUp", "ArrowDown"], pP = [" ", "Enter"], Wo = "Select", [hs, ms, hP] = HC(Wo), [$r, YT] = Fl(Wo, [hP, fm]), gs = fm(), [mP, jn] = $r(Wo), [gP, vP] = $r(Wo), Vm = t => { const { __scopeSelect: r, children: o, open: s, defaultOpen: l, onOpenChange: d, value: u, defaultValue: f, onValueChange: h, dir: m, name: v, autoComplete: g, disabled: x, required: C } = t, b = gs(r), [S, P] = w.useState(null), [R, N] = w.useState(null), [M, j] = w.useState(!1), I = GC(m), [H = !1, $] = Sm({ prop: s, defaultProp: l, onChange: d }), [W, le] = Sm({ prop: u, defaultProp: f, onChange: h }), oe = w.useRef(null), me = S ? !!S.closest("form") : !0, [Z, ge] = w.useState(new Set), ne = Array.from(Z).map(J => J.props.value).join(";"); return T.jsx(yk, { ...b, children: T.jsxs(mP, { required: C, scope: r, trigger: S, onTriggerChange: P, valueNode: R, onValueNodeChange: N, valueNodeHasChildren: M, onValueNodeHasChildrenChange: j, contentId: $l(), value: W, onValueChange: le, open: H, onOpenChange: $, dir: I, triggerPointerDownPosRef: oe, disabled: x, children: [T.jsx(hs.Provider, { scope: r, children: T.jsx(gP, { scope: t.__scopeSelect, onNativeOptionAdd: w.useCallback(J => { ge(se => new Set(se).add(J)) }, []), onNativeOptionRemove: w.useCallback(J => { ge(se => { const G = new Set(se); return G.delete(J), G }) }, []), children: o }) }), me ? T.jsxs(lg, { "aria-hidden": !0, required: C, tabIndex: -1, name: v, autoComplete: g, value: W, onChange: J => le(J.target.value), disabled: x, children: [W === void 0 ? T.jsx("option", { value: "" }) : null, Array.from(Z)] }, ne) : null] }) }) }; Vm.displayName = Wo; var Fm = "SelectTrigger", zm = w.forwardRef((t, r) => { const { __scopeSelect: o, disabled: s = !1, ...l } = t, d = gs(o), u = jn(Fm, o), f = u.disabled || s, h = et(r, u.onTriggerChange), m = ms(o), [v, g, x] = ug(b => { const S = m().filter(N => !N.disabled), P = S.find(N => N.value === u.value), R = cg(S, b, P); R !== void 0 && u.onValueChange(R.value) }), C = () => { f || (u.onOpenChange(!0), x()) }; return T.jsx(wk, { asChild: !0, ...d, children: T.jsx(ze.button, { type: "button", role: "combobox", "aria-controls": u.contentId, "aria-expanded": u.open, "aria-required": u.required, "aria-autocomplete": "none", dir: u.dir, "data-state": u.open ? "open" : "closed", disabled: f, "data-disabled": f ? "" : void 0, "data-placeholder": ag(u.value) ? "" : void 0, ...l, ref: h, onClick: Ge(l.onClick, b => { b.currentTarget.focus() }), onPointerDown: Ge(l.onPointerDown, b => { const S = b.target; S.hasPointerCapture(b.pointerId) && S.releasePointerCapture(b.pointerId), b.button === 0 && b.ctrlKey === !1 && (C(), u.triggerPointerDownPosRef.current = { x: Math.round(b.pageX), y: Math.round(b.pageY) }, b.preventDefault()) }), onKeyDown: Ge(l.onKeyDown, b => { const S = v.current !== ""; !(b.ctrlKey || b.altKey || b.metaKey) && b.key.length === 1 && g(b.key), !(S && b.key === " ") && fP.includes(b.key) && (C(), b.preventDefault()) }) }) }) }); zm.displayName = Fm; var Bm = "SelectValue", Um = w.forwardRef((t, r) => { const { __scopeSelect: o, className: s, style: l, children: d, placeholder: u = "", ...f } = t, h = jn(Bm, o), { onValueNodeHasChildrenChange: m } = h, v = d !== void 0, g = et(r, h.onValueNodeChange); return Et(() => { m(v) }, [m, v]), T.jsx(ze.span, { ...f, ref: g, style: { pointerEvents: "none" }, children: ag(h.value) ? T.jsx(T.Fragment, { children: u }) : d }) }); Um.displayName = Bm; var yP = "SelectIcon", Wm = w.forwardRef((t, r) => { const { __scopeSelect: o, children: s, ...l } = t; return T.jsx(ze.span, { "aria-hidden": !0, ...l, ref: r, children: s || "▼" }) }); Wm.displayName = yP; var lr = "SelectContent", $m = w.forwardRef((t, r) => { const o = jn(lr, t.__scopeSelect), [s, l] = w.useState(); if (Et(() => { l(new DocumentFragment) }, []), !o.open) { const d = s; return d ? xo.createPortal(T.jsx(Hm, { scope: t.__scopeSelect, children: T.jsx(hs.Slot, { scope: t.__scopeSelect, children: T.jsx("div", { children: t.children }) }) }), d) : null } return T.jsx(Km, { ...t, ref: r }) }); $m.displayName = lr; var pn = 10, [Hm, On] = $r(lr), wP = "SelectContentImpl", Km = w.forwardRef((t, r) => { const { __scopeSelect: o, position: s = "item-aligned", onCloseAutoFocus: l, onEscapeKeyDown: d, onPointerDownOutside: u, side: f, sideOffset: h, align: m, alignOffset: v, arrowPadding: g, collisionBoundary: x, collisionPadding: C, sticky: b, hideWhenDetached: S, avoidCollisions: P, ...R } = t, N = jn(lr, o), [M, j] = w.useState(null), [I, H] = w.useState(null), $ = et(r, Q => j(Q)), [W, le] = w.useState(null), [oe, me] = w.useState(null), Z = ms(o), [ge, ne] = w.useState(!1), J = w.useRef(!1); w.useEffect(() => { if (M) return Rk(M) }, [M]), nb(); const se = w.useCallback(Q => { const [ue, ...ye] = Z().map(Re => Re.ref.current), [we] = ye.slice(-1), be = document.activeElement; for (const Re of Q) if (Re === be || (Re?.scrollIntoView({ block: "nearest" }), Re === ue && I && (I.scrollTop = 0), Re === we && I && (I.scrollTop = I.scrollHeight), Re?.focus(), document.activeElement !== be)) return }, [Z, I]), G = w.useCallback(() => se([W, M]), [se, W, M]); w.useEffect(() => { ge && G() }, [ge, G]); const { onOpenChange: F, triggerPointerDownPosRef: Y } = N; w.useEffect(() => { if (M) { let Q = { x: 0, y: 0 }; const ue = we => { Q = { x: Math.abs(Math.round(we.pageX) - (Y.current?.x ?? 0)), y: Math.abs(Math.round(we.pageY) - (Y.current?.y ?? 0)) } }, ye = we => { Q.x <= 10 && Q.y <= 10 ? we.preventDefault() : M.contains(we.target) || F(!1), document.removeEventListener("pointermove", ue), Y.current = null }; return Y.current !== null && (document.addEventListener("pointermove", ue), document.addEventListener("pointerup", ye, { capture: !0, once: !0 })), () => { document.removeEventListener("pointermove", ue), document.removeEventListener("pointerup", ye, { capture: !0 }) } } }, [M, F, Y]), w.useEffect(() => { const Q = () => F(!1); return window.addEventListener("blur", Q), window.addEventListener("resize", Q), () => { window.removeEventListener("blur", Q), window.removeEventListener("resize", Q) } }, [F]); const [X, E] = ug(Q => { const ue = Z().filter(be => !be.disabled), ye = ue.find(be => be.ref.current === document.activeElement), we = cg(ue, Q, ye); we && setTimeout(() => we.ref.current.focus()) }), V = w.useCallback((Q, ue, ye) => { const we = !J.current && !ye; (N.value !== void 0 && N.value === ue || we) && (le(Q), we && (J.current = !0)) }, [N.value]), ce = w.useCallback(() => M?.focus(), [M]), ae = w.useCallback((Q, ue, ye) => { const we = !J.current && !ye; (N.value !== void 0 && N.value === ue || we) && me(Q) }, [N.value]), Se = s === "popper" ? au : Gm, ve = Se === au ? { side: f, sideOffset: h, align: m, alignOffset: v, arrowPadding: g, collisionBoundary: x, collisionPadding: C, sticky: b, hideWhenDetached: S, avoidCollisions: P } : {}; return T.jsx(Hm, { scope: o, content: M, viewport: I, onViewportChange: H, itemRefCallback: V, selectedItem: W, onItemLeave: ce, itemTextRefCallback: ae, focusSelectedItem: G, selectedItemText: oe, position: s, isPositioned: ge, searchRef: X, children: T.jsx(dP, { as: Or, allowPinchZoom: !0, children: T.jsx(Bh, { asChild: !0, trapped: N.open, onMountAutoFocus: Q => { Q.preventDefault() }, onUnmountAutoFocus: Ge(l, Q => { N.trigger?.focus({ preventScroll: !0 }), Q.preventDefault() }), children: T.jsx(_h, { asChild: !0, disableOutsidePointerEvents: !0, onEscapeKeyDown: d, onPointerDownOutside: u, onFocusOutside: Q => Q.preventDefault(), onDismiss: () => N.onOpenChange(!1), children: T.jsx(Se, { role: "listbox", id: N.contentId, "data-state": N.open ? "open" : "closed", dir: N.dir, onContextMenu: Q => Q.preventDefault(), ...R, ...ve, onPlaced: () => ne(!0), ref: $, style: { display: "flex", flexDirection: "column", outline: "none", ...R.style }, onKeyDown: Ge(R.onKeyDown, Q => { const ue = Q.ctrlKey || Q.altKey || Q.metaKey; if (Q.key === "Tab" && Q.preventDefault(), !ue && Q.key.length === 1 && E(Q.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(Q.key)) { let we = Z().filter(be => !be.disabled).map(be => be.ref.current); if (["ArrowUp", "End"].includes(Q.key) && (we = we.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(Q.key)) { const be = Q.target, Re = we.indexOf(be); we = we.slice(Re + 1) } setTimeout(() => se(we)), Q.preventDefault() } }) }) }) }) }) }) }); Km.displayName = wP; var xP = "SelectItemAlignedPosition", Gm = w.forwardRef((t, r) => { const { __scopeSelect: o, onPlaced: s, ...l } = t, d = jn(lr, o), u = On(lr, o), [f, h] = w.useState(null), [m, v] = w.useState(null), g = et(r, $ => v($)), x = ms(o), C = w.useRef(!1), b = w.useRef(!0), { viewport: S, selectedItem: P, selectedItemText: R, focusSelectedItem: N } = u, M = w.useCallback(() => { if (d.trigger && d.valueNode && f && m && S && P && R) { const $ = d.trigger.getBoundingClientRect(), W = m.getBoundingClientRect(), le = d.valueNode.getBoundingClientRect(), oe = R.getBoundingClientRect(); if (d.dir !== "rtl") { const be = oe.left - W.left, Re = le.left - be, Be = $.left - Re, Ot = $.width + Be, Hr = Math.max(Ot, W.width), Kr = window.innerWidth - pn, ur = Dh(Re, [pn, Kr - Hr]); f.style.minWidth = Ot + "px", f.style.left = ur + "px" } else { const be = W.right - oe.right, Re = window.innerWidth - le.right - be, Be = window.innerWidth - $.right - Re, Ot = $.width + Be, Hr = Math.max(Ot, W.width), Kr = window.innerWidth - pn, ur = Dh(Re, [pn, Kr - Hr]); f.style.minWidth = Ot + "px", f.style.right = ur + "px" } const me = x(), Z = window.innerHeight - pn * 2, ge = S.scrollHeight, ne = window.getComputedStyle(m), J = parseInt(ne.borderTopWidth, 10), se = parseInt(ne.paddingTop, 10), G = parseInt(ne.borderBottomWidth, 10), F = parseInt(ne.paddingBottom, 10), Y = J + se + ge + F + G, X = Math.min(P.offsetHeight * 5, Y), E = window.getComputedStyle(S), V = parseInt(E.paddingTop, 10), ce = parseInt(E.paddingBottom, 10), ae = $.top + $.height / 2 - pn, Se = Z - ae, ve = P.offsetHeight / 2, Q = P.offsetTop + ve, ue = J + se + Q, ye = Y - ue; if (ue <= ae) { const be = P === me[me.length - 1].ref.current; f.style.bottom = "0px"; const Re = m.clientHeight - S.offsetTop - S.offsetHeight, Be = Math.max(Se, ve + (be ? ce : 0) + Re + G), Ot = ue + Be; f.style.height = Ot + "px" } else { const be = P === me[0].ref.current; f.style.top = "0px"; const Be = Math.max(ae, J + S.offsetTop + (be ? V : 0) + ve) + ye; f.style.height = Be + "px", S.scrollTop = ue - ae + S.offsetTop } f.style.margin = `${pn}px 0`, f.style.minHeight = X + "px", f.style.maxHeight = Z + "px", s?.(), requestAnimationFrame(() => C.current = !0) } }, [x, d.trigger, d.valueNode, f, m, S, P, R, d.dir, s]); Et(() => M(), [M]); const [j, I] = w.useState(); Et(() => { m && I(window.getComputedStyle(m).zIndex) }, [m]); const H = w.useCallback($ => { $ && b.current === !0 && (M(), N?.(), b.current = !1) }, [M, N]); return T.jsx(CP, { scope: o, contentWrapper: f, shouldExpandOnScrollRef: C, onScrollButtonChange: H, children: T.jsx("div", { ref: h, style: { display: "flex", flexDirection: "column", position: "fixed", zIndex: j }, children: T.jsx(ze.div, { ...l, ref: g, style: { boxSizing: "border-box", maxHeight: "100%", ...l.style } }) }) }) }); Gm.displayName = xP; var SP = "SelectPopperPosition", au = w.forwardRef((t, r) => { const { __scopeSelect: o, align: s = "start", collisionPadding: l = pn, ...d } = t, u = gs(o); return T.jsx(xk, { ...u, ...d, ref: r, align: s, collisionPadding: l, style: { boxSizing: "border-box", ...d.style, "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-select-content-available-width": "var(--radix-popper-available-width)", "--radix-select-content-available-height": "var(--radix-popper-available-height)", "--radix-select-trigger-width": "var(--radix-popper-anchor-width)", "--radix-select-trigger-height": "var(--radix-popper-anchor-height)" } }) }); au.displayName = SP; var [CP, lu] = $r(lr, {}), uu = "SelectViewport", Ym = w.forwardRef((t, r) => { const { __scopeSelect: o, nonce: s, ...l } = t, d = On(uu, o), u = lu(uu, o), f = et(r, d.onViewportChange), h = w.useRef(0); return T.jsxs(T.Fragment, { children: [T.jsx("style", { dangerouslySetInnerHTML: { __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}" }, nonce: s }), T.jsx(hs.Slot, { scope: o, children: T.jsx(ze.div, { "data-radix-select-viewport": "", role: "presentation", ...l, ref: f, style: { position: "relative", flex: 1, overflow: "auto", ...l.style }, onScroll: Ge(l.onScroll, m => { const v = m.currentTarget, { contentWrapper: g, shouldExpandOnScrollRef: x } = u; if (x?.current && g) { const C = Math.abs(h.current - v.scrollTop); if (C > 0) { const b = window.innerHeight - pn * 2, S = parseFloat(g.style.minHeight), P = parseFloat(g.style.height), R = Math.max(S, P); if (R < b) { const N = R + C, M = Math.min(b, N), j = N - M; g.style.height = M + "px", g.style.bottom === "0px" && (v.scrollTop = j > 0 ? j : 0, g.style.justifyContent = "flex-end") } } } h.current = v.scrollTop }) }) })] }) }); Ym.displayName = uu; var Xm = "SelectGroup", [bP, kP] = $r(Xm), PP = w.forwardRef((t, r) => { const { __scopeSelect: o, ...s } = t, l = $l(); return T.jsx(bP, { scope: o, id: l, children: T.jsx(ze.div, { role: "group", "aria-labelledby": l, ...s, ref: r }) }) }); PP.displayName = Xm; var Qm = "SelectLabel", qm = w.forwardRef((t, r) => { const { __scopeSelect: o, ...s } = t, l = kP(Qm, o); return T.jsx(ze.div, { id: l.id, ...s, ref: r }) }); qm.displayName = Qm; var vs = "SelectItem", [EP, Zm] = $r(vs), Jm = w.forwardRef((t, r) => { const { __scopeSelect: o, value: s, disabled: l = !1, textValue: d, ...u } = t, f = jn(vs, o), h = On(vs, o), m = f.value === s, [v, g] = w.useState(d ?? ""), [x, C] = w.useState(!1), b = et(r, R => h.itemRefCallback?.(R, s, l)), S = $l(), P = () => { l || (f.onValueChange(s), f.onOpenChange(!1)) }; if (s === "") throw new Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."); return T.jsx(EP, { scope: o, value: s, disabled: l, textId: S, isSelected: m, onItemTextChange: w.useCallback(R => { g(N => N || (R?.textContent ?? "").trim()) }, []), children: T.jsx(hs.ItemSlot, { scope: o, value: s, disabled: l, textValue: v, children: T.jsx(ze.div, { role: "option", "aria-labelledby": S, "data-highlighted": x ? "" : void 0, "aria-selected": m && x, "data-state": m ? "checked" : "unchecked", "aria-disabled": l || void 0, "data-disabled": l ? "" : void 0, tabIndex: l ? void 0 : -1, ...u, ref: b, onFocus: Ge(u.onFocus, () => C(!0)), onBlur: Ge(u.onBlur, () => C(!1)), onPointerUp: Ge(u.onPointerUp, P), onPointerMove: Ge(u.onPointerMove, R => { l ? h.onItemLeave?.() : R.currentTarget.focus({ preventScroll: !0 }) }), onPointerLeave: Ge(u.onPointerLeave, R => { R.currentTarget === document.activeElement && h.onItemLeave?.() }), onKeyDown: Ge(u.onKeyDown, R => { h.searchRef?.current !== "" && R.key === " " || (pP.includes(R.key) && P(), R.key === " " && R.preventDefault()) }) }) }) }) }); Jm.displayName = vs; var $o = "SelectItemText", eg = w.forwardRef((t, r) => { const { __scopeSelect: o, className: s, style: l, ...d } = t, u = jn($o, o), f = On($o, o), h = Zm($o, o), m = vP($o, o), [v, g] = w.useState(null), x = et(r, R => g(R), h.onItemTextChange, R => f.itemTextRefCallback?.(R, h.value, h.disabled)), C = v?.textContent, b = w.useMemo(() => T.jsx("option", { value: h.value, disabled: h.disabled, children: C }, h.value), [h.disabled, h.value, C]), { onNativeOptionAdd: S, onNativeOptionRemove: P } = m; return Et(() => (S(b), () => P(b)), [S, P, b]), T.jsxs(T.Fragment, { children: [T.jsx(ze.span, { id: h.textId, ...d, ref: x }), h.isSelected && u.valueNode && !u.valueNodeHasChildren ? xo.createPortal(d.children, u.valueNode) : null] }) }); eg.displayName = $o; var tg = "SelectItemIndicator", ng = w.forwardRef((t, r) => { const { __scopeSelect: o, ...s } = t; return Zm(tg, o).isSelected ? T.jsx(ze.span, { "aria-hidden": !0, ...s, ref: r }) : null }); ng.displayName = tg; var cu = "SelectScrollUpButton", rg = w.forwardRef((t, r) => { const o = On(cu, t.__scopeSelect), s = lu(cu, t.__scopeSelect), [l, d] = w.useState(!1), u = et(r, s.onScrollButtonChange); return Et(() => { if (o.viewport && o.isPositioned) { let f = function () { const m = h.scrollTop > 0; d(m) }; const h = o.viewport; return f(), h.addEventListener("scroll", f), () => h.removeEventListener("scroll", f) } }, [o.viewport, o.isPositioned]), l ? T.jsx(ig, { ...t, ref: u, onAutoScroll: () => { const { viewport: f, selectedItem: h } = o; f && h && (f.scrollTop = f.scrollTop - h.offsetHeight) } }) : null }); rg.displayName = cu; var du = "SelectScrollDownButton", og = w.forwardRef((t, r) => { const o = On(du, t.__scopeSelect), s = lu(du, t.__scopeSelect), [l, d] = w.useState(!1), u = et(r, s.onScrollButtonChange); return Et(() => { if (o.viewport && o.isPositioned) { let f = function () { const m = h.scrollHeight - h.clientHeight, v = Math.ceil(h.scrollTop) < m; d(v) }; const h = o.viewport; return f(), h.addEventListener("scroll", f), () => h.removeEventListener("scroll", f) } }, [o.viewport, o.isPositioned]), l ? T.jsx(ig, { ...t, ref: u, onAutoScroll: () => { const { viewport: f, selectedItem: h } = o; f && h && (f.scrollTop = f.scrollTop + h.offsetHeight) } }) : null }); og.displayName = du; var ig = w.forwardRef((t, r) => { const { __scopeSelect: o, onAutoScroll: s, ...l } = t, d = On("SelectScrollButton", o), u = w.useRef(null), f = ms(o), h = w.useCallback(() => { u.current !== null && (window.clearInterval(u.current), u.current = null) }, []); return w.useEffect(() => () => h(), [h]), Et(() => { f().find(v => v.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" }) }, [f]), T.jsx(ze.div, { "aria-hidden": !0, ...l, ref: r, style: { flexShrink: 0, ...l.style }, onPointerDown: Ge(l.onPointerDown, () => { u.current === null && (u.current = window.setInterval(s, 50)) }), onPointerMove: Ge(l.onPointerMove, () => { d.onItemLeave?.(), u.current === null && (u.current = window.setInterval(s, 50)) }), onPointerLeave: Ge(l.onPointerLeave, () => { h() }) }) }), TP = "SelectSeparator", sg = w.forwardRef((t, r) => { const { __scopeSelect: o, ...s } = t; return T.jsx(ze.div, { "aria-hidden": !0, ...s, ref: r }) }); sg.displayName = TP; var fu = "SelectArrow", RP = w.forwardRef((t, r) => { const { __scopeSelect: o, ...s } = t, l = gs(o), d = jn(fu, o), u = On(fu, o); return d.open && u.position === "popper" ? T.jsx(Sk, { ...l, ...s, ref: r }) : null }); RP.displayName = fu; function ag(t) { return t === "" || t === void 0 } var lg = w.forwardRef((t, r) => { const { value: o, ...s } = t, l = w.useRef(null), d = et(r, l), u = bk(o); return w.useEffect(() => { const f = l.current, h = window.HTMLSelectElement.prototype, v = Object.getOwnPropertyDescriptor(h, "value").set; if (u !== o && v) { const g = new Event("change", { bubbles: !0 }); v.call(f, o), f.dispatchEvent(g) } }, [u, o]), T.jsx(Cm, { asChild: !0, children: T.jsx("select", { ...s, ref: d, defaultValue: o }) }) }); lg.displayName = "BubbleSelect"; function ug(t) { const r = un(t), o = w.useRef(""), s = w.useRef(0), l = w.useCallback(u => { const f = o.current + u; r(f), function h(m) { o.current = m, window.clearTimeout(s.current), m !== "" && (s.current = window.setTimeout(() => h(""), 1e3)) }(f) }, [r]), d = w.useCallback(() => { o.current = "", window.clearTimeout(s.current) }, []); return w.useEffect(() => () => window.clearTimeout(s.current), []), [o, l, d] } function cg(t, r, o) { const l = r.length > 1 && Array.from(r).every(m => m === r[0]) ? r[0] : r, d = o ? t.indexOf(o) : -1; let u = AP(t, Math.max(d, 0)); l.length === 1 && (u = u.filter(m => m !== o)); const h = u.find(m => m.textValue.toLowerCase().startsWith(l.toLowerCase())); return h !== o ? h : void 0 } function AP(t, r) { return t.map((o, s) => t[(r + s) % t.length]) } var NP = Vm, dg = zm, MP = Um, LP = Wm, fg = $m, DP = Ym, pg = qm, hg = Jm, jP = eg, OP = ng, mg = rg, gg = og, vg = sg; const _P = NP, IP = MP, yg = w.forwardRef(({ className: t, children: r, ...o }, s) => T.jsxs(dg, { ref: s, className: Oe("flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1", t), ...o, children: [r, T.jsx(LP, { asChild: !0, children: T.jsx(Sd, { className: "h-4 w-4 opacity-50" }) })] })); yg.displayName = dg.displayName; const wg = w.forwardRef(({ className: t, ...r }, o) => T.jsx(mg, { ref: o, className: Oe("flex cursor-default items-center justify-center py-1", t), ...r, children: T.jsx(T0, { className: "h-4 w-4" }) })); wg.displayName = mg.displayName; const xg = w.forwardRef(({ className: t, ...r }, o) => T.jsx(gg, { ref: o, className: Oe("flex cursor-default items-center justify-center py-1", t), ...r, children: T.jsx(Sd, { className: "h-4 w-4" }) })); xg.displayName = gg.displayName; const Sg = w.forwardRef(({ className: t, children: r, position: o = "popper", ...s }, l) => T.jsxs(fg, { ref: l, className: Oe("relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", o === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", t), position: o, ...s, children: [T.jsx(wg, {}), T.jsx(DP, { className: Oe("p-1", o === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"), children: r }), T.jsx(xg, {})] })); Sg.displayName = fg.displayName; const VP = w.forwardRef(({ className: t, ...r }, o) => T.jsx(pg, { ref: o, className: Oe("py-1.5 pl-8 pr-2 text-sm font-semibold", t), ...r })); VP.displayName = pg.displayName; const Cg = w.forwardRef(({ className: t, children: r, ...o }, s) => T.jsxs(hg, { ref: s, className: Oe("relative  flex w-full cursor-pointer select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground ", t), ...o, children: [T.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: T.jsx(OP, { children: T.jsx(xd, { className: "h-4 w-4" }) }) }), T.jsx(jP, { children: r })] })); Cg.displayName = hg.displayName; const FP = w.forwardRef(({ className: t, ...r }, o) => T.jsx(vg, { ref: o, className: Oe("-mx-1 my-1 h-px bg-muted", t), ...r })); FP.displayName = vg.displayName; const ys = w.forwardRef(({ className: t, ...r }, o) => T.jsx("div", { ref: o, className: Oe("rounded-lg border bg-card text-card-foreground shadow-sm", t), ...r })); ys.displayName = "Card"; const pu = w.forwardRef(({ className: t, ...r }, o) => T.jsx("div", { ref: o, className: Oe("flex flex-col space-y-1.5 p-6", t), ...r })); pu.displayName = "CardHeader"; const hu = w.forwardRef(({ className: t, ...r }, o) => T.jsx("h3", { ref: o, className: Oe("text-2xl font-semibold leading-none tracking-tight", t), ...r })); hu.displayName = "CardTitle"; const mu = w.forwardRef(({ className: t, ...r }, o) => T.jsx("p", { ref: o, className: Oe("text-sm text-muted-foreground", t), ...r })); mu.displayName = "CardDescription"; const ws = w.forwardRef(({ className: t, ...r }, o) => T.jsx("div", { ref: o, className: Oe("p-6 pt-0", t), ...r })); ws.displayName = "CardContent"; const gu = w.forwardRef(({ className: t, ...r }, o) => T.jsx("div", { ref: o, className: Oe("flex items-center p-6 pt-0", t), ...r })); gu.displayName = "CardFooter"; const bg = { AL: "Alabama", AK: "Alaska", AZ: "Arizona", AR: "Arkansas", CA: "California", CO: "Colorado", CT: "Connecticut", DE: "Delaware", DC: "District Of Columbia", FL: "Florida", GA: "Georgia", GU: "Guam", HI: "Hawaii", ID: "Idaho", IL: "Illinois", IN: "Indiana", IA: "Iowa", KS: "Kansas", KY: "Kentucky", LA: "Louisiana", ME: "Maine", MD: "Maryland", MA: "Massachusetts", MI: "Michigan", MN: "Minnesota", MS: "Mississippi", MO: "Missouri", MT: "Montana", NE: "Nebraska", NV: "Nevada", NH: "New Hampshire", NJ: "New Jersey", NM: "New Mexico", NY: "New York", NC: "North Carolina", ND: "North Dakota", OH: "Ohio", OK: "Oklahoma", OR: "Oregon", PW: "Palau", PA: "Pennsylvania", PR: "Puerto Rico", RI: "Rhode Island", SC: "South Carolina", SD: "South Dakota", TN: "Tennessee", TX: "Texas", UT: "Utah", VT: "Vermont", VI: "Virgin Islands", VA: "Virginia", WA: "Washington", WV: "West Virginia", WI: "Wisconsin", WY: "Wyoming" }, kg = w.forwardRef((t, r) => { const [o, s] = w.useState(t.flowData.flows.data.nodes[0]?.id), [l, d] = w.useState([]), [u, f] = w.useState(0), [h, m] = w.useState([]), [v, g] = w.useState(!1), [x, C] = w.useState(!1), [b, S] = w.useState(!1), [P, R] = w.useState(""), [N, M] = w.useState(""), [j, I] = w.useState(""), [H, $] = w.useState(""), [W, le] = w.useState(""), [oe, me] = w.useState(""), [Z, ge] = w.useState(""), [ne, J] = w.useState({ length: 0, width: 0, radius: 0 }); w.useEffect(() => { l.length > 0 ? t.onShowGoBackButton() : t.onHideGoBackButton() }, [l]), w.useEffect(() => { d([]), m([]) }, []); const se = async () => { if (P === "" || N === "" || j === "" || H === "" || W === "" || oe === "") { S(!0); return } const E = { customer: { firstLastName: P, email: N, phone: j, address: H, USAState: W, zip: oe, comments: Z }, history: l }; t.onCallSubmit(E) }, G = t.flowData.flows.data.nodes.find(E => E.id === o), F = E => { if (!G) return; let V; if (G.type === "measurements" ? V = { typeofArea: v ? "circular" : "rectangular", length: ne.length, width: ne.width, radius: ne.radius } : V = G.data.metadata.childComponent.handles.find(ae => ae.id === E)?.content, !V) return; const ce = t.flowData.flows.data.edges.find(ae => ae.source === o && ae.sourceHandle === E); if (ce) { const ae = ce.target, Se = !t.flowData.flows.data.edges.some(be => be.source === ae), ve = l.length + 1, Q = be => { const Re = t.flowData.flows.data.edges.filter(Be => Be.source === be); return Re.length === 0 ? 0 : 1 + Math.max(...Re.map(Be => Q(Be.target))) }, ue = Q(ae), ye = ve + ue, we = Se ? 100 : ve / ye * 100; f(we), d([...l, { nodeId: o, question: G.data.metadata.childComponent.question, selectedHandleId: E, answer: V }]), m([...h, we]), s(ae) } else console.log("End of steps or handle not connected."), f(100), m([...h, 100]) }, Y = () => { if (l.length > 0) { const E = l[l.length - 1], V = l.slice(0, l.length - 1), ce = h.slice(0, h.length - 1), ae = ce[ce.length - 1] || 0; s(E?.nodeId || ""), d(V), f(ae), m(ce) } }, X = E => { le(E) }; return w.useImperativeHandle(r, () => ({ callGoBack() { Y() } })), T.jsx("div", { className: "flex flex-1 w-full mt-2 no-scrollbar overflow-y-scroll flex-col items-center", children: t.flowData.flows.data.nodes.length === 0 || !o ? T.jsxs("div", { className: "flex flex-1 flex-col items-center justify-center space-y-4 text-center", children: [T.jsx("h2", { className: "text-3xl font-bold", children: "Loading..." }), T.jsx("p", { className: "text-muted-foreground", children: "Please wait while we load the questions." }), T.jsx("img", { className: "h-10 w-10 animate-spin text-white opacity-65", src: "/_static/loading.png" })] }) : T.jsxs(T.Fragment, { children: [T.jsx("div", { className: "absolute top-0 h-2 w-full bg-gray-100", children: T.jsx(sr.div, { className: "h-2 bg-black", initial: { width: 0 }, animate: { width: `${u}%` }, transition: { duration: .5 } }) }), G.type != "client_info" && T.jsxs("div", { className: "mb-6 flex min-h-44 w-full flex-col justify-center space-y-4 border-b bg-gray-50 px-3 py-8 text-center", children: [T.jsx("h2", { className: "text-xl font-bold sm:text-3xl", children: G?.data.metadata.childComponent.question }), T.jsx("p", { className: "text-muted-foreground", children: G?.data.metadata.description })] }), ["custom", "start"].includes(G.type) && T.jsx(T.Fragment, { children: G?.data.metadata.childComponent.handles.some(E => E.image) ? T.jsx("div", { className: "grid h-full grid-cols-2 gap-2 md:grid-cols-3 px-2", children: G?.data.metadata.childComponent.handles.map(E => T.jsxs(ys, { className: "cursor-pointer hover:shadow-md flex flex-col", onClick: () => F(E.id), children: [T.jsxs(ws, { className: "flex flex-col flex-1 items-center justify-start p-1.5", children: [T.jsx("img", { src: E.image ? `https://kxfxmsowfzmimavqqned.supabase.co/storage/v1/object/public/qt/assets/${E.image}` : "https://kxfxmsowfzmimavqqned.supabase.co/storage/v1/object/public/qt/assets/placeholder.svg", width: "200", height: "200", alt: E.content, className: "aspect-square overflow-hidden rounded-md object-cover" }), T.jsx("div", { className: "mt-4 text-center", children: T.jsx("h3", { className: "py-3 text-lg font-semibold", children: E.content }) })] }), T.jsx(gu, { className: "px-3 pb-3", children: T.jsx(Fo, { onClick: () => F(E.id), className: "w-full hover:shadow-md", children: "Add to Quote" }) })] }, E.id)) }) : T.jsx("div", { className: "mt-8 flex flex-1 px-3 flex-col items-center justify-center", children: G?.data.metadata.childComponent.handles.map(E => T.jsx(Fo, { onClick: () => F(E.id), className: "mb-4 w-full  min-w-72 p-6 text-xl hover:shadow-md", children: E.content }, E.id)) }) }), G.type == "measurements" && T.jsxs(ys, { className: "w-full max-w-md border-none shadow-none mx-auto p-6 sm:p-8", children: [T.jsxs(pu, { children: [T.jsx(hu, { children: "Enter the Area of Your Project" }), T.jsx(mu, { children: "Enter the dimensions of your project area." })] }), x && T.jsxs(Nh, { variant: "destructive", className: "py-3 my-2", children: [T.jsx(R0, { className: "h-4 w-4" }), T.jsx(Mh, { className: "text-left", children: "Error" }), T.jsx(Lh, { className: "text-left", children: "please enter your project area dimensions" })] }), T.jsx(ws, { children: T.jsxs("div", { className: "grid gap-4", children: [v ? T.jsxs("div", { className: "space-y-2", children: [T.jsx(Dt, { htmlFor: "width", children: "Radius Feet" }), T.jsx(ln, { id: "width", type: "number", placeholder: "0", defaultValue: ne.radius, min: "0", onChange: E => { J({ ...ne, radius: E.target.value }), C(!1) } })] }) : T.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [T.jsxs("div", { className: "space-y-2", children: [T.jsx(Dt, { htmlFor: "length", children: "Length (ft)" }), T.jsx(ln, { id: "length", type: "number", placeholder: "0", defaultValue: ne.length, min: "0", onChange: E => { J({ ...ne, length: E.target.value }), C(!1) } })] }), T.jsxs("div", { className: "space-y-2", children: [T.jsx(Dt, { htmlFor: "width", children: "Width (ft)" }), T.jsx(ln, { id: "width", type: "number", defaultValue: ne.width, placeholder: "0", min: "0", onChange: E => { C(!1), J({ ...ne, width: E.target.value }) } })] })] }), T.jsx("div", { className: "flex items-center gap-2", children: T.jsx("div", { className: "cursor-pointer", onClick: () => g(!v), children: T.jsx("p", { children: v ? "My Project Area is Rectangular?" : "My Project Area is Circular?" }) }) }), T.jsx(Fo, { type: "submit", onClick: () => { if (v && ne.radius === 0 || !v && (ne.length === 0 || ne.width === 0)) { C(!0); return } F(G.data.metadata.childComponent.handles[0].id) }, className: "w-full", children: "Submit Project Area" })] }) })] }), G.type == "client_info" && T.jsxs(ys, { className: "my-8 mb-2 w-full border-none shadow-none", children: [T.jsxs(pu, { children: [T.jsx(hu, { children: G.data.metadata.childComponent.question }), T.jsx(mu, { children: G.data.metadata.description })] }), T.jsx(ws, { className: "space-y-6", children: T.jsxs("div", { className: "grid gap-4", children: [T.jsxs("div", { className: "grid gap-2 ", children: [T.jsx(Dt, { className: Je("text-left ", b && P.length <= 0 ? "text-red-400" : ""), htmlFor: "name", children: "First & Last Name" }), T.jsx(ln, { onChange: E => { R(E.target.value) }, id: "name", className: Je("grid gap-2 ", b && P.length <= 0 ? "bg-red-50 focus-visible:ring-red-500 border-red-500 focus-visible:border-transparent" : ""), placeholder: "Enter your first and last name" })] }), T.jsxs("div", { className: "grid gap-2", children: [T.jsx(Dt, { className: Je("text-left ", b && N.length <= 0 ? "text-red-400" : ""), htmlFor: "email", children: "Email" }), T.jsx(ln, { onChange: E => { M(E.target.value) }, className: Je("grid gap-2 ", b && N.length <= 0 ? "bg-red-50 focus-visible:ring-red-500 border-red-500 focus-visible:border-transparent" : ""), id: "email", placeholder: "Enter your email address" })] }), T.jsxs("div", { className: "grid gap-2", children: [T.jsx(Dt, { className: Je("text-left ", b && j.length <= 0 ? "text-red-400" : ""), htmlFor: "phone", children: "Phone Number" }), T.jsx(ln, { onChange: E => { I(E.target.value) }, className: Je("grid gap-2 ", b && j.length <= 0 ? "bg-red-50 focus-visible:ring-red-500 border-red-500 focus-visible:border-transparent" : ""), id: "phone", placeholder: "Enter your phone number" })] }), T.jsxs("div", { className: "grid gap-2", children: [T.jsx(Dt, { className: Je("text-left ", b && H.length <= 0 ? "text-red-400" : ""), htmlFor: "address", children: "Address" }), T.jsx(ln, { onChange: E => { $(E.target.value) }, className: Je("grid gap-2 ", b && H.length <= 0 ? "bg-red-50 focus-visible:ring-red-500 border-red-500 focus-visible:border-transparent" : ""), id: "address", placeholder: "Enter your address" })] }), T.jsx("div", { className: "grid gap-4", children: T.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [T.jsxs("div", { className: "grid gap-2", children: [T.jsx(Dt, { className: Je("text-left ", b && W.length <= 0 ? "text-red-400" : ""), htmlFor: "shape", children: "State" }), T.jsxs(_P, { onValueChange: X, className: Je("bg-white", b && W.length <= 0 ? "bg-red-50 focus-visible:ring-red-500 border-red-500 focus-visible:border-transparent" : ""), children: [T.jsx(yg, { className: Je(b && W.length <= 0 ? "bg-red-50 focus-visible:ring-red-500 border-red-500 focus-visible:border-transparent" : ""), children: T.jsx(IP, { placeholder: "Select State" }) }), T.jsx(Sg, { className: "bg-white border-gray-200 rounded", children: Object.keys(bg).map(E => T.jsx(Cg, { value: E, children: bg[E] }, E)) })] })] }), T.jsxs("div", { className: "grid gap-2", children: [T.jsx(Dt, { className: Je("text-left ", b && oe.length <= 0 ? "text-red-400" : ""), htmlFor: "zip", children: "Zip/Postal" }), T.jsx(ln, { id: "zip", onChange: E => { me(E.target.value) }, className: Je("grid gap-2 ", b && oe.length <= 0 ? "bg-red-50 focus-visible:ring-red-500 border-red-500 focus-visible:border-transparent" : ""), placeholder: "Enter your zip/postal code" })] })] }) }), T.jsx(Ah, {}), T.jsxs("div", { className: "grid gap-2", children: [T.jsx(Dt, { className: "text-left", htmlFor: "description", children: "Comments" }), T.jsx(Ph, { id: "comments", placeholder: "Provide any additional information or instructions" })] })] }) }), T.jsx(gu, { children: T.jsx(Fo, { className: "relative w-full", onClick: E => { E.preventDefault(), se() }, children: "Send me a quote" }) })] })] }) }) }); kg.displayName = "StartQuoteFrom"; const zP = () => { const [t, r] = w.useState(!1), [o, s] = w.useState(!0), [l, d] = w.useState({}), [u, f] = w.useState(!1), [h, m] = w.useState({ height: "0px", width: "0px" }), v = async () => { if (!(Object.keys(l).length > 0)) try { const M = await fetch("https://quotegen.net/api/v1/flow/get"); if (!M.ok) throw new Error(`Error fetching data: ${M.statusText}`); const j = await M.json(); d(j) } catch (M) { console.error("Failed to fetch quote data:", M) } finally { s(!1) } }; w.useEffect(() => { t && v() }, [t]); const g = () => { r(!0); const M = window.innerWidth; M <= 768 ? m({ height: `${window.innerHeight - 80}px`, width: `${M - 18}px` }) : m({ height: `${window.innerHeight * .8}px`, width: "768px" }) }, [x, C] = w.useState(!1), b = () => { C(!0) }, S = () => { C(!1) }, P = async M => { try { const j = { business_id: l.id, data: M.history, customer: M.customer }; fetch("https://quotegen.net/api/v1/flow/set", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(j) }).then(I => I.json()).then(I => { console.log(I), f(!0), setTimeout(() => { r(!1) }, 3e3) }).catch(I => console.error("Error:", I)) } catch (j) { console.error("Failed to submit quote data:", j) } }, R = w.useRef(), N = () => { g() }; return w.useEffect(() => (window.handleExternalQuoteButtonClick = N, () => { delete window.handleExternalQuoteButtonClick }), []), T.jsxs(sr.div, { layout: !0, initial: { borderRadius: "2rem" }, animate: t ? { borderRadius: "0.5rem" } : { borderRadius: "2rem" }, className: Je("widget select-none fixed right-4 bottom-4 bg-white dark:bg-slate-900 z-50 w-fit overflow-hidden border py-2 shadow-sm dark:border-neutral-800 ", t ? "right-2 bottom-2 md:right-4 md:bottom-4" : ""), children: [T.jsx("span", { className: "flex items-center justify-center h-9 px-4 cursor-pointer", onClick: () => { g() }, children: T.jsx("div", { className: Je("text-black font-semibold dark:text-neutral-400", t ? "text-lg" : "text-base"), children: "Get an instant Quote" }) }), x && t && !u && T.jsx("button", { onClick: () => { R.current.callGoBack() }, className: "flex cursor-pointer absolute left-2 top-2.5 rounded-sm hover:bg-gray-50 h-8 min-h-8 w-8 min-w-8 items-center justify-center ", children: T.jsx(E0, { strokeWidth: 2.5, size: 22, className: "text-black dark:text-gray-600" }) }), t && T.jsx("button", { onClick: () => { r(!1) }, className: "flex cursor-pointer absolute right-2 top-2.5 rounded-sm hover:bg-gray-50 h-8 min-h-8 w-8 min-w-8 items-center justify-center ", children: T.jsx(A0, { strokeWidth: 2.5, size: 16, className: "text-black dark:text-gray-600" }) }), T.jsx(sr.div, { "aria-hidden": !t, initial: { height: 0, translateY: 15 }, transition: { ease: "easeInOut", duration: .3 }, className: Je("flex flex-col w-full", t ? "mt-[-10px]" : ""), animate: t ? h : {}, children: T.jsx(qS, { children: o ? T.jsxs("div", { className: "flex flex-col ", children: [T.jsx(jr, { className: "h-2 rounded-none w-full" }), T.jsxs("div", { className: " pt-12 px-4 flex flex-col  items-center", children: [T.jsx(jr, { className: "h-52 w-full rounded-xl" }), T.jsxs("div", { className: "flex flex-col gap-8 w-full pt-8 items-center", children: [T.jsx(jr, { className: "h-10 w-4/5" }), T.jsx(jr, { className: "h-10 w-4/5" }), T.jsx(jr, { className: "h-10 w-4/5" }), T.jsx(jr, { className: "h-10 w-4/5" })] })] })] }) : T.jsx(T.Fragment, { children: u && t ? T.jsxs(sr.div, { variants: BP, initial: "hidden", animate: "show", className: "flex h-full w-full flex-col items-center justify-center gap-2 text-sm font-normal", children: [T.jsx(sr.div, { variants: vu, className: "flex h-8 min-h-8 w-8 min-w-8 items-center justify-center rounded-full bg-blue-500 dark:bg-sky-500", children: T.jsx(xd, { strokeWidth: 2.5, size: 16, className: "stroke-white" }) }), T.jsx(sr.div, { variants: vu, children: "You will receive a quote to your email shortly." }), T.jsx(sr.div, { variants: vu, children: "Thank you for choosing us." })] }) : T.jsx(T.Fragment, { children: Object.keys(l).length > 0 && T.jsx(T.Fragment, { children: t && T.jsx("div", { className: "h-full flex flex-col pb-3", children: T.jsx(kg, { ref: R, onCallSubmit: P, flowData: l, onShowGoBackButton: b, onHideGoBackButton: S }) }) }) }) }) }) })] }) }, BP = { hidden: { opacity: 0, y: 20 }, show: { opacity: 1, y: 0, transition: { duration: .2, staggerChildren: .04 } } }, vu = { hidden: { y: 10 }, show: { y: 0 } }, UP = `*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}.widget{--background: 0 0% 100%;--foreground: 222.2 84% 4.9%;--card: 0 0% 100%;--card-foreground: 222.2 84% 4.9%;--popover: 0 0% 100%;--popover-foreground: 222.2 84% 4.9%;--primary: 222.2 47.4% 11.2%;--primary-foreground: 210 40% 98%;--secondary: 210 40% 96.1%;--secondary-foreground: 222.2 47.4% 11.2%;--muted: 210 40% 96.1%;--muted-foreground: 215.4 16.3% 46.9%;--accent: 210 40% 96.1%;--accent-foreground: 222.2 47.4% 11.2%;--destructive: 0 84.2% 60.2%;--destructive-foreground: 210 40% 98%;--border: 214.3 31.8% 91.4%;--input: 214.3 31.8% 91.4%;--ring: 222.2 84% 4.9%;--radius: .5rem}.dark .widget{--background: 222.2 84% 4.9%;--foreground: 210 40% 98%;--card: 222.2 84% 4.9%;--card-foreground: 210 40% 98%;--popover: 222.2 84% 4.9%;--popover-foreground: 210 40% 98%;--primary: 210 40% 98%;--primary-foreground: 222.2 47.4% 11.2%;--secondary: 217.2 32.6% 17.5%;--secondary-foreground: 210 40% 98%;--muted: 217.2 32.6% 17.5%;--muted-foreground: 215 20.2% 65.1%;--accent: 217.2 32.6% 17.5%;--accent-foreground: 210 40% 98%;--destructive: 0 62.8% 30.6%;--destructive-foreground: 210 40% 98%;--border: 217.2 32.6% 17.5%;--input: 217.2 32.6% 17.5%;--ring: 212.7 26.8% 83.9%}*{border-color:hsl(var(--border))}body{background-color:hsl(var(--background));color:hsl(var(--foreground))}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }.container{width:100%;margin-right:auto;margin-left:auto;padding-right:2rem;padding-left:2rem}@media (min-width: 1400px){.container{max-width:1400px}}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.bottom-2{bottom:.5rem}.bottom-4{bottom:1rem}.left-2{left:.5rem}.right-2{right:.5rem}.right-4{right:1rem}.top-0{top:0}.top-2{top:.5rem}.top-2\\.5{top:.625rem}.z-50{z-index:50}.-mx-1{margin-left:-.25rem;margin-right:-.25rem}.mx-auto{margin-left:auto;margin-right:auto}.my-1{margin-top:.25rem;margin-bottom:.25rem}.my-2{margin-top:.5rem;margin-bottom:.5rem}.my-8{margin-top:2rem;margin-bottom:2rem}.mb-1{margin-bottom:.25rem}.mb-2{margin-bottom:.5rem}.mb-4{margin-bottom:1rem}.mb-6{margin-bottom:1.5rem}.mr-2{margin-right:.5rem}.mt-2{margin-top:.5rem}.mt-3{margin-top:.75rem}.mt-4{margin-top:1rem}.mt-8{margin-top:2rem}.mt-\\[-10px\\]{margin-top:-10px}.inline{display:inline}.flex{display:flex}.inline-flex{display:inline-flex}.grid{display:grid}.hidden{display:none}.aspect-square{aspect-ratio:1 / 1}.h-10{height:2.5rem}.h-11{height:2.75rem}.h-16{height:4rem}.h-2{height:.5rem}.h-24{height:6rem}.h-3{height:.75rem}.h-3\\.5{height:.875rem}.h-4{height:1rem}.h-5{height:1.25rem}.h-52{height:13rem}.h-6{height:1.5rem}.h-8{height:2rem}.h-9{height:2.25rem}.h-\\[1px\\]{height:1px}.h-\\[var\\(--radix-select-trigger-height\\)\\]{height:var(--radix-select-trigger-height)}.h-fit{height:-moz-fit-content;height:fit-content}.h-full{height:100%}.h-px{height:1px}.max-h-96{max-height:24rem}.min-h-44{min-height:11rem}.min-h-8{min-height:2rem}.min-h-\\[80px\\]{min-height:80px}.w-10{width:2.5rem}.w-3{width:.75rem}.w-3\\.5{width:.875rem}.w-4{width:1rem}.w-4\\/5{width:80%}.w-5{width:1.25rem}.w-6{width:1.5rem}.w-72{width:18rem}.w-8{width:2rem}.w-\\[1px\\]{width:1px}.w-fit{width:-moz-fit-content;width:fit-content}.w-full{width:100%}.min-w-72{min-width:18rem}.min-w-8{min-width:2rem}.min-w-\\[8rem\\]{min-width:8rem}.min-w-\\[var\\(--radix-select-trigger-width\\)\\]{min-width:var(--radix-select-trigger-width)}.max-w-md{max-width:28rem}.flex-1{flex:1 1 0%}.shrink-0{flex-shrink:0}@keyframes pulse{50%{opacity:.5}}.animate-pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}@keyframes spin{to{transform:rotate(360deg)}}.animate-spin{animation:spin 1s linear infinite}.cursor-default{cursor:default}.cursor-pointer{cursor:pointer}.select-none{-webkit-user-select:none;-moz-user-select:none;user-select:none}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.flex-row{flex-direction:row}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-start{justify-content:flex-start}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-0{gap:0px}.gap-0\\.5{gap:.125rem}.gap-1{gap:.25rem}.gap-1\\.5{gap:.375rem}.gap-2{gap:.5rem}.gap-4{gap:1rem}.gap-8{gap:2rem}.space-y-1>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.25rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.25rem * var(--tw-space-y-reverse))}.space-y-1\\.5>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.375rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.375rem * var(--tw-space-y-reverse))}.space-y-2>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem * var(--tw-space-y-reverse))}.space-y-4>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(1rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1rem * var(--tw-space-y-reverse))}.space-y-6>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1.5rem * var(--tw-space-y-reverse))}.overflow-hidden{overflow:hidden}.overflow-y-scroll{overflow-y:scroll}.truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.whitespace-nowrap{white-space:nowrap}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:var(--radius)}.rounded-md{border-radius:calc(var(--radius) - 2px)}.rounded-none{border-radius:0}.rounded-sm{border-radius:calc(var(--radius) - 4px)}.rounded-xl{border-radius:.75rem}.border{border-width:1px}.border-2{border-width:2px}.border-b{border-bottom-width:1px}.border-solid{border-style:solid}.border-dashed{border-style:dashed}.border-none{border-style:none}.border-destructive\\/50{border-color:hsl(var(--destructive) / .5)}.border-gray-100{--tw-border-opacity: 1;border-color:rgb(243 244 246 / var(--tw-border-opacity))}.border-gray-200{--tw-border-opacity: 1;border-color:rgb(229 231 235 / var(--tw-border-opacity))}.border-input{border-color:hsl(var(--input))}.border-primary{border-color:hsl(var(--primary))}.border-red-500{--tw-border-opacity: 1;border-color:rgb(239 68 68 / var(--tw-border-opacity))}.bg-background{background-color:hsl(var(--background))}.bg-black{--tw-bg-opacity: 1;background-color:rgb(0 0 0 / var(--tw-bg-opacity))}.bg-blue-500{--tw-bg-opacity: 1;background-color:rgb(59 130 246 / var(--tw-bg-opacity))}.bg-border{background-color:hsl(var(--border))}.bg-card{background-color:hsl(var(--card))}.bg-destructive{background-color:hsl(var(--destructive))}.bg-gray-100{--tw-bg-opacity: 1;background-color:rgb(243 244 246 / var(--tw-bg-opacity))}.bg-gray-50{--tw-bg-opacity: 1;background-color:rgb(249 250 251 / var(--tw-bg-opacity))}.bg-muted{background-color:hsl(var(--muted))}.bg-popover{background-color:hsl(var(--popover))}.bg-primary{background-color:hsl(var(--primary))}.bg-red-50{--tw-bg-opacity: 1;background-color:rgb(254 242 242 / var(--tw-bg-opacity))}.bg-secondary{background-color:hsl(var(--secondary))}.bg-slate-100{--tw-bg-opacity: 1;background-color:rgb(241 245 249 / var(--tw-bg-opacity))}.bg-white{--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.stroke-white{stroke:#fff}.object-cover{-o-object-fit:cover;object-fit:cover}.p-1{padding:.25rem}.p-1\\.5{padding:.375rem}.p-2{padding:.5rem}.p-3{padding:.75rem}.p-4{padding:1rem}.p-6{padding:1.5rem}.px-2{padding-left:.5rem;padding-right:.5rem}.px-3{padding-left:.75rem;padding-right:.75rem}.px-4{padding-left:1rem;padding-right:1rem}.px-8{padding-left:2rem;padding-right:2rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-1\\.5{padding-top:.375rem;padding-bottom:.375rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.py-3{padding-top:.75rem;padding-bottom:.75rem}.py-8{padding-top:2rem;padding-bottom:2rem}.pb-3{padding-bottom:.75rem}.pl-8{padding-left:2rem}.pr-2{padding-right:.5rem}.pt-0{padding-top:0}.pt-12{padding-top:3rem}.pt-8{padding-top:2rem}.text-left{text-align:left}.text-center{text-align:center}.text-2xl{font-size:1.5rem;line-height:2rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.text-\\[0\\.7rem\\]{font-size:.7rem}.text-\\[0\\.85rem\\]{font-size:.85rem}.text-base{font-size:1rem;line-height:1.5rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-xs{font-size:.75rem;line-height:1rem}.font-bold{font-weight:700}.font-medium{font-weight:500}.font-normal{font-weight:400}.font-semibold{font-weight:600}.leading-none{line-height:1}.leading-snug{line-height:1.375}.leading-tight{line-height:1.25}.tracking-tight{letter-spacing:-.025em}.text-black{--tw-text-opacity: 1;color:rgb(0 0 0 / var(--tw-text-opacity))}.text-card-foreground{color:hsl(var(--card-foreground))}.text-current{color:currentColor}.text-destructive{color:hsl(var(--destructive))}.text-destructive-foreground{color:hsl(var(--destructive-foreground))}.text-foreground{color:hsl(var(--foreground))}.text-gray-400{--tw-text-opacity: 1;color:rgb(156 163 175 / var(--tw-text-opacity))}.text-gray-500{--tw-text-opacity: 1;color:rgb(107 114 128 / var(--tw-text-opacity))}.text-muted-foreground{color:hsl(var(--muted-foreground))}.text-popover-foreground{color:hsl(var(--popover-foreground))}.text-primary{color:hsl(var(--primary))}.text-primary-foreground{color:hsl(var(--primary-foreground))}.text-red-400{--tw-text-opacity: 1;color:rgb(248 113 113 / var(--tw-text-opacity))}.text-red-600{--tw-text-opacity: 1;color:rgb(220 38 38 / var(--tw-text-opacity))}.text-secondary-foreground{color:hsl(var(--secondary-foreground))}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.underline-offset-4{text-underline-offset:4px}.opacity-50{opacity:.5}.opacity-65{opacity:.65}.shadow-md{--tw-shadow: 0 4px 6px -1px rgb(0 0 0 / .1), 0 2px 4px -2px rgb(0 0 0 / .1);--tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-none{--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-sm{--tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);--tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline-none{outline:2px solid transparent;outline-offset:2px}.outline{outline-style:solid}.ring-offset-background{--tw-ring-offset-color: hsl(var(--background))}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}@keyframes enter{0%{opacity:var(--tw-enter-opacity, 1);transform:translate3d(var(--tw-enter-translate-x, 0),var(--tw-enter-translate-y, 0),0) scale3d(var(--tw-enter-scale, 1),var(--tw-enter-scale, 1),var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0))}}@keyframes exit{to{opacity:var(--tw-exit-opacity, 1);transform:translate3d(var(--tw-exit-translate-x, 0),var(--tw-exit-translate-y, 0),0) scale3d(var(--tw-exit-scale, 1),var(--tw-exit-scale, 1),var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0))}}.no-scrollbar::-webkit-scrollbar{display:none}.no-scrollbar{-ms-overflow-style:none;scrollbar-width:none}.file\\:border-0::file-selector-button{border-width:0px}.file\\:bg-transparent::file-selector-button{background-color:transparent}.file\\:text-sm::file-selector-button{font-size:.875rem;line-height:1.25rem}.file\\:font-medium::file-selector-button{font-weight:500}.placeholder\\:text-muted-foreground::-moz-placeholder{color:hsl(var(--muted-foreground))}.placeholder\\:text-muted-foreground::placeholder{color:hsl(var(--muted-foreground))}.hover\\:bg-accent:hover{background-color:hsl(var(--accent))}.hover\\:bg-destructive\\/90:hover{background-color:hsl(var(--destructive) / .9)}.hover\\:bg-gray-50:hover{--tw-bg-opacity: 1;background-color:rgb(249 250 251 / var(--tw-bg-opacity))}.hover\\:bg-primary\\/90:hover{background-color:hsl(var(--primary) / .9)}.hover\\:bg-secondary\\/80:hover{background-color:hsl(var(--secondary) / .8)}.hover\\:text-accent-foreground:hover{color:hsl(var(--accent-foreground))}.hover\\:underline:hover{text-decoration-line:underline}.hover\\:shadow-md:hover{--tw-shadow: 0 4px 6px -1px rgb(0 0 0 / .1), 0 2px 4px -2px rgb(0 0 0 / .1);--tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.focus\\:bg-accent:focus{background-color:hsl(var(--accent))}.focus\\:text-accent-foreground:focus{color:hsl(var(--accent-foreground))}.focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\\:ring-2:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\\:ring-ring:focus{--tw-ring-color: hsl(var(--ring))}.focus\\:ring-offset-2:focus{--tw-ring-offset-width: 2px}.focus-visible\\:border-transparent:focus-visible{border-color:transparent}.focus-visible\\:outline-none:focus-visible{outline:2px solid transparent;outline-offset:2px}.focus-visible\\:ring-2:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus-visible\\:ring-red-500:focus-visible{--tw-ring-opacity: 1;--tw-ring-color: rgb(239 68 68 / var(--tw-ring-opacity))}.focus-visible\\:ring-ring:focus-visible{--tw-ring-color: hsl(var(--ring))}.focus-visible\\:ring-offset-2:focus-visible{--tw-ring-offset-width: 2px}.disabled\\:pointer-events-none:disabled{pointer-events:none}.disabled\\:cursor-not-allowed:disabled{cursor:not-allowed}.disabled\\:opacity-50:disabled{opacity:.5}.peer:disabled~.peer-disabled\\:cursor-not-allowed{cursor:not-allowed}.peer:disabled~.peer-disabled\\:opacity-70{opacity:.7}.data-\\[side\\=bottom\\]\\:translate-y-1[data-side=bottom]{--tw-translate-y: .25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[side\\=left\\]\\:-translate-x-1[data-side=left]{--tw-translate-x: -.25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[side\\=right\\]\\:translate-x-1[data-side=right]{--tw-translate-x: .25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[side\\=top\\]\\:-translate-y-1[data-side=top]{--tw-translate-y: -.25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[state\\=checked\\]\\:bg-primary[data-state=checked]{background-color:hsl(var(--primary))}.data-\\[state\\=checked\\]\\:text-primary-foreground[data-state=checked]{color:hsl(var(--primary-foreground))}.data-\\[state\\=open\\]\\:animate-in[data-state=open]{animation-name:enter;animation-duration:.15s;--tw-enter-opacity: initial;--tw-enter-scale: initial;--tw-enter-rotate: initial;--tw-enter-translate-x: initial;--tw-enter-translate-y: initial}.data-\\[state\\=closed\\]\\:animate-out[data-state=closed]{animation-name:exit;animation-duration:.15s;--tw-exit-opacity: initial;--tw-exit-scale: initial;--tw-exit-rotate: initial;--tw-exit-translate-x: initial;--tw-exit-translate-y: initial}.data-\\[state\\=closed\\]\\:fade-out-0[data-state=closed]{--tw-exit-opacity: 0}.data-\\[state\\=open\\]\\:fade-in-0[data-state=open]{--tw-enter-opacity: 0}.data-\\[state\\=closed\\]\\:zoom-out-95[data-state=closed]{--tw-exit-scale: .95}.data-\\[state\\=open\\]\\:zoom-in-95[data-state=open]{--tw-enter-scale: .95}.data-\\[side\\=bottom\\]\\:slide-in-from-top-2[data-side=bottom]{--tw-enter-translate-y: -.5rem}.data-\\[side\\=left\\]\\:slide-in-from-right-2[data-side=left]{--tw-enter-translate-x: .5rem}.data-\\[side\\=right\\]\\:slide-in-from-left-2[data-side=right]{--tw-enter-translate-x: -.5rem}.data-\\[side\\=top\\]\\:slide-in-from-bottom-2[data-side=top]{--tw-enter-translate-y: .5rem}.dark\\:border-destructive:is(.dark *){border-color:hsl(var(--destructive))}.dark\\:border-neutral-800:is(.dark *){--tw-border-opacity: 1;border-color:rgb(38 38 38 / var(--tw-border-opacity))}.dark\\:bg-sky-500:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(14 165 233 / var(--tw-bg-opacity))}.dark\\:bg-slate-900:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(15 23 42 / var(--tw-bg-opacity))}.dark\\:text-gray-600:is(.dark *){--tw-text-opacity: 1;color:rgb(75 85 99 / var(--tw-text-opacity))}.dark\\:text-neutral-400:is(.dark *){--tw-text-opacity: 1;color:rgb(163 163 163 / var(--tw-text-opacity))}@media (min-width: 640px){.sm\\:p-8{padding:2rem}.sm\\:text-3xl{font-size:1.875rem;line-height:2.25rem}}@media (min-width: 768px){.md\\:bottom-4{bottom:1rem}.md\\:right-4{right:1rem}.md\\:grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}}.\\[\\&\\>span\\]\\:line-clamp-1>span{overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}.\\[\\&\\>svg\\+div\\]\\:translate-y-\\[-3px\\]>svg+div{--tw-translate-y: -3px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.\\[\\&\\>svg\\]\\:absolute>svg{position:absolute}.\\[\\&\\>svg\\]\\:left-4>svg{left:1rem}.\\[\\&\\>svg\\]\\:top-4>svg{top:1rem}.\\[\\&\\>svg\\]\\:text-destructive>svg{color:hsl(var(--destructive))}.\\[\\&\\>svg\\]\\:text-foreground>svg{color:hsl(var(--foreground))}.\\[\\&\\>svg\\~\\*\\]\\:pl-7>svg~*{padding-left:1.75rem}.\\[\\&_p\\]\\:leading-relaxed p{line-height:1.625}
`, WP = ({ projectId: t }) => T.jsxs(T.Fragment, { children: [T.jsx("style", { children: UP }), T.jsx(zP, {})] }), $P = t => t.replace(/-([a-z])/g, (r, o) => o.toUpperCase()); class HP extends HTMLElement { constructor() { super(), this.attachShadow({ mode: "open" }) } connectedCallback() { const r = this.getPropsFromAttributes(); Na.createRoot(this.shadowRoot).render(T.jsx(WP, { ...r })) } getPropsFromAttributes() { const r = {}; for (const { name: o, value: s } of this.attributes) r[$P(o)] = s; return r } } document.body.appendChild(document.createElement("my-widget")), document.querySelectorAll('button[data="start-quote-button"]').forEach(t => { t.addEventListener("click", () => { window.handleExternalQuoteButtonClick() }) }), customElements.define("my-widget", HP)
});
